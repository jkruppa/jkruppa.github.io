```{r echo = FALSE}
#| message: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, patchwork, ggimage,
               plotly, conflicted)
conflicts_prefer(plotly::layout)
conflicts_prefer(dplyr::filter)
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
source("images/R/stat-modeling-R.R")
source("images/R/stat-modeling-basic.R")
set.seed(20250708)
theme_modeling <- function() {
  theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          plot.background = element_rect(fill = "white", color = NA),
          plot.title = element_text(size = 16, face = "bold"),
          plot.subtitle = element_text(size = 12, face = "italic"),
          plot.caption = element_text(face = "italic"),
          axis.title = element_text(size = 12, face = "bold"),
          axis.text = element_text(size = 12),
          strip.text = element_text(face = "bold"),
          strip.background = element_rect(fill = "grey80", color = NA))
}
```

# Multiple lineare Regression {#sec-mult-reg-basic}

*Letzte Änderung am `r format(fs::file_info("stat-modeling-basic.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

> *"All models are approximations. Essentially, all models are wrong, but some are useful. However, the approximate nature of the model must always be borne in mind." --- George E. P. Box*

![](images/caution.png){fig-align="center" width="100%"}

::: {.callout-caution appearance="simple"}
## Stand des Kapitels: Konstruktion (seit 07.2025)

Dieses Kapitel wird in den nächsten Wochen geschrieben und ist damit meine aktuelle Großbaustelle. Ich plane zum Beginn des WiSe 2025/26 eine fertige Version des Kapitels erstellt zu haben. Während das Kapitel entsteht, funktioniert so manches dann nicht so wie es soll. Bitte daher hier dann abwarten.
:::

In diesem Kapitel geht es um die multiple lineare Regression. Der große Unterschied zu der simplen linearen Regression ist, dass wir in der multiplen Regression mehr als eine Einflussvariable vorliegen haben. Damit wird unser Modell um einiges komplexer. Hier gibt es jetzt gewisse Überschneidungen mit den [Marginal effect models](#sec-marginal), die im Prinzip die Erweiterung der multiplen Regression sind. Wir können mit den *Marginal effect models* eben dann doch etwas anders lineare und nicht linare Regressionen interpretieren. Damit kannst du in dem Kapitel dann mehr über eine alternative Art der Interpretation von multiplen Modellen lernen. Ebenso gehe nicht hier so stark auf das [Modellieren in R](#sec-modeling-R) ein. Hier kannst du dann in dem entsprechenden Kapitel auch nochmal mehr lesen. Hier zeige ich dann die Basisanwendungen. Am Ende habe ich mich auch entschieden hier nur einen normalverteilten Messwert zu betrachten. Sonst wird es einfach viel zu komplex, wenn wir hier noch andere Verteilungen berücksichtigen. Dazu dann mehr in den entsprechenden [Kapiteln zur statistischen Modellierung](https://jkruppa.github.io/stat-modeling-preface.html).

::: {layout="[15,85]" layout-valign="top"}
![](images/personal_opinion.png){fig-align="center" width="100%"}

> *"In den folgenden Kapiteln gibt es immer mal wieder Redundanzen. Teilweise sind diese Redundanzen gewollt, denn eine gute Wiederholung hilft ja immer. Meistens habe ich aber den Überblick verloren und fand, dass das Thema dann an der Stelle doch nochmal gut reinpasste. Ist so passiert." --- Jochen Kruppa-Scheetz, meiner bescheidener Meinung nach.*
:::

## Allgemeiner Hintergrund

> *"This idea of 'holding everything constant' though can be tricky to wrap your head around." --- [Andrew Heiss](https://www.andrewheiss.com/blog/2022/05/20/marginalia/#regression-sliders-switches-and-mixing-boards)*

Wenn wir über die multiple lineare Regression sprechen, dann sprechen wir immer über mehr als eine Einflussvariable. Dadurch können wir den Fall haben, dass wir nicht nur eine Kovariate sondern mehrere Kovariaten in einem Modell vorliegen haben. Zum Beispiel wollen wir wissen, ob die Sprungweite von dem Gewicht der Flöhe oder der Anzahl an Beinhaaren abhängt. Wir haben hier also mehrere kontinuierliche Einflussvariablen vorliegen. Ebenso können wir den Fall haben, dass uns nur kategoriale Einflussvariablen interessieren. Hat die Ernährungsform oder aber der Entwicklungsstand einen Einfluss auf die Sprungweite der Flöhe. Klassischerweise wären wir hier zwar auf dem ANOVA Pfad eines faktoriellen Experiments, aber wir können natürlich die Koeffzienten eines mehfaktoriellen Modells in der Form einer multiplen Regression interpretieren. Wenn wir dann keinen normalverteilten Messwert haben, dann bietet sich natürlich dennoch die multiple Regression als eine Analyseform an. Abschließend können wir natürlich auch kombinierte Modelle vorliegen haben. Wir haben also in unseren multiple Modell nicht nur Kovariaten oder Faktoren sondern eben eine Mischung aus beiden Formen. Das führt dann zu einer noch komplexeren Interpretation. Alle Fälle wollen wir uns hier in diesem Kapitel einmal an einem normalverteilten Messwert anschauen.

#### Sprachlicher Hintergrund {.unnumbered .unlisted}

> *"In statistics courses taught by statisticians we don't use independent variable because we use independent on to mean stochastic independence. Instead we say predictor or covariate (either). And, similarly, we don't say "dependent variable" either. We say response." --- [User berf auf r/AskStatistics](https://www.reddit.com/r/AskStatistics/comments/qt1hvu/comment/hkigiks/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)*

Wenn wir uns mit dem statistischen Modellieren beschäftigen wollen, dann brauchen wir auch Worte um über das Thema reden zu können. Statistik wird in vielen Bereichen der Wissenschaft verwendet und in jedem Bereich nennen wir dann auch Dinge anders, die eigentlich gleich sind. Daher werde ich mir es hier herausnehmen und auch die Dinge so benennen, wie ich sie für didaktisch sinnvoll finde. Wir wollen hier was verstehen und lernen, somit brauchen wir auch eine klare Sprache.

::: {layout="[15,85]" layout-valign="top"}
![](images/personal_opinion.png){fig-align="center" width="100%"}

> *"Jeder nennt in der Statistik sein Y und X wie er möchte. Da ich hier nicht nur von Y und X schreiben will, führe ich eben die Worte ein, die ich nutzen will. Damit sind die Worte dann auch richtig, da der Kontext definiert ist. Andere mögen es dann anders machen. Ich mache es eben dann so. Danke." --- Jochen Kruppa-Scheetz, meiner bescheidener Meinung nach.*
:::

In dem folgenden Kasten erkläre ich nochmal den Gebrauch meiner Begriffe im statistischen Testen. Es ist wichtig, dass wir hier uns klar verstehen. Zum einen ist es angenehmer auch mal ein Wort für ein Symbol zu schreiben. Auf der anderen Seite möchte ich aber auch, dass du dann das Wort richtig einem Konzept im statistischen Modellieren zuordnen kannst. Deshalb einmal hier meine persönliche und didaktische Zusammenstellung meiner Wort im statistischen Modellieren. Du kannst dann immer zu dem Kasten zurückgehen, wenn wir mal ein Wort nicht mehr ganz klar ist. Die fetten Begriffe sind die üblichen in den folgenden Kapiteln. Die anderen Worte werden immer mal wieder in der Literatur genutzt.

{{< include stat-modeling/stat-modeling-callout-words.qmd >}}

#### Wie multiple Einflussvariablen interpretieren? {.unnumbered .unlisted}

Wie schon im Zitat am Anfang erwähnt, heißt die Regel, dass wir jeden Koeffizienten unseres Modell nur in soweit interpretieren können, wenn sich die anderen Einflussvariablen nicht ändern. Das klingt jetzt kryptisch und macht eigentlich nur Sinn, wenn man schon alles verstanden hat. Deshalb hier einmal die Analogie mit Schaltern und Schieberegelern. Wir können eine kategoriale Variable oder Faktor durch die Level durchschalten. Daher können wir uns den Effekt von weiblichen oder männlichen Flöhen anschauen. Es gibt aber nur diese beiden Möglichkeiten. Entweder steht der Schalter auf männlichen Floh oder aber auf weiblichen Floh. Etwas anderes ist es wenn wir uns eine Kovariate vorliegen haben. Eine kontinuierliche Einflussvariable können wir beliebig einstellen. Wir können das Gewicht eines Flohs eben hin und herschieben um einen Wert zu haben.

![Unterschied zwischen einer kategorialen Variable und einer kontinuierlichen Variable in einem statistischen Modell visualisiert als Schalter und Schieberegler. Übersetzt nach @heiss2022](images/marginal/slider-switch-annotated-trans.png){#fig-utest-intro-01 fig-align="center" width="100%"}

In einer multiplen Regression kombinieren wir nun alles miteinander. Wir haben eben eine Art Mischpult vorliegen. Auf unserem Mischpult finden wir eben Schalter und Schieberegler. Wir haben dann auch in unserem Modell Faktoren und Kovariaten vorliegen. Dann können wir auch Schalter auf verschiedene Positionen setzen und die Regler verschieden einstellen.

![Kombination verschiedener kategorialer Variablen und kontinuierlichen Variablen in einem statistischen Modell visualisiert als Mischpult. Übersetzt nach @heiss2022](images/marginal/mixer-board-annotated-trans.png){#fig-utest-intro-02 fig-align="center" width="100%"}

Worher kommt nun die Interpretation, dass wir eine Einflussvaribale nur interpretieren können, wenn wir den Rest der Einflussvariablen konstant halten? Wenn wir an dem Schieberegler des Gewichts der Flöhe drehen, dann müssen die anderen Schalter und Regler still stehen. Wir interpretieren dann eben das sich änderende Gewicht, *für weibliche Flöhe unter der Ernährung mit Ketchup*. Wir können nicht global das gesmate Modell interpretieren. Einen Ausweg bieten die [Marginal effect models](#sec-marginal), aber diese werden wir in diesem Kapitel nur am Rande behandeln. Dafür ist das Thema zu komplex. Daher behalte ich Kopf, wenn wir später einzelne Einflussvariablen betrachten, dann tuen wir das immer im Kontext fixierter anderer Einflussvariablen.

#### Eine Frage der Einheit! {.unnumbered .unlisted}

Die Einheit von den Messwerten oder auch Kovariaten hat einen nicht zu unterschätzenden Einfluss auf die Interpretation der Koeffizienten oder eben der Effekt einer multiplen linearen Modellierung. Da wir ja mehrere Einflussvariablen vorliegen haben bist du schnell dabei die Koeffizienten der Steigung untereinander zu vergleichen. Dann kommt man schnell zu einem Schluss der eventuell nicht wahr ist. Ich zeige dir hier einmal in der folgenden Abbildung den Fall, wo wir visuell die gleiche Steigung in den Daten vorliegen haben. Was sich aber in den beiden Abbildungen fundamental unterscheidet ist die Einheit der Kovariate.

![Der Zusammenhang von Hohlstrunk Boniturnote und Kopfgewicht sowie Strunkdurchmesser. In dem Beispiel ist gut der Zusammenhang zwischen der Steigung und der Einheit der Kovariate zu erkennen.](images/corr_example_einheit.jpeg){#fig-corr-01 fig-align="center"}

In der linken Abbildung ist der Koeffizient der Steigung des Kopfgewichts $0.021$ mehr mittlere Boniturnote pro Gramm Kopfgewicht. Das wirkt sehr klein. Im Gegensatz ist der Koeffizient der Steigung des Strunkdurchmessers $5.15$ mehr mittlere Boniturnoten pro Zentimeter Strunkdurchmesser. Es wirkt als hätte der Strunkdurchmesser einen viel größeren Effekt als das Gewicht auf die Boniturnoten. Das ist aber ein Trugschluss, wie wir dann gleich nochmal sehen werden. Ich zeige dir den Zusammenhang hier nochmal in der Tabelle.

|                  | Kopfgewicht \[g\]          | Strunkdurchmesser \[cm\]   |
|:-----------------|----------------------------|----------------------------|
| Gradengleichung  | $y = 0.021 \cdot x - 8.42$ | $y = 5.15 \cdot x - 16.65$ |
| Bestimmtheitsmaß | $R^2 = 0.74$               | $R^2 = 0.93$               |
| Faktor Steigung  | $\times1$                  | $\times 245.24$            |

: Vergleich vom Kopfgewicht und dem Strunkdurchmesser nach Gradengleichung, Bestimmtheitsmaß und dem Faktor der Steigung für Strunkdurchmesser. {#tbl-einheit}

Wir würden jetzt meinen, dass der Effekt des Strunkdurchmessers 245mal größer ist als der des Kopfgewichts. Das ist aber ein Trugschluss! Wir haben die Einheiten nicht beachtet. Die Spannweite bei dem Kopfgewicht geht von etwas über 450 Gramm bis fast 750 Gramm. Daher ist die Steigerung um eine Einheit nur eine kleine Menge mehr an Boniturnote. Bei dem Strunkdurchmesser haben wir als kleinsten Wert 3.5cm und als höchsten Wert 5cm für die Grade. Erhöhen wir den Strunkdurchmesser um 1 Zentimeter durchlaufen wir fast die gesamte Spannweite. Wenn du für den Vergleich eine einheitslose Steigung brauchst, dann schaue nochmal in dem [Kapitel zur Korrelation](#sec-lin-reg-corr) vorbei oder weiter unten in dem entsprechenden Abschnitt zur Einheit.

#### Wie verschiedene Modelle darstellen? {.unnumbered .unlisted}

Häufig stellt sich dann die Frage, wie so multiple Regressionsmodelle dargestellt werden können. Daher hier gleich einmal vorweg ein Beispiel für eine Darstellung einer multiplen linearen Regression in einer wissenschaftlichen Arbeit. In der Arbeit [Energy expenditure and obesity across the economic spectrum](https://www.pnas.org/doi/10.1073/pnas.2420902122) von @mcgrosky2025energy wird die multiple lineare Regression genutzt um den Zusammenhang von Energieaufnahme und dem Energieverbauch in veschiedenen Entwicklungsstufen von Ländern zu modellieren. Dabei kommt eigentlich ein recht spannendes Ergebnis heraus, wenn ich das einmal sehr kanpp zitieren darf. Es kommt eben mehr auf die Energieaufnahme als auf den Verbrauch an. Oder anders herum, wenn du abnehmen willst achte auf dein Essen und nicht so sehr auf deine Bewegung.

> *"Our analyses suggest that increased energy intake has been roughly 10 times more important than declining total energy expenditure (TEE) in driving the modern obesity crisis." --- @mcgrosky2025energy*

In der folgenden Tabelle siehst du dann eimal das multiple lineare Modell mit dem prozentualen Körperfettanteil als Messwert. Es wurden dann acht verschiedene multiple Modelle gerechnet und in jedem Modell wurden andere Einflussvariablen aufgenommen. In der vorletzten Zeile findest du dann noch das Bestimmtheitsmaß $R^2$, was dir angibt wie gut das Modell funktioniert hat. Hier wollen wir eigentlich einen Wert gegen Eins sehen, aber in Beobachtungsdaten wie hier, ist eine höhere Zahl erstmal eine bessere Zahl.

![Lineare Modelle für den Einfluss des Anteils ultraverarbeiteter Lebensmittel in der Ernährung (Anteil an der gesamten Kalorienaufnahme, %UPF) und des Fleischkonsums (kg pro Kopf) auf den Körperfettanteil. Signifikante Effekte (\*p\<0,05, \*\*p\<0,01, \*\*\*p\<0,001) in Fettdruck, negative Effekte in Blau. Quelle: @mcgrosky2025energy](images/mcgrosky2025energy.png){fig-align="center" width="100%"}

Was sagt uns jetzt die Tabelle aus? Zuerst einmal rechnen wir hier acht Modelle in den Spalten der Tabelle, die wir dann untereinander vergleichen. Wir nehmen verschiedene Einflussvariablen mit in das Modell, die alle in den Zeilen stehen. Teilweise ist das bei kategorialen Variablen wie dem Geschlecht die Gruppe angegeben. Wie interpretieren wir nun diese Tabelle? Hier einmal ein Auszug zu dem Einfluss des Fleischkonsum (eng. *per capita meat consumption*) in den letzten drei Spalten auf den Messwert Körperfetrprozent.

> *"\[...\], per capita meat consumption, another dietary change associated with development, was not significantly associated with fat percentage when added to models including percent ultraprocessed foods (UPF) \[i.e., industrial formulations of five or more ingredients (29)\]" --- @mcgrosky2025energy*

Was lesen wir hier? Wenn wir den Fleischkonsum zusammen mit den hochverarbeiteten Lebensmittel mit ins Modell nehmen, dann wird der Fleichkonsum nicht signifikant. Dies ist eine Art eine multiple lineare Regression zu rechnen und die Einflussvariablen untereinander zu vergleichen. Mehr dazu dann in den folgenden Abschnitten und den entsprechenden [Kapiteln zur statistischen Modellierung](https://jkruppa.github.io/stat-modeling-preface.html).

::: callout-note
## Defintion von hochverarbeiteten Lebensmittel (eng. *ultraprocessed foods*)

Wir können in der Abrbeit von @gibney2019ultra nocheinmal nachlesen, was die aktuelle Definition eines hochverarbeiteten Lebensmittel (eng. *ultraprocessed foods*) ist. Das ist ja immer wieder ein Streitpunkt, der aktuell ja auch noch offen ist. Wir halten uns einmal an die folgende Definition.

> *"Industrial formulations typically with 5 or more and usually many ingredients. Besides salt, sugar, oils, and fats, ingredients of ultra-processed foods include food substances not commonly used in culinary preparations, such as hydrolyzed protein, modified starches, and hydrogenated or interesterified oils, and additives whose purpose is to imitate sensorial qualities of unprocessed or minimally processed foods and their culinary preparations or to disguise undesirable qualities of the final product, such as colorants, flavorings, nonsugar sweeteners, emulsifiers, humectants, sequestrants, and firming, bulking, de-foaming, anticaking, and glazing agents." --- @gibney2019ultra*
:::

In diesem Kapitel findest du dann noch am Ende einige Abschnitte zu Dingen von Interesse. Wenn wir nämlich über den Effekt sprechen, dann müssen wir auch nochmal über die Einheiten von den Einflussvariablen sprechen. Wenn diese sehr unterschiedliche sind, dann kann das zu Problemen führen. Auch können Einflussvariablen mit sehr großen numerischen Werten ein Problem in der Interpretation sein. Dann schauen wir nochmal auf die Korrelation der Einflussvariablen. Eigentlich sollten ja alle Einflussvariablen untereinander unabhängig sein. Dann wollen wir nochmal schauen, wie wir den verschiedene multiple Modelle untereinander vergleichen können um das beste multiple Modell zu finden.

Jetzt kommen wir aber nochmal zu dem theoretischen Hintergrund. Wir wollen hier nochmal gleich verstehen, wie die multiplen Modelle aufgebaut sind und wie die Modelle in R dargestellt werden. Wenn du dich mit dem allgemeinen Hintergrund zufrieden gibst, dann kannst du auch gerne direkt in die Beispiele und deren Auswertung springen. Oder eben dann nochmal später zurückkommen, wenn der Bedarf besteht.

## Theoretischer Hintergrund

In dem theoretischen Hintergrund der multiplen Modelle bleibe ich etwas oberflächlich und gehe nicht auf die mathematischen Hintergründe tiefer ein. Das lohnt hier auch nicht weiter. In den Anwendungen habe ich dann immer noch die theoretische Berechnung in R ergänzt, die dir dann nochmal zeigt, wie in R intern die Modelle gerechnet werden. Ganz allgemein kann ich das Buch von @kery2010introduction wärmstens empfehlen. Dort habe ich viel über die Modelle und die Berechnungen gelernt. In dem Zusammenhang kann ich auch noch @dormann2013parametrische empfehlen, wenn es um die Maximum Likelihood Methode geht, die dort gut beschrieben ist. Ich gebe hier dann die Zusammenfassung wieder.

Beginnen wir nochmal mit dem klassischen statistischen Modell in der folgenden Abbildung. Wir haben Daten vorliegen, die wir in ein Modell und einen Fehler zerlegen wollen. Das liest sich sehr allgemein, in der Praxis haben wir auf der linken Seite den beobachteten Messwert Y stehen und auf der linken Seite das Modell aus dem der erklärte Anteil am Y rauskommt. Die Differenz zu den beobachteten Messwerten ist dann der Fehler. Somit ist unser Modell die Kombination aus dem Messwert und unseren Einflussvariablen. Was die Einflussvariablen an dem Messwert nicht erklären können wandert in den Fehler. Somit wollen wir einen geringen Fehler in unserer Modellierung.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 1.5
#| fig-width: 7
#| fig-cap: "Der Zusammenhang von Daten, dem statistischen Modell und dem Fehler. Das Modell versucht durch ein statistisches Modell $f(x)$ den Zusammenhang zwischen den Einflussvariablen dem Messwert zu erklären. Den Anteil des unerklärten Messwert geht in den Fehlerterm. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-model-abstract

p_model_abstract 
```

Erinnern wir uns nochmal an das simple und multiple lineares Modell. Die beiden Modelle entscheiden sich durch die Anzahl an Einflussvariablen. In der folgenden Abbildung siehst du nochmal das simple lineare Modell. Wir haben hier eine Einflussvariable X. Dann kommen noch die Koeffizienten $\beta_0$ für den Intercept und der Koeffizient $\beta_1$ für die Steigung der eine Einflussvariable hinzu. Alles was wir nicht durch die Grae erklären können, wandert dann in die Residuen oder Fehler $\epsilon$. Eine klassische Gradengleichung mit einer Einflussvariable.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2.25
#| fig-width: 7
#| fig-cap: "Formelschreibweise der simplen linearen Regression beinhaltend die Koeffizienten $\\beta_0$ für den y-Achsenabschnitt sowie $\\beta_1$ für die Steigung der Graden für eine Einflussvariable $x_1$. Die Residuen werden durch $\\epsilon$ abgebildet. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-07

p_simple_model
```

In diesem Kapitel erweitern wir das simple lineare Modell um mehr Einflussvariablen. Dann erhalten wir ein multiples lineares Modell wie in der folgenden Abbildung. Meistens haben wir dann mehr als zwei Einflussvariablen sondern eben $p$ Stück. Jede dieser Einflussvariablen hat dann eine eigene Stigung. Wir haben dann aber immer noch nur einen Intercept vorliegen. Auch haben wir dann am Ende nur einen Wert für die Residuen oder Fehler. Die Einflussvariablen können eine beliebige Kombination an Kovariten und Faktoren sein.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2.25
#| fig-width: 7
#| fig-cap: "Formelschreibweise der multiplen linearen Regression beinhaltend die Koeffizienten $\\beta_0$ für den y-Achsenabschnitt sowie $\\beta_1$ bis $\\beta_p$ für die partielle Steigung der Graden für jede Einflussvariable $x_1$ bis $x_p$. Die Residuen werden durch $\\epsilon$ abgebildet. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-04

p_mult_model 
```

Jetzt können wir uns nochmal die Formelschreibweise in R anschauen. Wir brauchen hier natürlich nicht die Koeffizienten zu benennen, denn wir wollen die Werte für die Steigung und den Intercept ja durch die multiple Regression bestimmen. Wir schreiben dann auf die linke Seite der Tilde `~` unseren Messwert und auf die rechte Seite dann die Einflussvariablen durch ein Plus `+` miteinander verbunden. Wir lernen dann im Kapitel zum [Modellieren in R](#sec-modeling-R) noch andere Möglichkeiten in der Formelschreibweise in R. Häufig reichen die Grundlagen aber aus.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Statistische Modellschreibweise in R mit dem Messwert auf der linken Seite und den Einflussvariablen auf der rechten Seite der Tilde. Die Platzhalter $Y$ und $X$ werden durch die Spaltennamen im Datensatz ersetzt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-22

p_lhs_rhs_mult_r 
```

Jetzt könnte man meinen, so kompliziert ist es ja dann doch nicht. Dafür musst du aber noch wissen, dass wir nicht nur eine Art von Messwert vorliegen haben. Jeder Messwert auf der linken Seite der Tilde folgt einer Verteilung. Zwar sind die Arten der Verteilungen in etwa begrenz, aber wir haben doch einige vorliegen. Daher müssen wir abhängig von der Verteilunsgfamilie noch die Regression ändern. In der folgenden Abbildung habe ich dir einmal den Zusammenhang der schrecklich netten Verteilunsgfamilie zusammengefasst. Wir müssen eben entscheiden, welcher Verteilungsfamilie unser Messwert angehört und dann eben schauen, wie unsere Einflussvariablen beschaffen sind. Daraus ergibt sich dann die Interpretation des statistischen Modells. Mehr dazu dann in den folgenden Abschnitten und den entsprechenden [Kapiteln zur statistischen Modellierung](https://jkruppa.github.io/stat-modeling-preface.html).

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.7
#| fig-width: 7
#| fig-cap: "Erweiterte Darstellung der statistischen Modellierung. Die Messwerte $Y$ folgen einer Verteilung. Die Einflussvariablen liegen kontinuierlich als Kovariaten oder aber kategorial als Faktoren vor. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-09

p_lhs_rhs_detail
```

Damit sind wir hier für das erste auch durch mit der theoretischen Betrachtung. Ich habe dann bei dem kausalen Modellen immer noch einen Tab ergänzt in dem ich mehr auf die Hinetrgründe eingehe. Wir wollen hier aber nichts händsich rechnen, so dass ich mich auf die praktsiche Umsetzung in R konzentriere. Teilweise gibt es dann wieder Überschneidungen mit der ANOVA oder anderen Kapiteln, aber das ist dann eben auch so gewollt.

::: {layout="[25,75]" layout-valign="center"}
![](images/angel_01.png){fig-align="center" width="100%"}

> *Wenn du jetzt denkst 'Hä? Was soll denn mehrdimensional bedeuten?', dann besuche doch einmal die fantastische Seite [Explained Visually \| Ordinary Least Squares Regression](https://setosa.io/ev/ordinary-least-squares-regression/) um selber zu erfahren, was eine multiple lineare Regression macht. Auf der Seite findest du interaktive Abbildungen, die dir das Konzept der linearen Regression sehr anschaulich nachvollziehen lassen.*
:::

::: callout-tip
## Weitere Tutorien für die multiple lineare Regression

Wir immer geht natürlich mehr als ich hier Vorstellen kann. Du findest im Folgenden Tutorien, die mich hier in dem Kapitel inspiriert haben. Ich habe mich ja in diesem Kapitel auf die Durchführbarkeit in R und die allgemeine Verständlichkeit konzentriert.

-   Wir funktioniert nun so eine lineare Regression und was sind den jetzt eigentlich die Koeffizienten $\beta_0$ und $\beta_1$ eigentlich? Hier gibt es die fantastische Seite [Explained Visually \| Ordinary Least Squares Regression](https://setosa.io/ev/ordinary-least-squares-regression/), die dir nochmal erlaubt selbe mit Punkten in einem Scatterplot zu spielen und zu sehen wie sich dann die Regressionsgleichung ändert.
-   Das Buch [Tidy Modeling with R](https://www.tmwr.org/) gibt nochmal einen tieferen Einblick in das Modellieren in R. Wir immer, es ist ein Vorschlag aber kein Muss.
-   Das R Paket [`{jtools}`](https://jtools.jacob-long.com/articles/summ) gibt nochmal Möglichkeiten sich schnönere `summary()` Ausgaben erstellen zu lassen.
-   Das R Paket [`{modelsummary}`](https://modelsummary.com/) ist perfekt dafür geeignet nochmal verschiedene Modelle miteinander zu vergleichen.
:::

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, broom, correlation, jtools,
               see, performance, car, parameters, modelsummary,
               ggpmisc, tinytable, ggdag, conflicted)
conflicts_prefer(magrittr::set_names)
conflicts_prefer(ggplot2::annotate)
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

An der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.

## Daten

In diesem Kapitel schauen wir uns zwei Datensätze an. Zum einen den Datensatz zu den Sprungweiten von Flöhen und anderen Messwerten. Eigentlich ein faktorielles Experiment mit zwei Faktoren und einiges an spannenden Kovariaten. An diesem Datensatz können wir dann die verschiedenen multiplen Regressionen einmal nachvollziehen. Als zweiten Datensatz habe ich Schlangen mitgebracht. Der Datensatz ist super klein und auch sehr künstlich, da wir uns hier nur die theoretischen Berechnungen in R anschauen wollen. Da brauche ich nicht viel und da habe ich diesen Datensatz dann genutzt.

#### Modellierung von Flöhen {.unnumbered .unlisted}

![In unseren Daten zu der Modellierung der Flöhe schauen wir auf verschiedene Ernährungsformen sowie Entwicklungsstadien und fragen uns, ob sich die Sprungweiten und andere Messwerte unterscheiden.](images/flea_feeding_stage.png){#fig-flea-yedi fig-align="center" width="60%"}

Der folgende Datensatz zu den Sprungweiten und anderen Messwerten von juvenilen und adulten Flöhen ist von mir so gebaut, dass wir hier usn einige Aspekte der multiplen Regression gut anschauen können. Als Hauptfaktor haben wir hier drei verschiedene Ernährungsformen vorliegen und betrachten als zweiten Faktor eben den Entwicklungsstand der Flöhe. Dazu kommen dann noch eine ganze Reihe von Einflussvariablen wie das Gewicht und Laborwerte. Insgesamt also ein sehr großer Datensatz. Wir schauen uns dann aber immer nur einzelene Kombinationen von Einflussvariablen an. Als meinen Messwert nehme ich dann immer die Sprungweite als einen normalverteilten Messwert.

```{r}
flea_model_tbl <- read_excel("data/fleas_model_data.xlsx") |> 
  mutate(feeding = as_factor(feeding),
         stage = as_factor(stage),
         bonitur = as.numeric(bonitur),
         infected = as_factor(infected))
```

Da der Datensatz so groß ist, schaue ich mir hier nicht alle möglichen Abbildungen an sondern gebe dir hier einmal einen Auszug aus der Tabelle wieder. Wie du siehst haben wir einiges an Möglichkeiten mit den Daten. Wir haben hier verschiedene Einflussvariablen sowie verschiedene Messwerte vorliegen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table
#| tbl-cap: "Tabelle der Modelldaten zu den Sprungweiten und den Ernährungsformen von juvenilen und adulten Flöhen."

model_raw_tbl <- read_excel("data/fleas_model_data.xlsx")

rbind(head(model_raw_tbl, n = 3),
      rep("...", times = ncol(model_raw_tbl)),
      tail(model_raw_tbl, n = 3)) |> 
  kable(align = "c", "pipe")
```

In den folgenden Abschnitten nehem ich dann immer wieder einzelne Einflussvariablen und kombiniere diese miteinander in ein statistsiches Modell. Dabei nehme ich als Messwert immer die Sprungweite der Flöhe. Mehr Informationen findest du dann im [Kapitel zu von der Modellierung der Flöhe](#sec-example-flea-model). Dort sind dann auch die Einheiten und übersichtliche Abbildungen zu finden.

#### Theoretischer Datensatz {.unnumbered .unlisted}

![In unseren theoretischen Datensatz schauen wir uns die Körperlängen von verschiedenen Schlangen mit unterschiedlichen Einflussvariablen an. Wir schauen uns die Körperfarbe sowie die Regionen der Messung an.](images/snakes_region.png){fig-align="center" width="100%"}

Abschließend kommen wir noch zu einem theoretischen Datensatz dem ich @kery2010introduction entlehnt habe. Ich möchte nochmal zeigen, wie R intern mit der Modellmatrix die Berechnungen durchführt. Das hat mich interessiert und deshalb habe ich es einmal für mein Verständnis aufgeschrieben. Wenn es dich auch interessiert, dann kannst du in den entsprechenden Tabs weiter unten einmal nachschauen. Hier also erstmal ein sehr simpler theoretischer Datensatz zu Körperlängen von Schlangen. Wir müssen hier dann noch die Faktoren einmal umwandeln, damit wir auch später die Modellmatrix sauber vorliegen haben. Deshalb hier die explizite Benennung der Level der Faktoren in dem Datensatz.

```{r}
#| message: false
snake_tbl <- read_xlsx("data/regression_data.xlsx", sheet = "theory_mult") |> 
  mutate(region = factor(region, levels = c("west", "nord")),
         color = factor(color, levels = c("schwarz", "rot", "blau")))
```

In der folgenden Tabelle ist der Datensatz `snake_tbl` nochmal dargestellt. Wir haben die Schlangenlänge `svl` als Messwert sowie das Gewicht der Schlangen `mass` sowie den Durchmesser der Schlange $diameter$ als kontinuierliche Einflussvariable, die Sammelregion `region` und die Farbe der Schlangen `color` und als kategoriale Einflussvariablen mit unterschiedlichen Anzahlen an Gruppen. Die Region `region` ist also ein Faktor mit zwei Leveln und die Schlangenfarbe `color` ein Faktor mit drei Leveln. Ich nutze den Datensatz also einmal als einen Spieldatensatz um die Modellierung theoretisch besser nachvollziehen zu können.

```{r}
#| message: false
#| echo: false
#| tbl-cap: "Datensatz zu den Körperlängen als Messwert von acht Schlangen mit verschiedenen Einflussvariablen. Die Einflussvariablen haben verschiedene Eigenschaften und müssen daher unterschiedliche modelliert werden."
#| label: tbl-snakes

snake_tbl |> 
  kable(align = "c", "pipe")
```

Damit haben wir dann auch die beiden Datensätze zusammen. Im Folgenden gehe ich dann einmal auf das kausale Modell sowie das prädktive Modell ein. Hier nimmt das kausale Modell mehr Platz ein, da wir eigentlich in der multiplen Regression mehr an dem Zusammenhang interessiert sind. Die Prädiktion ist aber immer mehr im Vormarsch und es kommt hier wirklich auf deine Fragestellung an. Es kann sogar sein, dass du mit vorgesagten Werten mehr Informationen aus deinen Daten ziehen kannst, als mit einem kausalen Modell.

## Kausales Modell

Was ist das kausale Modell? Wir wollen wissen, welchen Einfluss die Einflussvariablen auf den Messwert haben. Das ist jetzt erstmal einleuchtend. Wir bauen uns ein Modell und wollen wissen, ob es einen kausalen Zusammenhang zwischen einzelnen Kovariaten oder Faktoren und einem Messwert gibt. Dabei müssen nicht alle Kovariaten und alle Faktoren einen signifikanten Einfluss haben. Es geht hier eher um eine Art vor und zurück. Wir probieren verschiedene Modell aus und wollen das beste Modell finden. Dafür müssen wir abr verstehen, was die Interpretation der einzelnen Modell ist. Daher schauen wir uns jetzt einmal rein kovariate Modelle, reine faktorielle Modelle und Kombinationen davon an.

### Mehrkovariates Modell

Beginnen wir mit einem mehrkovariaten Modell. Im Gegensatz zu einem einkovaraten Modell in der simplen linearen Regression haben wir jetzt nicht mehr nur eine Kovariate sondern mindestens zwei Kovariaten im Modell. Für die Interpretation nutzen wir hier nur ein zweikovariates Modell inhaltlich lässt sich das Modell aber auch auf mehr als zwei Kovariaten erweitern. In der folgenden Abbildung siehst du einmal das Modell dargestellt. Wir haben einen Messwert auf der linken Seite und zwei Kovariaten auf der rechten Seite. Wir wollen jetzt wissen, wie die beiden Kovariaten den Messwert erklären.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Schemantisches multiples Modell mit einem Messwert $Y$ und zwei kontinuierlichen Einflussvariablen als Kovariate $c_1$ und Kovariate $c_2$ dargestellt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-12

p_2cov_model
```

Die Grundidee ist in der folgenen Abbildung einmal dargestellt. Du kennst dich ja schon mit der simplen linearen Regression aus. In dem mehrkovariaten Fall haben wir nun im zweikovariaten Fall einen Scatterplit in drei Dimensionen vorliegen. Je mehr Kovariaten desto hoöher wird die Dimension. Ich kann aber nicht einen vier dimensionalen Scatterplot darstellen, daher hier die Einschränkung auf zwei Kovariaten. Wie du siehst zeichnen wir jetzt nicht eine Grade im eigentlichen Sinne sondern eine Ebene durch die Punkte hindurch. Dennoch wird der quadratische Abstand zu den Punkten eben über diese Ebene minimiert. Wir erhalten somit auch nur für jede einzelne Beobachtung einen Wert für die Residuen wieder.

![Ein 3D Scatterplot von zwei Kovariaten und einem Messwert Y in drei Dimensionen. Statt eine Grade wird ein Ebene (eng. *regression plane*) durch die Punkte im dreidimensionalen Raum gelegt. Die Residuen sind die Abweichungen der Beobachtungen zu den Werten auf der Ebene. Modifiziert nach https://stackoverflow.com/users/8770170/frans-rodenburg](images/mult-reg-scatter3d-00.png){#fig-scatter3d-00 fig-align="center" width="100%"}

Die Darstellung einer multiplen linearen Regression ist vollkommen unüblich. Wir zeigen eigentlich nicht die Daten als Visualisierung sondern müssen uns dann mit statistischen Maßzahlen helfen, wenn wir wissen wollen, ob unsere Regression gelungen ist. Deshalb auch im Folgenden einmal die praktische Anwendung in R und wie wir die zweikovariate Regression interpretieren.

::: panel-tabset
## Praktisch in R

Dann rechnen wir einmal eine zweikovariate Analyse in R. Dafür brauchen wir einmal einen normalverteilten Messwert. Das ist nicht notwendig, aber für die Interpretation gleich viel einfacher. Dann nehmen wir noch die zwei Kovariten des Flohgewichts und der mitleren Anzahl an Beinhaaren mit ins Modell. Damit haben wir also ein klassisches kovariates Modell.

```{r}
cov2_fit <- lm(jump_length ~ weight + count_leg, data = flea_model_tbl) 
```

Dann können wir uns auch schon die drei Koeffizienten für den Intercept und die Steigungen für die beiden Kovariaten wiedergeben lassen. Da wir das Modell so rechnen, dass wir beide Kovariaten mit ins Modell nehmen, haben wir hier natürlich auch jeweils für die anderen Kovariate den Effekt adjustiert. Will heißen, wir schauen uns den Effekt des Gewichts bereinigt um den Effekt der Beinhaare auf die Sprungweiten an. Und eben umgekehrt dann auch.

```{r}
cov2_fit |> 
  coef() |> round(2)
```

Jetzt müssen wir bei den Koeffizienten aufpassen. Ohne die Einheit, würde man denken, dass der Effekt der mittleren Beinzahl auf die Sprungweite klein wäre. Aber wir haben hier die Steigung pro Änderung der Einheit um Eins in den Einflussvariablen. Die Beinhaare haben aber eine Spannweite von 9 bis 1351! Das ist eine ganz andere Änderung als beim Gewicht mit einer Spannweite von 2.71mg bis 25.73mg. Deshalb brauchen wir auch hier dann die zusammenfassende Ausgabe um einmal die Signifikanz bewerten zu können.

```{r}
#| eval: true
cov2_fit |> summary()
```

Die Zusammenfassugn ist manchmal etwas schwer zu lesen, deshalb habe ich dir einmal die Ausgabe im Folgenden annotiert. Hier siehst du dann auch sehr schön, dass die mittlere Anzahl an Haaren auf den Beinen auch signifikant ist. Ansonsten sieht unser Modell recht gut aus. die Resdiuen sind einigermaßen normalverteilt und auch das Bestimmtheitsmaß ist relativ hoch. Der Fehler der Residuen könnte mit 17.78 etwas kleiner sein. Am Ende passt das Modell.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 8
#| fig-cap: "Annotierte Ausgabe der Funktion `summary()` aus einer linearen Modellanpassung mit der Funktion `lm()`. Die Ausgabe der Funktion teilt sich grob in drei informative Bereiche: Informationen zu den Residuen, Informationen zu den Koeffizienten und Informationen zu der Modelgüte. *[Zum Vergrößern anklicken]*"
#| label: fig-model-c2-summary

p_lm_summary_cov2_explained
```

Was sagt jetzt noch diese seltsame ANOVA aus? Wir scheinen hier ja noch eine ANOVA am Ende zu rechnen. Das ist hier jetzt nicht die einfaktorielle ANOVA, die wir aus den simplen linearen Regressionen kennen, sondern beinhaltet einen Modellvergleich. Welche Modelle vergleichen wir aber nun? In diesem Fall einmal das Nullmodell und das volle Modell, welches wir gerechnet haben. Was soll der Name Nullmodell bedeuten? Wir haben in diesem Modell nichts weiter außer dem Intercept. Hier einmal das Nullmodel gerechnet.

```{r}
lm(jump_length ~ 1, data = flea_model_tbl)
```

Wir erhalten also einmal den globalen Mittelwert über alle Sprungweiten wiedergeben. Jetzt können wir mit der ANOVA auch einen MOdellvergleich rechnen. Wir wollen wissen, ob sich unser volles zweifaktorielles Modell von dem Modell nur mit dem Intercept unterscheidet. Da sehen wir wieder den p-Wert wie wir ihn auch oben in der Ausgabe haben.

```{r}
anova(lm(jump_length ~ 1, data = flea_model_tbl),
      lm(jump_length ~ weight + count_leg, data = flea_model_tbl))
```

Brauchen wir den Vergleich? Meistens nicht. Denn wir können ja direkt schauen, ob sich die Koeffizienten sigifkant von Nhull unterscheiden. Dann brauchen wir auch nur sehr selten den Vergleich zu dem Nullmodell. Das Nullmodell beinhaltet eigentlich nie eine Information, die wir wirklich brauchen. Daher ist es eher ein Artefakt der Programmierung aus den Anfangstagen. Wir können es, also packen wir es mit in die Ausgabe rein.

Die folgende Abbildung dient hier nur der Anschauung. Wir publizieren eigentlich nicht eine Visualisierung in drei Dimensionen. Wie du hier schon siehst, ist die Darstellung durch die unterschiedlich Minima- und Maximawerte des Gewichts und der Anzahl an Beinhaaren sehr verdreht. Häufig sieht dann die Abbildung in drei Dimensionen nur gut aus, wenn alle drei Achsen die gleichen Spannweiten an Werten haben. Daher dient die Abbildung eher nochmal zum Verständnis der Berechnungen der Residuen aus der Ebene der Regression.

![Ein 3D Scatterplot von den zwei Kovariaten Gewicht der Flöhe in \[mg\] sowie der mittleren Anzahl an Beinhaaren und der Sprungweite in drei Dimensionen. Statt eine Grade wird ein Ebene (eng. *regression plane*) durch die Punkte im dreidimensionalen Raum gelegt. Die Residuen sind die Abweichungen der Beobachtungen zu den Werten auf der Ebene.](images/mult-reg-scatter3d-01.png){fig-align="center" width="100%"}

## Theoretisch in R

```{r}
model.matrix(svl ~ mass + diameter, data = snake_tbl) |> as_tibble() 
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  50 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  1 & 6 & 9 \\
  1 & 8 & 3 \\
  1 & 5 & 6 \\
  1 & 7 & 7 \\
  1 & 9 & 5 \\
  1 & 11& 4 \\
  1 & 12& 10 \\
  1 & 10& 11 \\
 \end{pmatrix}
 \times
  \begin{pmatrix}
  \beta_0 \\
  \beta_{mass} \\
  \beta_{diameter} \\
 \end{pmatrix} +
  \begin{pmatrix}
  \epsilon_1 \\
  \epsilon_2 \\
  \epsilon_3 \\
  \epsilon_4 \\
  \epsilon_5 \\
  \epsilon_6 \\
  \epsilon_7 \\
  \epsilon_8 \\
 \end{pmatrix}
$$

```{r}
cov2_fit <- lm(svl ~ mass + diameter, data = snake_tbl)
```

```{r}
cov2_fit |> coef() |> round(2)
```

```{r}
cov2_fit |> residuals() |> round(2)
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  51 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  28.27 & 6 \cdot 2.67 & 9 \cdot -0.30 \\
  28.27 & 8 \cdot 2.67 & 3 \cdot -0.30 \\
  28.27 & 5 \cdot 2.67 & 6 \cdot -0.30 \\
  28.27 & 7 \cdot 2.67 & 7 \cdot -0.30 \\
  28.27 & 9 \cdot 2.67 & 5 \cdot -0.30 \\
  28.27 & 11 \cdot 2.67 & 4 \cdot -0.30 \\
  28.27 & 12 \cdot 2.67 & 10 \cdot -0.30 \\
  28.27 & 10 \cdot 2.67 & 11 \cdot -0.30 \\
 \end{pmatrix} +
  \begin{pmatrix}
  -1.56 \\
  -3.71 \\
  -0.80 \\
  +6.17 \\
  +1.22 \\
  +0.58 \\
  +0.73 \\
  -2.63 \\
 \end{pmatrix}
$$

```{r}
c(28.27 +  6*2.67 + 9*(-0.30) - 1.56,
  28.27 +  8*2.67 + 3*(-0.30) - 3.71,
  28.27 +  5*2.67 + 6*(-0.30) - 0.80,
  28.27 +  7*2.67 + 7*(-0.30) + 6.17,
  28.27 +  9*2.67 + 5*(-0.30) + 1.22,
  28.27 + 11*2.67 + 4*(-0.30) + 0.58,
  28.27 + 12*2.67 + 10*(-0.30) + 0.73,
  28.27 + 10*2.67 + 11*(-0.30) - 2.63) |> round()
```

```{r}
snake_tbl |> pull(svl)
```

## Simulation

Dieser Abschnitt beinhaltet eine kurze Simulation in R mit einem Tibble und der Erstellung eines normalverteilten Messwerts. Mehr zu der [Generierung von Daten](#sec-eda-gen-data) dann im entsprechenden Kapitel. Ich habe alles ausgelagert, da es dann hier zu voll wurde. Daher ist es hier eher so eine kleine Spielweise.

```{r}
cov2_tbl <- tibble(c_1 = rnorm(10, 0, 1),
                   c_2 = rnorm(10, 0, 1),
                   y = 2 + 
                       1 * c_1 + 
                       2 * c_2 + 
                           rnorm(10, 0, 0.001))
```

Dann schauen wir uns einmal an, ob wir dann den Intercept und die Koeffizienten wiederfinden. Wenn du den Fehler in `rnorm()` von $0.001$ hochsetzt, dann werden auch die Koeffizienten in dem folgenden Modell ungenauer. Hat aber gut geklappt, wir erhalten die gerundeten Koeffizienten, die wir eingestellt hatten einigermaßen wiedergegeben.

```{r}
lm(y ~ c_1 + c_2, cov2_tbl) |> 
  coef() |> round(2)
```
:::

### Mehrfaktorielles Modell

Betrachten wir nun ein mehrfaktorielles Modell. Hier sei aber gleich gesagt, dass wir eigentlich in einem mherfaktoriellen Modell an den Vergleichen der Level in den Faktoren interessiert sind. Wir wollen also eigentlich einen paarweisen Vergleich über die Gruppen rechnen. Damit sind wir dann auf dem ANOVA Pfad mit der [ANOVA](#sec-anova) und den [Post-hoc Tests](#sec-posthoc). Wir schauen uns hier also erstmal die Koeffizienten des Modells an, sehr häufig nutzen wir diese Koeffizienten dann aber nicht. Das hat den Grund, dass der Referenzwert ja der Interecept im Modell ist und wir wenig an dem Vergleich zu dem Intercept interessiert sind. Dazu dann aber gleich mehr. Hier dann erstmal das zweifaktorielle Modell mit dem Interaktionsterm. Zu der Interaktion kannst du im [Kapitel zur ANOVA](#sec-anova) mehr erfahren.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Schemantisches multiples Modell mit einem Messwert $Y$ und einer kategorialen Einflussvariablen als Faktor $f_A$ mit drei Leveln sowie einer kategorialen Einflussvariablen als Faktor $f_B$ mit zwei Leveln und deren Interaktion $f_A \\times f_B$ dargestellt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-13

p_2fac_model  +
  labs(title = "") 
```

Im Folgenden wollen wir also einmal ein multiples Modell rechnen und die Koeffizienten für die einzelnen Faktoren ermitteln. Dabei hat es dann eine Auswirkung wie viele Level ein Faktor hat und wie wir das Modell bauen. Wir machen hier gleich das volle Modell mit Interaktion. Ohne die Interaktion lassen sich dann die Koeffizienten etwas leichter zu interpretieren. Am Ende ist es dann doch die ANOVA, die wir eigentlich wollen. Hier also bitte nicht verwirren lassen, es kommt immer auf die wissenschaftliche Fragestellung an.

::: panel-tabset
## Praktisch in R

Beginnen wir wieder mit dem zweifaktoriellen Modell. Wir nehmen hier beide Faktoren mit ins Modell und wollen auch den Interaktionsterm mit modellieren. Wenn wir den Interaktionsterm weglassen, dann können wir die Koeffizienten des Modells etwas leichter interpretieren. Wenn also unsere Interaktion nicht signifikant ist, dann kannst du die Interaktion auch aus dem Modell entfernen und so es etwas einfacher machen.

```{r}
fac2_fit <- lm(jump_length ~ feeding + stage + stage:feeding, data = flea_model_tbl) 
```

Jetzt erhalten wir die Koeffizienten des Modells mit einem Intercept und der Steigung zu den einzelnen Gruppenmittelwerten. Oder anders ausgedrückt, die Differenz der Gruppenmittelwerte zum Intercept. Dazu dann noch die Koeffizienten der Interaktion. Hier sehen wir noch nicht, ob die Koeffizienten der Interaktion signifikant sind.

```{r}
fac2_fit |> 
  coef() |> round(2)
```

Jetzt müssen wir uns einmal die Zusammenfassung des Modells wiedergeben lassen, damit wir abschätzen können, ob unsere Koeffizienten signifikant sind. Auch erhalten wir die statistischen Maßzahlen für die Modelgüte wiedergegeben. Unser Interaktion ist für beide Koeffizienten nicht signifikant, daher könnten wir die Interaktion auch aus dem Modell nehmen.

```{r}
#| eval: true
fac2_fit |> summary()
```

Dann habe ich dir in der folgenden Abbildung nochmal die Ausgabe der Zusammenfassung annotiert. Der spannendeste Teil ist eigentlich, was der Intercept repräsentiert. Der Intercept ist nämlich das lokale Gruppenmittel der Behandlung Zuckerwasser für die adulten Flöhe. Dann haben wir die einzlenen statistischen Tests, ob sich die Koeffizienten von Null unterscheiden. Somit eigentlich die Frage, ob die lokalen Mittelwerte der Gruppen sich vom Intercept unterscheiden.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 8
#| fig-cap: "Annotierte Ausgabe der Funktion `summary()` aus einer linearen Modellanpassung mit der Funktion `lm()`. Die Ausgabe der Funktion teilt sich grob in drei informative Bereiche: Informationen zu den Residuen, Informationen zu den Koeffizienten und Informationen zu der Modelgüte. Die Erklärung der Schätzer (eng. *estimate*) kann in der folgenden Tabelle nachvollzogen werden. *[Zum Vergrößern anklicken]*"
#| label: fig-model-f2-summary

p_lm_summary_fac2_explained
```

Das Ganze mag etwas kryptisch sein, aber das Ziel ist es eigentlich die Mittelwerte der Faktorkombinationen abzubilden. Wir haben hier etwas Glück, dass die Residuen faktisch Null sind und somit keien Rolle spielen, wie du im Folgenden siehst. Sonst müssten wir die Werte der Residuen natürlich immer nochmal berücksichtigen. Das kannst du dann in den kombinierten Modellen teilweise beobachten.

```{r}
#| message: false
#| warning: false
fac2_fit |> 
  augment() |> 
  group_by(feeding, stage) |> 
  summarise(mean_resid = round(mean(.resid), 2))
```

In der folgenden Tabelle habe ich dir einmal gezeigt, wie wir von den Koeffizienten auf die Mittelwerte der Sprungweiten in den einzelnen Gruppen der Faktorkombinationen kommen. Jetzt siehst du auch, dass die Koeffizienten nur einen sehr kleinen Teil der Unterschiede in den Sprungweiten beschreiben. Daher nutzen wir dann lieber Post-hoc Tests um alle paarweisen Mittelwertsvergleiche rechnen zu können.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table-fac2
#| tbl-cap: "Zusammensetzung der Mittelwerte der Sprungweiten $\\bar{Y}$ für jede Faktorkombination aus der Ernährungsart und dem Entwicklungsstand aus den Koeffizienten des zweifaktoriellen Modells."
options(knitr.kable.NA = '')

tibble("$f_{feeding}$" = rep(c("sugar", "blood", "ketchup"), each = 2),
       "$f_{stage}$" = rep(c("adult", "juvenile"), 3),
       "$\\bar{Y}$" = c(78.9, 61.03, 99.71, 116.03, 92.15, 111.24), 
       "$\\boldsymbol{\\beta_{0}}$" = 78.98,
       "$\\boldsymbol{\\beta_{blood}}$" = c(NA, NA, 20.73, 20.73, NA, NA),
       "$\\boldsymbol{\\beta_{ketchup}}$" = c(NA, NA, NA, NA, 13.17, 13.17),
       "$\\boldsymbol{\\beta_{juvenile}}$" = c(NA, -17.94, NA, -17.94, NA, -17.94),
       "$\\boldsymbol{\\beta_{blood \\times juvenile}}$" = c(NA, NA, NA, 34.26, NA, NA),
       "$\\boldsymbol{\\beta_{ketchup \\times juvenile}}$" = c(NA, NA, NA, NA, NA, 37.03),
       "$\\boldsymbol{\\epsilon}$" = 0) |> 
  kable(align = "c", "pipe")
```

Dann wird dir alles wahrscheinlich klarer, wenn wir uns nochmal die Abbildung zu dem zweifaktoriellen Versuch anschauen. Wir haben hier unsere y-Achse mit dem Intercept direkt durch den lokalen Gruppenmittelwert der adulten Flöhe, die Zuckerwasser trinken. Dann kannst du die jeweiligen Abweichungen aus der obigen Tabelle der Mittelwerte in der Abbildung nachvollziehen.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 6
#| fig-cap: "Darstellung der Gruppenmittelwerte der Sprungweiten für alle Faktorkombinationen aus dem zweifaktoriellen Modell zur Ernährung und Entwicklungsstand von Flöhen. Der Intercept liegt auf dem lokalen Mittelwert der adulten Flöhe, die Zuckerwasser trinken. Die Koeffizienten des zweifaktoriellen Modells beschreiben die Abweichungen zu dem Intercept. *[Zum Vergrößern anklicken]*"
#| label: fig-model-basis-fac2

ggplot(flea_model_tbl, aes(feeding, jump_length, color = stage)) +
  theme_modeling() +
  geom_vline(xintercept = 0.95, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 78.98, linewidth = 0.5, color = "#CC79A7") +
  geom_point(position = position_dodge(0.2), alpha = 0.5, size = 1) +
  stat_summary(fun = "mean", geom = "label", 
               aes(label = round(..y.., 2)), 
               position = position_nudge(c(-0.3, 0.3, -0.3, 0.3, -0.3, 0.3)),
               show.legend = FALSE) +
  stat_summary(fun = "mean", geom = "point", shape = 13, size = 5,
               aes(label = round(..y.., 2)), 
               show.legend = FALSE, position = position_dodge(0.2)) +
  scale_x_discrete(labels = c("Zuckerwasser", "Blut", "Ketchup")) +
  labs(title = "Zweifaktorielles Modell mit Interaktion",
       subtitle = "Intercept ist der Mittelwert der Sprungweiten der\nBehandlung Zuckerwasser bei den adulten Flöhen",
       x = "Fütterungsart", y = "Sprungweite in [cm]", color = "Entwicklungsstand") +
  scale_color_okabeito() +
  theme(legend.position = "top",
        panel.grid.major.x = element_blank()) +
  ylim(0, 170)
```

## Theoretisch in R

Aus Gründen der Einfachheit lassen wir einmal die Interaktion weg.

```{r}
model.matrix(svl ~ color + region, data = snake_tbl) |> as_tibble() 
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  50 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  1 & 0 & 0 & 0 \\
  1 & 0 & 0 & 0 \\
  1 & 1 & 0 & 0 \\
  1 & 1 & 0 & 1 \\
  1 & 1 & 0 & 1 \\
  1 & 0 & 1 & 1 \\
  1 & 0 & 1 & 1 \\
  1 & 0 & 1 & 1 \\
 \end{pmatrix}
 \times
  \begin{pmatrix}
  \beta_0 \\
  \beta^{color}_{rot} \\
  \beta^{color}_{blau} \\
  \beta^{region}_{nord} \\
 \end{pmatrix} +
  \begin{pmatrix}
  \epsilon_1 \\
  \epsilon_2 \\
  \epsilon_3 \\
  \epsilon_4 \\
  \epsilon_5 \\
  \epsilon_6 \\
  \epsilon_7 \\
  \epsilon_8 \\
 \end{pmatrix}
$$

```{r}
fac2_fit <- lm(svl ~ color + region, data = snake_tbl)
```

```{r}
fac2_fit |> coef() |> round(2)
```

```{r}
fac2_fit |> residuals() |> round(2)
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  51 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  42.50 & 0 \cdot -3.50 & 0 \cdot -0.33 & 0 \cdot 12.50 \\
  42.50 & 0 \cdot -3.50 & 0 \cdot -0.33 & 0 \cdot 12.50 \\
  42.50 & 1 \cdot -3.50 & 0 \cdot -0.33 & 0 \cdot 12.50 \\
  42.50 & 1 \cdot -3.50 & 0 \cdot -0.33 & 1 \cdot 12.50 \\
  42.50 & 1 \cdot -3.50 & 0 \cdot -0.33 & 1 \cdot 12.50 \\
  42.50 & 0 \cdot -3.50 & 1 \cdot -0.33 & 1 \cdot 12.50 \\
  42.50 & 0 \cdot -3.50 & 1 \cdot -0.33 & 1 \cdot 12.50 \\
  42.50 & 0 \cdot -3.50 & 1 \cdot -0.33 & 1 \cdot 12.50 \\
 \end{pmatrix} +
  \begin{pmatrix}
  -2.50 \\
  +2.50 \\
  0.00 \\
  -0.50 \\
  +0.50 \\
  +2.33 \\
  +3.33 \\
  -5.67 \\
 \end{pmatrix}
$$

```{r}
c(42.50 +  0*(-3.50) + 0*(-0.33) + 0*12.50 - 2.50,
  42.50 +  0*(-3.50) + 0*(-0.33) + 0*12.50 + 2.50,
  42.50 +  1*(-3.50) + 0*(-0.33) + 0*12.50 + 0.00,
  42.50 +  1*(-3.50) + 0*(-0.33) + 1*12.50 - 0.50,
  42.50 +  1*(-3.50) + 0*(-0.33) + 1*12.50 + 0.50,
  42.50 +  0*(-3.50) + 1*(-0.33) + 1*12.50 + 2.33,
  42.50 +  0*(-3.50) + 1*(-0.33) + 1*12.50 + 3.33,
  42.50 +  0*(-3.50) + 1*(-0.33) + 1*12.50 - 5.67) |> round()
```

```{r}
snake_tbl |> pull(svl)
```

## Simulation

Dieser Abschnitt beinhaltet eine kurze Simulation in R mit einem Tibble und der Erstellung eines normalverteilten Messwerts. Mehr zu der [Generierung von Daten](#sec-eda-gen-data) dann im entsprechenden Kapitel. Ich habe alles ausgelagert, da es dann hier zu voll wurde. Daher ist es hier eher so eine kleine Spielweise. Beachte auch hier die Interaktion, die als Multiplikation der beiden Faktoren in der Generierung entsteht. Das ist aber dann nur eine Möglichkeit eine Interaktion zu bauen.

```{r}
fac2_tbl <- tibble(f_a = rep(gl(3, 5), 2),
                   f_b = gl(2, 15),
                   y = 2 + 
                       2 * as.numeric(f_a) + 
                       3 * as.numeric(f_b) + 
                       2 * as.numeric(f_a) * as.numeric(f_b) +
                           rnorm(15, 0, 0.001))
```

Dann schauen wir uns einmal an, ob wir dann den Intercept und die Koeffizienten wiederfinden. Wenn du den Fehler in `rnorm()` von $0.001$ hochsetzt, dann werden auch die Koeffizienten in dem folgenden Modell ungenauer. Hat aber gut geklappt, wir erhalten die gerundeten Koeffizienten, die wir eingestellt hatten einigermaßen wiedergegeben.

```{r}
lm(y ~ f_a + f_b + f_a:f_b, fac2_tbl) |> 
  coef() |> round(2)
```
:::

### Kombinierte Modelle

Kommen wir jetzt zu dem wirklich spannenden Teil. Wir kombinieren Kovariaten zusammen mit Faktoren in einem Modell. Zum einen haben wir hier jetzt eine klassische [ANCOVA](#sec-ancova) vorliegen, wenn wir an den Faktoren als Haupteffekt interessiert sind. Wenn es eher um die Kovariaten geht, dann ist eben eine klassische Regression. Hier kommt es dann auf die wissenschaftliche Fragestellung an. Wollen wir wissen wie sich die Kovariate in den Faktoren ändert oder wollen wir die Faktoren für eine Kovariate adjustieren? Das kannst nur du beantworten.

Was passiert wenn wir eine Kovariate und einen Faktor kombinieren?

:   Wenn wir eine Kovariate mit einem Faktor kombinieren, dann kippen wir den Intercept der Graden um die Steigung der Kovariate. Die Level der Faktoren liegen dann auf den Mittelwerten der Kovariaten für das entsprechende Level des Faktors. Wenn wir dann noch eine Interaktion hinzunehmen, dann erlauben wir jedem Level des Faktors eine eigene Steigung der Kovariaten.

Das erstmal die sehr allgemeine Beschreibung. mehr dazu dann gleich in der Durchführung in R. Ich hoffe, dass dann das ein oder andere nochmal klarer wird. Wir wollen uns insgesamt drei Typen von multiplen Regressionen anschauen. Einmal das kombinierte Modell mit einem Faktor und einer Kovariate. Dann das gleiche Modell nur mit einm Faktor mehr. Am Ende dann noch das zweikovariate und zweifaktorielle Modell. Weiter unten diskutiere ich dann noch die Modellauswahl, wenn du dich fragst, wie viel der Einflussvariablen sollen denn jetzt in ein Modell mit rein.

#### $f_A + c_1$ {.unnumbered .unlisted}

Beginnen wir ein kombiniertes Modell mit einem Faktor und einer Kovariate. Wenn es hier mit einem faktoriellen Experiment zu tun haben in dem wir noch eine Kovariate gemessen haben, dann rechnen wir hier eigentlich eine klassische [einfaktorielle ANCOVA](#sec-ancova) (eng. *analysis of covariance*). Daher kommt es immer etwas auf die Perspektive an. Wenn wir einfach nur Daten beobachtet haben und eine Kovariate sowie einen Faktor erhoben haben, dann mag die multiple Regression eine bessere Möglichkeit zur Interpretation der Daten sein. In der folgenden Abbildung zeige ich dir nochmal das schematische Modell mit einem Faktor mit drei Leveln sowie einer Kovariate.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Schemantisches multiples Modell mit einem Messwert $Y$ und einer kategorialen Einflussvariablen als Faktor $f_A$ mit drei Leveln sowie einer kontinuierlichen Einflussvariable als Kovariate $c_1$ dargestellt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-14

p_fa_c1_model
```

Dann wollen wir einmal das kombinierte Modell mit einer Kovariate und einem Faktor in R rechnen. Dann kannst du dir nochmal die Berechnung theoretisch anschauen sowie eine kleine Simulation. Hier zeige ich dir auch nochmal die Auswirkungen der Interaktion zwischen der Kovariate und dem Faktor. Das lässt sich in dem einfachen Fall hier am besten zeigen.

::: panel-tabset
## Praktisch in R

Wir haben jetzt die Wahl einmal das kombinierte Modell mit einem Interaktionsterm oder ohne einen Interaktionsterm für die Kovariate und den Faktor anzuschauen. Ich mache in diesem einfachen Beispiel dann nochmal beides. Wenn du jetzt denkst, dass wir eigentlich ja keine Interaktion mit Kovariaten als kontinuierlichen Einflussvariablen rechnen können stimmt es nur bedingt. Wir ja einen Faktor und wir haben die mittleren Werte der Kovariaten für die jeweiligen Faktorlevel. Damit können wir dann auch eine Interaktion mit bestimmen. Aber das wird vermutlich gleich im Beispiel klarer.

Dann wollen wir einmal im Folgenden uns den Einfluss der Ernährung auf die Sprungweite der Flöhe anschauen. Wir mitteln hier über die beiden Entwicklungsstadien, da wir das Alter der Flöhe in dem Modell hier ignorieren. Wir nutzen ja nur einen Faktor. Dann nehmen wir noch den Kaliumgehalt im Blut der Flöhe als eine Kovariate mit in das Modell hinein. Damit würden wir dann auch sagen, dass wir die Ernährungsbedingungen um den Kaliumgehalt im Blut adjustieren. Wir nutzen ununterbrochen das Wort Adjustieren in jeglichen Kontexten in der Statistik. Es ist manchmal dann nicht so einfach.

#### Ohne Interaktion {.unnumbered .unlisted}

Wenn wir das kombinierte Modell mit einem Faktor und einer Kovariate ohne Interaktion bauen, dann nehmen wir einfahc die beiden Einflussvariablen in das Modell und schauen uns an, was die Koeffizienten ergeben. Hier nehmen wir dann die Ernährung und den Kaliumgehalt im Blut der Flöhe.

```{r}
cov1_fac1_fit <- lm(jump_length ~ feeding + K, data = flea_model_tbl) 
```

Dann können wir uns auch schon gleich die Koeffizienten einmal anschauen. Wir sehen hier vier Werte. Wiederrum als erstes den Intercept und dann die Steigungen zu der Ernährung Blut und Ketchup. Am Ende dann noch ein kleiner Wert für die Steigung des Kaliumgehalts. Aber Achtung, die Zahlen sind immer auf die Änderung der Einheit bezogen. Faktoren haben sehr häufig größere Werte als Kovariaten.

```{r}
cov1_fac1_fit |> 
  coef() |> round(2)
```

Als nächstes lassen wir uns die zusammenfassende Tabelle des Modells wiedergeben. Hier erhalten wir dann auch die p-Werte und die weiteren Informationen zu der Modelgüte. Ich annotiere dir hier nicht nochmal die zusammenfassende Tabelle, das wird sehr redundant. Dazu dann einfach nochmal oben bei den mehrkovariaten oder mehrfaktoriellen Modellen reinschauen.

```{r}
#| eval: true
cov1_fac1_fit |> summary()
```

Wir wollen uns hier nochmal auf die Koeffizienten konzentrieren und was uns jetzt die Koeffizienten aussagen. Dafür habe ich nochmal die lokalen Mittelwerte der Sprungweite und der Kovariate für jedes Level der Ernährungsform bestimmt. Sie mittlere Sprungweite der Zuckerflöhe ist damit 70cm und der mittlere Kaliumgehalt im Blut der Zuckerflöhe liegt bei 33.7mmol/l.

```{r}
flea_model_tbl |> 
  group_by(feeding) |> 
  summarise(mean(jump_length),
            mean(K))
```

Damit können wir jetzt besser verstehen, was die Koeffizienten der Einflussvariablen uns sagen wollen. In der folgenden Tabelle habe ich dir einmal für die Faktorlevel die Mittelwerte der Kovariaten sowie des Messswerts der Sprungweite dargestellt. Wie setzt sich jetzt der Mittelwert der Sprungweiten aus den Koeffizienten zusammen? Der Intercept liegt auf dem lokalen Mittel der Zuckerflöhe. Jedenfalls fast. Denn wir müssen noch die Steigung des Kaliumsgehalt mit dem mittleren Kaliumgehalt in den Zuckerflöhen multiplizieren. Dieser Betrag fehlt noch zum lokalen Mittel der Zuckerflöhe. Faktisch kippen wir die Grade durch den Intercept um die Steigung der Kovariaten. Die mittleren Residuen sind in diesem Beispiel gerade Null und speilen somit keine Rolle.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table-fac1-cov1
#| tbl-cap: "Zusammensetzung der Mittelwerte der Sprungweiten $\\bar{Y}$ für jede Faktorkombination aus der Ernährungsart aus den Koeffizienten des kombinierten Modells."
options(knitr.kable.NA = '')

tibble("$f_{feeding}$" = c("sugar", "blood", "ketchup"),
       "$\\bar{c}_{K}$" = c(33.69, 29.47, 25.06), 
       "$\\bar{Y}$" = c(70.01, 107.87, 101.69), 
       "$\\boldsymbol{\\beta_{0}}$" = 58.48,
       "$\\boldsymbol{\\beta_{blood}}$" = c(NA, 39.31, NA),
       "$\\boldsymbol{\\beta_{ketchup}}$" = c(NA, NA, 34.64),
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{K}}$" = c("$11.45 = 33.69 \\cdot 0.34$",
                                             "$10.02 = 29.47 \\cdot 0.34$",
                                             "$8.52 = 25.06 \\cdot 0.34$"),
       "$\\boldsymbol{\\epsilon}$" = 0) |> 
  kable(align = "c", "pipe")
```

Wir können uns dann den Zusammenhang auch nochmal visualisieren. Wir legen auf die x-Achse die Kaliumwerte. Die Mittelwerte der Sprungweite für die Ernärhungstypen der Flöhe liegen jetzt exakt auf den Mittwelwerten der Kaliumwerte in den entsprechenden Gruppen. Im Endeffekt kippen wir die Grade durch den Intercept um die Steigung der Kovariaten. Hier haben wir dann eine Steigung für alle Gruppen der Ernährung für den Kaliumgehalt. Wenn wir eine Interaktion zulassen, dann erhält jede Gruppe der Ernährung nochmal 'eine Art eigene Steigung'. Das ist nicht super korekt, aber so kann man sich das vorstellen.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 6.5
#| fig-cap: "Darstellung der Gruppenmittelwerte der Sprungweiten aus dem kombinierten Modell zur Ernährung und dem Kaliumgehalt im Blut von Flöhen. Der Intercept liegt auf dem lokalen Mittelwert der Flöhe, die Zuckerwasser trinken und wird um die Steigung der Kovariaten gekippt. Die lokalen Mittel der Ernährungstypen liegen auf den Mittelwerten der Kovariaten in den entsprechenden Leveln des Faktors. *[Zum Vergrößern anklicken]*"
#| label: fig-model-basic-cov1-fac1-01

ggplot(flea_model_tbl, aes(K, jump_length, color = feeding)) +
  theme_modeling() +
  geom_vline(xintercept = 33.69, linewidth = 0.5, color = "#E69F00") +
  geom_vline(xintercept = 29.46, linewidth = 0.5, color = "#56B4E9") +
  geom_vline(xintercept = 25.05, linewidth = 0.5, color = "#009E73") +
  geom_hline(yintercept = 58.48, linewidth = 0.5, color = "#CC79A7", linetype = 11) +
  geom_point(position = position_dodge(0.2)) +
  geom_function(fun = \(x) 58.48 + 0.342 * x, color = "#CC79A7") +
  xlim(c(0, NA)) + ylim(c(40, 150)) +
  annotate("point", x = c(25.05, 29.46, 33.69), y = c(70.0, 107.8, 101.7), 
           label = c(70.0, 107.8, 101.7), fill = c("#009E73", "#56B4E9", "#E69F00"),
           alpha = 1, size = 2, shape = 23) +
  annotate("label", x = c(25.05, 29.46, 33.69)+c(2,3,3), y = c(70.0, 107.8, 101.7)+5, 
           label = c(70.0, 107.8, 101.7), fill = c("#009E73", "#56B4E9", "#E69F00"),
           alpha = 0.5, size = 3) +
  labs(title = "Modell mit Kovariate und Faktor",
       subtitle = "Intercept ist der Mittelwert der Sprungweiten der Behandlung Zuckerwasser\ngekippt um die Steigung der Kovariate",
       x = "Kaliumgehalt im Blut [mmol/ml]", y = "Sprungweite in [cm]", color = "Fütterungsart") +
  scale_color_okabeito() +
  theme(legend.position = "top") +
  geom_segment(aes(x = 40, xend = 40, y = 58.48, yend = 58.48 + 40 * 0.3420),
               color = "#CC79A7") +
  annotate("text", hjust = "left", x = 41, y = 58.48 + (40 * 0.3420)/2,
           label = expression(beta[K]*"="~40%.%0.34)) +
  scale_x_continuous(breaks = c(0, 10, 20, 25.05, 29.46, 33.69, 40, 50),
                     guide = guide_axis(n.dodge = 2),
                     limits = c(0, NA))
```

#### Mit Interaktion {.unnumbered .unlisted}

Jetzt schauen wir uns das gleiche Modell nochmal mit der Interaktion zwischen den Ernährungsformen und dem Kaliumgehalt im Blut der Flöhe an. Im Prinzip erlauben wir jetzt jeder Ernährungsform eine eigene Steigung für den Kaliumghalt. Das heißt aber auch im Umkehrschluss, dass wir die Steigung nicht richtig ohne die Interaktionsterme bewerten können. Irgendwas ist ja immer.

```{r}
cov1_fac1_fit <- lm(jump_length ~ feeding + K + feeding:K, data = flea_model_tbl) 
```

Schauen wir uns einmal die zusammenfassende Ausgabe des Modells an. Wir sehen hier, dass wir noch zwei Koeffizienten für die Interaktion zwischen der Bluternährung und dem Kaliumgehalt sowie der Ketchupernährung und dem Kaliumgehalt zusätzlich erhalten haben. Du kannst die Interaktion als Steigung für Kalium in den Gruppen interpretieren *zusammen mit der Steigung für die Zuckerflöhe*. In der Steigung für das Kalium ist jetzt die Gruppe der Zuckerernährung direkt mit drin. Das führt jetzt gleich zu einer etwas umständlicheren Interpretation. Mehr dazu in der Tabelle weiter unten.

```{r}
#| eval: true
cov1_fac1_fit |> summary()
```

In der folgenden Tabelle zeige ich dir einmal wie sich die lokalen Mittelwerte für die Sprungweiten und den Ernährungsformen zusammensetzen. Die mittleren Residuen sind in diesem Beispiel gerade Null und speilen somit keine Rolle. Wir erhalten eine höhere Steigung für den Kaliumgehall als ohne die Interaktion. Die Steigung beschreibt ja jetzt Grade für die Zuckerflöhe. Damit wir jetzt mit den aufaddierten Effekten der Ernährung wieder bei den lokalen Mitteln landen, müssen wir noch die mittleren Werte der Kovariaten gewichtet um die Steigung abziehen. Das klingt jetzt komplizierter als es ist. Schaue dir einfach mal die Tabelle an.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table-fac1-cov1-inter
#| tbl-cap: "Zusammensetzung der Mittelwerte der Sprungweiten $\\bar{Y}$ für die Ernährungsart und dem Kaliumgehalt aus den Koeffizienten des kombinierten Modells eines Faktors und einer Kovariate. Wichtig ist hier der mittlere Kaliumgehalt pro Level der Ernährungsart für die Berechnung der Sprungweiten."
options(knitr.kable.NA = '')

tibble("$f_{feeding}$" = c("sugar", "blood", "ketchup"),
       "$\\bar{c}_{K}$" = c(33.69, 29.47, 25.06), 
       "$\\bar{Y}$" = c(70.01, 107.87, 101.69), 
       "$\\boldsymbol{\\beta_{0}}$" = 44.13,
       "$\\boldsymbol{\\beta_{blood}}$" = c(NA, 44.59, NA),
       "$\\boldsymbol{\\beta_{ketchup}}$" = c(NA, NA, 81.63),
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{K}}$" = c("$25.94 = 33.69 \\cdot 0.77$",
                                             "$22.69 = 29.47 \\cdot 0.77$",
                                             "$19.29 = 25.06 \\cdot 0.77$"),
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{blood\\times K}}$" = c(NA,
                                                          "$-3.54 = 29.47 \\cdot -0.12$",
                                                          NA),
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{ketchup\\times K}}$" = c(NA, NA,
                                                          "$-43.35 = 25.06 \\cdot -1.73$"),
       "$\\boldsymbol{\\epsilon}$" = 0) |> 
  kable(align = "c", "pipe")
```

In der folgenden Abbildung können wir uns dann den Zusammenhang nochmal visualisieren. Wir sehen hier, dass die Steigung größer ist. Wir haben auf der anderen Seite aber auch einen geringeren Intercept als in dem Modell ohne Interaktion. Das liegt daran, das sich die Steigung des Kaliumsgehalt jetzt auf die Zuckerflöhe bezieht und nicht mher auf alle drei Ernährungsformen. Die Steigung der anderen Ernährungsformen wird dann durch die Werte der Koeffizenten der Interaktion abgebildet. Daher ist die Interpretation nicht mehr ganz so eingängig und einfach zu interpretieren. Wichtig ist aber, dass du verstehst, dass wir es hier in der Interaktion mit einer Steigung zu tun haben.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 6.5
#| fig-cap: "Darstellung der Gruppenmittelwerte der Sprungweiten aus dem kombinierten Modell zur Ernährung und dem Kaliumgehalt im Blut von Flöhen. Der Intercept liegt auf dem lokalen Mittelwert der Flöhe, die Zuckerwasser trinken und wird um die Steigung der Kovariaten gekippt. Die lokalen Mittel der Ernährungstypen liegen auf den Mittelwerten der Kovariaten in den entsprechenden Leveln des Faktors. Hier haben wir eine höhere Steigung, da die Steigung der Kovariaten sich auf die Zuckerflöhe bezieht. Die Koeffizienten der Interaktion modifizieren dann die Steigung für die beiden anderen Ernährungsformen. *[Zum Vergrößern anklicken]*"
#| label: fig-model-basic-cov1-fac1-02

ggplot(flea_model_tbl, aes(K, jump_length, color = feeding)) +
  theme_modeling() +
  geom_vline(xintercept = 33.69, linewidth = 0.5, color = "#E69F00") +
  geom_vline(xintercept = 29.46, linewidth = 0.5, color = "#56B4E9") +
  geom_vline(xintercept = 25.05, linewidth = 0.5, color = "#009E73") +
  geom_hline(yintercept = 44.1255, linewidth = 0.5, color = "#CC79A7", linetype = 11) +
  geom_point(position = position_dodge(0.2)) +
  geom_function(fun = \(x) 44.1255 + 0.7681 * x, color = "#CC79A7") +
  xlim(c(0, NA)) + ylim(c(40, 150)) +
  annotate("point", x = c(25.05, 29.46, 33.69), y = c(70.0, 107.8, 101.7), 
           label = c(70.0, 107.8, 101.7), fill = c("#009E73", "#56B4E9", "#E69F00"),
           alpha = 1, size = 2, shape = 23) +
  annotate("label", x = c(25.05, 29.46, 33.69)+c(2,3,3), y = c(70.0, 107.8, 101.7)+5, 
           label = c(70.01, 107.87, 101.69), fill = c("#009E73", "#56B4E9", "#E69F00"),
           alpha = 0.5, size = 3) +
  labs(title = "Modell mit Kovariate und Faktor sowie Interaktion",
       subtitle = "Intercept ist der Mittelwert der Sprungweiten der Behandlung Zuckerwasser\ngekippt um die Steigung der Kovariate",
       x = "Kaliumgehalt im Blut [mmol/ml]", y = "Sprungweite in [cm]", color = "Fütterungsart") +
  scale_color_okabeito() +
  theme(legend.position = "top") +
  geom_segment(aes(x = 40, xend = 40, y = 44.1255, yend = 44.1255 + 40 * 0.7681),
               color = "#CC79A7") +
  annotate("text", hjust = "left", x = 41, y = 44.1255 + (40 * 0.7681)/2,
           label = expression(beta[K]*"="~40%.%0.77)) +
  scale_x_continuous(breaks = c(0, 10, 20, 25.05, 29.46, 33.69, 40, 50),
                     guide = guide_axis(n.dodge = 2),
                     limits = c(0, NA))
```

## Theoretisch in R

Aus Gründen der Einfachheit lassen wir einmal die Interaktion weg.

```{r}
model.matrix(svl ~ mass + color, data = snake_tbl) |> as_tibble() 
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  50 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  1 & 6 & 0 & 0  \\
  1 & 8 & 0 & 0  \\
  1 & 5 & 1 & 0  \\
  1 & 7 & 1 & 0  \\
  1 & 9 & 1 & 0  \\
  1 & 11 & 0 & 1  \\
  1 & 12 & 0 & 1  \\
  1 & 10 & 0 & 1  \\
 \end{pmatrix}
 \times
  \begin{pmatrix}
  \beta_0 \\
  \beta_{mass}\\
  \beta^{color}_{rot} \\
  \beta^{color}_{blau} \\
 \end{pmatrix} +
  \begin{pmatrix}
  \epsilon_1 \\
  \epsilon_2 \\
  \epsilon_3 \\
  \epsilon_4 \\
  \epsilon_5 \\
  \epsilon_6 \\
  \epsilon_7 \\
  \epsilon_8 \\
 \end{pmatrix}
$$

```{r}
cov1_fac1_fit <- lm(svl ~ mass + color, data = snake_tbl)
```

```{r}
cov1_fac1_fit |> coef() |> round(2)
```

```{r}
cov1_fac1_fit |> residuals() |> round(2)
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  51 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  19.17 & 6 \cdot 3.33  & 0 \cdot 4.83 & 0 \cdot -1.17  \\
  19.17 & 8 \cdot 3.33  & 0 \cdot 4.83 & 0 \cdot -1.17   \\
  19.17 & 5 \cdot 3.33  & 1 \cdot 4.83 & 0 \cdot -1.17  \\
  19.17 & 7 \cdot 3.33  & 1 \cdot 4.83 & 0 \cdot -1.17  \\
  19.17 & 9 \cdot 3.33  & 1 \cdot 4.83 & 0 \cdot -1.17 \\
  19.17 & 11 \cdot 3.33  & 0 \cdot 4.83 & 1 \cdot -1.17 \\
  19.17 & 12 \cdot 3.33  & 0 \cdot 4.83 & 1 \cdot -1.17  \\
  19.17 & 10 \cdot 3.33  & 0 \cdot 4.83 & 1 \cdot -1.17 \\
 \end{pmatrix} +
  \begin{pmatrix}
  +0.83 \\
  -0.83 \\
  -1.67 \\
  +3.67 \\
  -2.00 \\
  +2.33 \\
  0.00 \\
  -2.33 \\
 \end{pmatrix}
$$

```{r}
c(19.17 + 6*(3.33) + 0*(4.83) + 0*(-1.17) + 0.83,
  19.17 + 8*(3.33) + 0*(4.83) + 0*(-1.17) - 0.83,
  19.17 + 5*(3.33) + 1*(4.83) + 0*(-1.17) - 1.67,
  19.17 + 7*(3.33) + 1*(4.83) + 0*(-1.17) + 3.67,
  19.17 + 9*(3.33) + 1*(4.83) + 0*(-1.17) - 2.00,
  19.17 + 11*(3.33) + 0*(4.83) + 1*(-1.17) + 2.33,
  19.17 + 12*(3.33) + 0*(4.83) + 1*(-1.17) + 0.00,
  19.17 + 10*(3.33) + 0*(4.83) + 1*(-1.17) - 2.33) |> round()
```

```{r}
snake_tbl |> pull(svl)
```

## Simulation

Dieser Abschnitt beinhaltet eine kurze Simulation in R mit einem Tibble und der Erstellung eines normalverteilten Messwerts. Mehr zu der [Generierung von Daten](#sec-eda-gen-data) dann im entsprechenden Kapitel. Ich habe alles ausgelagert, da es dann hier zu voll wurde. Daher ist es hier eher so eine kleine Spielweise.

```{r}
cov1_fac1_tbl <- tibble(c_1 = rnorm(15, 0, 1),
                        f_a = gl(3, 5),
                        y = 2 + 
                            1 * c_1 + 
                            2 * as.numeric(f_a) + 
                                rnorm(15, 0, 0.001))
```

Dann schauen wir uns einmal an, ob wir dann den Intercept und die Koeffizienten wiederfinden. Wenn du den Fehler in `rnorm()` von $0.001$ hochsetzt, dann werden auch die Koeffizienten in dem folgenden Modell ungenauer. Hat aber gut geklappt, wir erhalten die gerundeten Koeffizienten, die wir eingestellt hatten einigermaßen wiedergegeben.

```{r}
lm(y ~ f_a + c_1, cov1_fac1_tbl) |> 
  coef() |> round(2)
```
:::

#### $c_1 + f_A + f_B$ {.unnumbered .unlisted}

Dann kommen wir jetzt zu einem Modell mit drei Einflussvariablen. Wir haben jetzt eine Kovariate sowie zwei Faktoren mit in dem Modell. Wenn wir hier von der Seite der Faktoren schauen und ein faktorielles Experiment mit einem Hauptfaktor vorliegen haben, dann rechnen wir eigentlich eine klassische [zweifaktorielle ANCOVA](#sec-ancova) (eng. *analysis of covariance*). Es kommt dann aber immer auf die Perspektive der wissenschaftlichen Fragestellung an. Wenn wir wirklich alles gleichwertig ansehen und unsere Faktoren eher beobachtete kategoriale Einflussvariablen sind, dann müssen wir das Modell eher im Sinne einer multiplen Regression betrachten. Das wollen wir dann hier auch einmal machen.

::: callout-warning
## Achtung, bitte beachten!

Jetzt wird es komplizierter. Je mehr Einflussvariablen wir in ein Modell nehmen, desto komplexer werden die Modelle. Besonders Faktoren verursachen dann immer mehr Level, die sich dann im Intercept konzentrieren. So kann es sehr schnell sein, dass der Intercept aus dem Mittel einer Faktorkombination von vielen ist. Dann wird die Interpretation herausfordernd, da der Bezug zum Intercept herausfordernd ist.
:::

In der folgenden schematischen Darstellung siehst du dann einmal unser multiples Modell. Wir haben einen Messwert sowie eine Kovariate und zwei Faktoren. Ein Faktor hat drei Level und der andere Faktor dann nur zwei Level. Im Prinizip können wir auch noch Faktoren mit mehr Leveln vorliegen haben, aber dann wird das Modell immer größer. Die grundsätzlichen Ideen bleiben aber gleich.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Schemantisches multiplen Modell mit einem Messwert $Y$ und einer kontinuierlichen Einflussvariable als Kovariate $c_1$ sowie einer kategorialen Einflussvariablen als Faktor $f_A$ mit drei Leveln und einer kategorialen Einflussvariablen als Faktor $f_B$ mit zwei Leveln dargestellt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-16

p_c1_fa_2lvl_fb_3lvl_model
```

Jetzt können wir das Modell einmal in R rechnen. Dazu nehmen wir dann in das Modell einmal den Kaliumgehalt im Blut der Flöhe sowie die Fütterungsart und das Alter der Flöhe in den beiden Gruppen juvenile und adult. Ich nehme hier mal keine Interaktion mit ins Modell, das wird dann sehr groß. Wir können ja hier verschiedene Interaktionen berechnen, die dann sehr stark von der Fragestellung abhängn. Die Interpretation ist dann aber ähnlich wie in dem Modell mit einer Kovariate und einem Faktor weiter oben.

::: panel-tabset
## Praktisch in R

Im Folgenden siehst du einmal das multiple Modell mit drei Einflussvariablen. Wir schauen uns die Kovariate Kalium an sowie die beiden Faktoren Enrährung und Entwicklungsstand. Dabei hat die Ernährung dann drei Gruppen und der Entwicklungsstand betrachtet die juvenilen und adulten Flöhe. Ich habe hier dann mal keine Interaktion mit ins Modell genommen.

```{r}
cov1_fac2_fit <- lm(jump_length ~ K + feeding + stage, data = flea_model_tbl) 
```

Dann können wir uns schon die Koeffizienten des Modells anschauen. Die Level der Faktoren, die jetzt fehlen kummulieren dann in dem Intercept. Das heißt jetzt für uns, dass der Intercept die adulten Zuckerflöhe repräsentiert. Die Änderung zu dem Intercept erklären jetzt die Koeffizienten. Darüber hinaus haben wir dann noch die Steigung der Kovariate, die eben dann den Effekt des Kaliumgehalt im Blut auf die Sprungleistung entspricht.

```{r}
cov1_fac2_fit |> 
  coef() |> round(2)
```

Wir erhlaten dann in der Zusammenfassung nochmal mehr Informationen. Ich habe auch hier auf die Annotierung verzichtet, da sich hier viel wiederholt und ich die Koeffizienten dann gleich nochmal gesondert erkläre. Wir sehen hier aber, dass unser Modell nicht so gut funktioniert hat, da wir eine Abweichung von der Normalverteilung in den Residuen vorliegen haben. Der Median sollte eigentlich Null sein. Die restlichen Gütezahlen sind dann auch nur okay.

```{r}
#| eval: true
cov1_fac2_fit |> summary()
```

Für die Interpretation der Koeffizienten helfen dann auch immer die lokalen Mittlwerte der SPrungweiten und der Kaliumgehalte für die Faktorkombinationen. Ich habe die die Mittelwerte dann einmal in der folgenden Tabelle dargestellt.

```{r}
#| message: false
#| warning: false
flea_model_tbl |> 
  group_by(feeding, stage) |> 
  summarise(mean(jump_length),
            mean(K))
```

Das eigentlich spannende sind jetzt die Koeffizienten. Hier müssen wir nochmal aufpassen, dass sich in dem Intercept die adulten Zuckerflöhe verstecken. Die Änderung zu dieser Faktorkombination stellen dann die Koeffizienten dar. Um dann auf die entgültigen lokalen Mittelwerte der Sprungweiten in den Faktorkombinationen zu kommen, müssen wir die lokalen Mittelwerte des Kaliumgehalts mit der Steigung der Kovariate multiplizieren. Dazu benötigen wir auch die mittleren Residuen für die Faktorkombinationen. Ja, das ist echt eine Menge. Ich berechne also einmal die mittleren Residuen als Fehler.

```{r}
#| message: false
#| warning: false
cov1_fac2_fit |> 
  augment() |> 
  group_by(feeding, stage) |> 
  summarise(mean_resid = round(mean(.resid), 2))
```

Dann können wir alles zusammenbringen. Ziel ist es für jede Faktorkombination aus der Ernährung und dem Entwicklungsstand einmal die lokalen Mittelwerte der Sprungweiten aus den Koeffizienten und den Residuen zusammenzubauen. So haben wir dann den Intercept als lokalen Mittelwert der adulten Zuckerflöhe auf dem Mittel der Kovariaten. Je nach Faktorkombination müssen wir dann andere Koeffizienten zusammen mit den Residuen aufaddieren um auf die lokalen Mittel der Sprungweiten zu kommen. Du musst dir das eine Zeit anschauen, auch für mich war die Berechnung nicht gleich klar.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table-cov1-fac2
#| tbl-cap: "Zusammensetzung der Mittelwerte der Sprungweiten $\\bar{Y}$ für jede Faktorkombination aus der Ernährungsart und dem Entwicklungsstand sowie dem Kaliumgehalt in Blut aus den Koeffizienten des multiplen Modells. Am Ende kommen noch die mittleren Residuen als Fehler mit hinzu."
options(knitr.kable.NA = '')

tibble("$f_{feeding}$" = rep(c("sugar", "blood", "ketchup"), each = 2),
       "$f_{stage}$" = rep(c("adult", "juvenile"), 3),
       "$\\bar{c}_{K}$" = c(37.0, 30.4, 17.3, 41.7, 20.6, 29.5), 
       "$\\bar{Y}$" = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0), 
       "$\\boldsymbol{\\beta_{0}}$" = 59.71,
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{K}}$" = c("$9.25 = 37.0 \\cdot 0.25$",
                                                          "$7.6 = 30.4 \\cdot 0.25$",
                                                          "$4.3 = 17.3 \\cdot 0.25$",
                                                          "$10.4 = 41.7 \\cdot 0.25$",
                                                          "$5.2 = 20.6 \\cdot 0.25$",
                                                          "$7.4 = 29.5 \\cdot 0.25$"),
       "$\\boldsymbol{\\beta_{blood}}$" = c(NA, NA, 38.93, 38.93, NA, NA),
       "$\\boldsymbol{\\beta_{ketchup}}$" = c(NA, NA, NA, NA, 33.89, 33.89),
       "$\\boldsymbol{\\beta_{juvenile}}$" = c(NA, 3.58, NA, 3.58, NA, 3.58),
       "$\\boldsymbol{\\epsilon}$" = c(9.9, -9.9, -3.3, 3.3, -6.6, 6.6)) |> 
  kable(align = "c", "pipe")
```

In der folgenden Abbildung habe ich versucht dir den Zusammenhang nochmal darzustellen. Die lokalen Mittelwerte der Sprungweiten für die Faktorkombinationen liegen dann auf den Mittelwerten der Kovariaten. Wir kippen dann den Intercept um die Steigung der Kovariaten um dann die Abweichungen an den lokalen Mitteln zu bestimmen. Ja, es klingt wild, aber so wird es eben gerechnet. Daher wird die Darstellung auch immer schwerer, da wir hier jetzt sechs Punktewolken haben, die natürlich nicht aufsteigend sortiert nach den Kovariaten sind. Die gestrichelte Linie dient dir nochmal als Orientierung für einen konstanten Intercept.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6.5
#| fig-cap: "Darstellung der Gruppenmittelwerte der Sprungweiten aus dem kombinierten Modell zur Ernährung sowie dem Entwicklungsstand und dem Kaliumgehalt im Blut von Flöhen. Der Intercept liegt auf dem lokalen Mittelwert der adulten Flöhe, die Zuckerwasser trinken und wird um die Steigung der Kovariaten gekippt. Die Ordnung hat nichts mit dem Mittelwert der Kovariate zu tun. Die lokalen Mittel der Ernährungstypen liegen auf den Mittelwerten der Kovariaten in den entsprechenden Leveln der Faktorkombinationen. *[Zum Vergrößern anklicken]*"
#| label: fig-model-basic-cov1-fac2-02

ggplot(flea_model_tbl, aes(K, jump_length, color = feeding, shape = stage)) +
  theme_modeling() +
  geom_vline(xintercept = 37.0, linewidth = 0.5, color = "#E69F00") +
  geom_vline(xintercept = 30.4, linewidth = 0.5, color = "#E69F00", linetype = 2) +
  geom_vline(xintercept = 17.3, linewidth = 0.5, color = "#56B4E9") +
  geom_vline(xintercept = 41.7, linewidth = 0.5, color = "#56B4E9", linetype = 2) +
  geom_vline(xintercept = 20.6, linewidth = 0.5, color = "#009E73") +
  geom_vline(xintercept = 29.5, linewidth = 0.5, color = "#009E73", linetype = 2) +
  geom_hline(yintercept = 59.7160, linewidth = 0.5, color = "#CC79A7", linetype = 11) +
  geom_point(position = position_dodge(0.2)) +
  geom_function(fun = \(x) 59.7160 + 0.2523 * x, color = "#CC79A7") +
  xlim(c(0, NA)) + ylim(c(40, 150)) +
  annotate("point", x = c(37.0, 30.4, 17.3, 41.7, 20.6, 29.5), 
           y = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0), 
           label = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0), 
           fill = c("#E69F00", "#E69F00", "#56B4E9", "#56B4E9", "#009E73", "#009E73"),
           alpha = 1, size = 2, shape = 23) +
  annotate("label", x = c(37.0, 30.4, 17.3, 41.7, 20.6, 29.5)+c(2, 2, 2.5, 2.5, 2.5, 2.5), 
           y = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0)+5, 
           label = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0), 
           fill = c("#E69F00", "#E69F00", "#56B4E9", "#56B4E9", "#009E73", "#009E73"),
           alpha = 0.5, size = 3) +
  labs(title = "Modell mit Kovariate und zwei Faktoren",
       subtitle = "Intercept ist der Mittelwert der Sprungweiten der Behandlung Zuckerwasser\nund adult gekippt um die Steigung der Kovariate", shape = "Entwicklungsstand",
       x = "Kaliumgehalt im Blut [mmol/ml]", y = "Sprungweite in [cm]", color = "Fütterungsart") +
  scale_color_okabeito() +
  theme(legend.position = "top")  +
  geom_segment(aes(x = 40, xend = 40, y = 59.7160, yend = 59.7160 + 40 * 0.2523),
               color = "#CC79A7") +
  annotate("text", hjust = "left", x = 41, y = 59.7160 + (40 * 0.2523)/2,
           label = expression(beta[K]*"="~40%.%0.25))  +
  scale_x_continuous(breaks = c(0, 10, 17.3, 20.6, 29.5, 30.4, 37.0, 41.7, 50),
                     guide = guide_axis(n.dodge = 2),
                     limits = c(0, NA)) +
  guides(color=guide_legend(nrow=2,byrow=TRUE))
```

## Theoretisch in R

```{r}
model.matrix(svl ~ mass + region + color, data = snake_tbl) |> as_tibble() 
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  51 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  1 & 6 & 0 & 0 & 0 \\
  1 & 8 & 0 & 0 & 0\\
  1 & 5 & 0 & 1 & 0\\
  1 & 7 & 1 & 1 & 0\\
  1 & 9 & 1 & 1 & 0\\
  1 & 11& 1 & 0 & 1\\
  1 & 12& 1 & 0 & 1\\
  1 & 10& 1 & 0 & 1\\
 \end{pmatrix}
 \times
  \begin{pmatrix}
  \beta_0 \\
  \beta_{mass} \\
  \beta^{region}_{nord} \\
  \beta^{color}_{rot} \\
  \beta^{color}_{blau} \\
 \end{pmatrix} +
  \begin{pmatrix}
  \epsilon_1 \\
  \epsilon_2 \\
  \epsilon_3 \\
  \epsilon_4 \\
  \epsilon_5 \\
  \epsilon_6 \\
  \epsilon_7 \\
  \epsilon_8 \\
 \end{pmatrix}
$$

```{r}
cov1_fac2_fit <- lm(svl ~ mass + region + color, data = snake_tbl) 
cov1_fac2_fit |> coef() |> round(2)
```

```{r}
cov1_fac2_fit |> residuals() |> round(2)
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  50 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  25 & \phantom{0}6 \cdot 2.5 & 0 \cdot 5 & 0 \cdot 1.5& 0 \cdot -2.83 \\
  25 & \phantom{0}8 \cdot 2.5 & 0 \cdot 5 & 0 \cdot 1.5& 0 \cdot -2.83\\
  25 & \phantom{0}5 \cdot 2.5 & 0 \cdot 5 & 1 \cdot 1.5& 0 \cdot -2.83\\
  25 & \phantom{0}7 \cdot 2.5 & 1 \cdot 5 & 1 \cdot 1.5& 0 \cdot -2.83\\
  25 & \phantom{0}9 \cdot 2.5 & 1 \cdot 5 & 1 \cdot 1.5& 0 \cdot -2.83\\
  25 & 11\cdot 2.5 & 1 \cdot 5 & 0 \cdot 1.5& 1 \cdot -2.83\\
  25 & 12\cdot 2.5 & 1 \cdot 5 & 0 \cdot 1.5& 1 \cdot -2.83\\
  25 & 10\cdot 2.5 & 1 \cdot 5 & 0 \cdot 1.5& 1 \cdot -2.83\\
 \end{pmatrix} +
  \begin{pmatrix}
  \phantom{+}0.00 \\
  \phantom{+}0.00 \\
  \phantom{+}0.00 \\
  +2.00 \\
  -2.00 \\
  +2.33 \\
  +0.83 \\
  -3.17 \\
 \end{pmatrix}
$$

```{r}
c(25 +  6*2.5 + 0*5 + 0*1.5 + 0*-2.83 + 0.00,
  25 +  8*2.5 + 0*5 + 0*1.5 + 0*-2.83 + 0.00,
  25 +  5*2.5 + 0*5 + 1*1.5 + 0*-2.83 + 0.00,
  25 +  7*2.5 + 1*5 + 1*1.5 + 0*-2.83 + 2.00,
  25 +  9*2.5 + 1*5 + 1*1.5 + 0*-2.83 - 2.00,
  25 + 11*2.5 + 1*5 + 0*1.5 + 1*-2.83 + 2.33,
  25 + 12*2.5 + 1*5 + 0*1.5 + 1*-2.83 + 0.83,
  25 + 10*2.5 + 1*5 + 0*1.5 + 1*-2.83 - 3.17) 
```

```{r}
snake_tbl |> pull(svl)
```

## Simulation

Dieser Abschnitt beinhaltet eine kurze Simulation in R mit einem Tibble und der Erstellung eines normalverteilten Messwerts. Mehr zu der [Generierung von Daten](#sec-eda-gen-data) dann im entsprechenden Kapitel. Ich habe alles ausgelagert, da es dann hier zu voll wurde. Daher ist es hier eher so eine kleine Spielweise.

```{r}
cov1_fac2_tbl <- tibble(c_1 = rnorm(30, 0, 1),
                        f_a = rep(gl(3, 5), 2),
                        f_b = gl(2, 15),
                        y = 2 + 
                            1 * c_1 + 
                            2 * as.numeric(f_a) + 
                            3 * as.numeric(f_b) + 
                                rnorm(15, 0, 0.001))
```

Dann schauen wir uns einmal an, ob wir dann den Intercept und die Koeffizienten wiederfinden. Wenn du den Fehler in `rnorm()` von $0.001$ hochsetzt, dann werden auch die Koeffizienten in dem folgenden Modell ungenauer. Hat aber gut geklappt, wir erhalten die gerundeten Koeffizienten, die wir eingestellt hatten einigermaßen wiedergegeben.

```{r}
lm(y ~ c_1 + f_a + f_b, cov1_fac2_tbl) |> 
  coef() |> round(2)
```
:::

#### $c_1 + c_2 + f_A + f_B$ {.unnumbered .unlisted}

Am Ende kommen wir dann nochmal zu einem Modell mit zwei Kovariaten und zwei Faktoren. Auch wenn wir dann die Interaktionen weglassen, wird das Modell immer komplexer. Hier können wir uns dann das Modell auch nicht mehr visualiseren. Prinzipiell ginge es schon mit einem dreidimensionalen Scatterplot, aber es wird dadurch eigentlich nicht übersichtlicher. Wir hätten dann die Faktorkombinationen auf den kombinierten Mittelwerten der Kovariaten. Das wird dann eigentlich immer nur noch ein Durcheinander, da wir ja auch noch alle Beobachtungen als Scatterplot vorliegen haben. Deshalb hier dann ohne Visualisierung. Das ist dann eigentlich aucb üblich, dass wir dann ab einer Kovariaten und Faktor dann keine Visualisierung mehr nutzen.

::: callout-warning
## Achtung, bitte beachten!

Jetzt wird es komplizierter. Je mehr Einflussvariablen wir in ein Modell nehmen, desto komplexer werden die Modelle. Besonders Faktoren verursachen dann immer mehr Level, die sich dann im Intercept konzentrieren. So kann es sehr schnell sein, dass der Intercept aus dem Mittel einer Faktorkombination von vielen ist. Dann wird die Interpretation herausfordernd, da der Bezug zum Intercept herausfordernd ist.
:::

Damit haben wir dann folgendes Modell vorliegen. Im Prinzip kannst du noch mehr Kovariaten oder Faktoren mit ins Modell nehmen. Wir enden dann aber einmal bei diesem Modell mit zwei Kovariaten und zwei Faktoren. Hier ist dann wichtig, dass der Intercept die beiden ersten Level der beiden Faktoren einschließt. Das klingt erstmal kompliziert, wird dann aber im Folgenden hoffentlich klarer. Je mehr Faktoren du hast, desto wichtiger wird dann die Ordnung der Level in den Faktoren, da das niedrigste Level ja über alle Faktoren im Intercept zusammengefasst wird.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Schemantisches multiples Modell mit einem Messwert $Y$ und einer kontinuierlichen Einflussvariable als Kovariate $c_1$ sowie einer kategorialen Einflussvariablen als Faktor $f_A$ mit drei Leveln und einer kategorialen Einflussvariablen als Faktor $f_B$ mit zwei Leveln dargestellt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-in-R-21

p_c2_fa_2lvl_fb_3lvl_model 
```

Dann wollen wir uns einmal das multiple Modell in R anschauen. In den weiteren Tabs findest du dann nochmal die theoretische Betrachtung in R sowie eine kleine Simulation zum nachvollziehen, wie so die Effekte zusammenkommen. Am Ende kommt es bei komplexeren Modellen sehr auf die wissenschaftliche Fragestellung an. Ein gutes Modellieren dauert dann eben seine Zeit. Insbesondere da wir hier ja noch nicht mal quadratische oder komplexere Zusammenhänge wir in dem [Kapitel zu nicht linearen Regression](#sec-non-linear) betrachten.

::: panel-tabset
## Praktisch in R

Bauen wir also zuerst einmal unser multiples Modell in R. Dafür nutze ich hier die beiden Kovariaten Kaliumgehalt und Magnesiumgehalt im Blut der Flöhe sowie die beiden Faktoren der Ernährung und dem Entwicklungsstand. Wir wollen wissen, ob es einen kausalen Zusammenhang zwischen den Einflussvariablen und der Sprungweite gibt. Dabei könnte ich noch Interaktionen mit in das Modell nehme, entscheide mich aber aus Gründen der Komplexität dagegen. Wir bauen dann einmal das Modell.

```{r}
cov2_fac2_fit <- lm(jump_length ~ K + Mg + feeding + stage, data = flea_model_tbl) 
```

Wenn wir uns jetzt die Koeffizienten ansehen, dann sehen wir recht wenig. In einem multiplen Modell musst du immer aufpassen, dass du die Effekte der Faktoren nicht überinterpretierst und die Effekte der Kovariaten unterschätzt. Die Effekte hängen von den Einheiten und der Anzahl an Leveln ab. Daher haben Faktoren mesit sehr große Effekte im Vergleich zu den Kovariaten im Modell.

```{r}
cov2_fac2_fit |> 
  coef() |> round(2)
```

Wir brauchen also einmal die Ausgabe der Zusammenfassung des Modells. Hier sehen wir schon etwas mehr. Das Modelll ist mit einem adjustierten Bestimmtheitsmaß $R^2$ von 0.1695 nicht gerade gut. Auch sind die Residuen eher weniger normalverteilt. Wir können aber soweit einmal mit dem Modell leben. Wir sehen auch, dass nur die Fütterungen signifikant sind. Achtung, in dem Intercept sind hier die adulten Zuckerflöhe zu denen dann die Steigung der adulten Blutflöhe und Ketchupflöhe verglichen wird. Meistens ist es dann nicht mehr die Frage, die du an die Daten hast. Deshalb sind eventuell die [Marginal effect models](#sec-marginal) hilfreicher bei der Beantwortung deiner Fragen.

```{r}
#| eval: true
cov2_fac2_fit |> summary()
```

Um die Effekte der einzelnen Faktorkombinationen dann zu verstehen, brauchen wir wie immer einmal die lokalen Mittelwerte aller Faktorkombinationen der Sprungweiten und dann eben auch die Mittelwerte der Kovariaten. Daher hier ein großes Set an an Mittelwerten für die jeweiligen sechs Faktorkombinationen.

```{r}
#| message: false
#| warning: false
flea_model_tbl |> 
  group_by(feeding, stage) |> 
  summarise(mean(jump_length),
            mean(K),
            mean(Mg))
```

Dann brauchen wir noch die gemittelten Residuen für die Faktorkombinationen damit dann auch am Ende die Zaheln wieder aufgehen. Wir wollen dann ja am Ende die Sprungweiten aus den Koeffizienten und den Residuen wieder zusammensetzen können.

```{r}
#| message: false
#| warning: false
cov2_fac2_fit |> 
  augment() |> 
  group_by(feeding, stage) |> 
  summarise(mean_resid = round(mean(.resid), 2))
```

Am Ende haben wir dann diese riesige Tabelle mit Koeffizienten und Mittelwerten der Kovariaten für die Faktorkombinationen. Das sieht wild aus und du musst dich da vermutlich einmal reinknien damit du die Zuammenhänge einmal siehst. Em Ende wollen wir den Mittelwert der Sprungweiten $\bar{Y}$ aus den Koeffizienten für die Faktorkombinatioen wieder haben. Dafür müssen sich die Koeffzienten und die Residuen eben zu den lokalen Mitteln der Sprungweiten aufaddieren lassen. Hier siehst du dann auch gut, wie dann eben der Intercept aus den Zuckerflöhen gebildet wird und die Koeffizienten dann die Abweichungen zu den Zuckerflöhen beschreiben. Meistens ist es dann doch nicht so ganz was man möchte. Das ist eben das generelle Problem von großen multiplen Modellen mit vielen Faktoren. Am Ende ist der Intercept eine sehr spezifische Subgruppe.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-model-table-cov2-fac2
#| tbl-cap: "Zusammensetzung der Mittelwerte der Sprungweiten $\\bar{Y}$ für jede Faktorkombination aus der Ernährungsart und dem Entwicklungsstand sowie dem Kaliumgehalt und Magnesiumgehalt in Blut aus den Koeffizienten des multiplen Modells. Am Ende kommen noch die mittleren Residuen als Fehler mit hinzu."
options(knitr.kable.NA = '')

tibble("$f_{feeding}$" = rep(c("sugar", "blood", "ketchup"), each = 2),
       "$f_{stage}$" = rep(c("adult", "juvenile"), 3),
       "$\\bar{c}_{K}$" = c(37.0, 30.4, 17.3, 41.7, 20.6, 29.5), 
       "$\\bar{c}_{Mg}$" = c(18.6, 9.7, 19.2, 9.3, 19.4, 18.9), 
       "$\\bar{Y}$" = c(79.0, 61.0, 99.7, 116.0, 92.1, 111.0), 
       "$\\boldsymbol{\\beta_{0}}$" = 52.3,
       "$\\boldsymbol{\\bar{c}_{K}\\cdot\\beta_{K}}$" = c("$9.62 = 37.0 \\cdot 0.26$",
                                                          "$7.9 = 30.4 \\cdot 0.26$",
                                                          "$4.5 = 17.3 \\cdot 0.26$",
                                                          "$10.8 = 41.7 \\cdot 0.26$",
                                                          "$5.4 = 20.6 \\cdot 0.26$",
                                                          "$7.7 = 29.5 \\cdot 0.26$"),
       "$\\boldsymbol{\\bar{c}_{Mg}\\cdot\\beta_{Mg}}$" = c("$7.8 = 18.6 \\cdot 0.42$",
                                                            "$4.1 = 9.7 \\cdot 0.42$",
                                                            "$8.1 = 19.2 \\cdot 0.42$",
                                                            "$3.9 = 9.3 \\cdot 0.42$",
                                                            "$2.2 = 19.4 \\cdot 0.42$",
                                                            "$7.9 = 18.9 \\cdot 0.42$"),
       "$\\boldsymbol{\\beta_{blood}}$" = c(NA, NA, 38.92, 38.92, NA, NA),
       "$\\boldsymbol{\\beta_{ketchup}}$" = c(NA, NA, NA, NA, 31.82, 31.82),
       "$\\boldsymbol{\\beta_{juvenile}}$" = c(NA, 6.22, NA, 6.22, NA, 6.22),
       "$\\boldsymbol{\\epsilon}$" = c(9.35, -9.35, -3.98, 3.98, -5.37, 5.37)) |> 
  kable(align = "c", "pipe")
```

Hier bietet es sich dann nochnmal an zu Testen, ob unser Modell überhaupt besser ist als das reine Nullmodell nur mit dem Intercept. Wir können hier die ANOVA dafür nutzen. Wir erhalten dann als p-Wert den gleichen p-Werte wie schon in der letzten Zeile in der Widergabe der Zusammenfassung unseres Modells. Mit einem p-Wert von gerade einmal 0.02 sehen wir dann auch, dass unser Modell nicht sehr viel erklärt.

```{r}
anova(lm(jump_length ~ 1, data = flea_model_tbl),
      lm(jump_length ~ K + Mg + feeding + stage, data = flea_model_tbl))
```

Bitte schaue dann für die Entscheidung welches Modell besser ist dann weiter unten in de Abschnitt zur Vergleich von Modellen nochmal rein. Du kannst beliebig viele Modelle bauen und schauen, welches Modell am besten abschneidet. Du darfst dabei natürlich nicht deine Fragestellung aus den Augen verlieren, aber das ist ja sowieso immer die Herausforderung. Am Ende ist man so im Kaninchenbau, dass man vergisst was das Ziel eigentlich war.

## Theoretisch in R

```{r}
model.matrix(svl ~ mass + diameter + region + color, data = snake_tbl) |> as_tibble() 
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  51 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  1 & 6 & 9 & 0 & 0 & 0 \\
  1 & 8 & 3 & 0 & 0 & 0\\
  1 & 5 & 6 & 0 & 1 & 0\\
  1 & 7 & 7 & 1 & 1 & 0\\
  1 & 9 & 5 & 1 & 1 & 0\\
  1 & 11 & 4 & 1 & 0 & 1\\
  1 & 12 & 10 & 1 & 0 & 1\\
  1 & 10 & 11 & 1 & 0 & 1\\
 \end{pmatrix}
 \times
  \begin{pmatrix}
  \beta_0 \\
  \beta_{mass} \\
  \beta_{diameter} \\
  \beta^{region}_{nord} \\
  \beta^{color}_{rot} \\
  \beta^{color}_{blau} \\
 \end{pmatrix} +
  \begin{pmatrix}
  \epsilon_1 \\
  \epsilon_2 \\
  \epsilon_3 \\
  \epsilon_4 \\
  \epsilon_5 \\
  \epsilon_6 \\
  \epsilon_7 \\
  \epsilon_8 \\
 \end{pmatrix}
$$

```{r}
cov2_fac2_fit <- lm(svl ~ mass + diameter + region + color, data = snake_tbl) 
cov2_fac2_fit |> coef() |> round(2)
```

```{r}
cov2_fac2_fit |> residuals() |> round(2)
```

$$
 \begin{pmatrix}
  40 \\
  45 \\
  39 \\
  50 \\
  52 \\
  57 \\
  58 \\
  49 \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  31.18 & 6 \cdot 1.94 & 9 \cdot -0.37 & 0 \cdot 6.68 & 0 \cdot 0.38 & 0 \cdot -1.40 \\
  31.18 & 8 \cdot 1.94 & 3 \cdot -0.37 & 0 \cdot 6.68 & 0 \cdot 0.38 & 0 \cdot -1.40\\
  31.18 & 5 \cdot 1.94 & 6 \cdot -0.37 & 0 \cdot 6.68 & 1 \cdot 0.38 & 0 \cdot -1.40\\
  31.18 & 7 \cdot 1.94 & 7 \cdot -0.37 & 1 \cdot 6.68 & 1 \cdot 0.38 & 0 \cdot -1.40\\
  31.18 & 9 \cdot 1.94 & 5 \cdot -0.37 & 1 \cdot 6.68 & 1 \cdot 0.38 & 0 \cdot -1.40\\
  31.18 & 11\cdot 1.94 & 4 \cdot -0.37 & 1 \cdot 6.68 & 0 \cdot 0.38 & 1 \cdot -1.40\\
  31.18 & 12\cdot 1.94 & 10 \cdot -0.37 & 1 \cdot 6.68 & 0 \cdot 0.38 & 1 \cdot -1.40\\
  31.18 & 10\cdot 1.94 & 11 \cdot -0.37 & 1 \cdot 6.68 & 0 \cdot 0.38 & 1 \cdot -1.40\\
 \end{pmatrix} +
  \begin{pmatrix}
  0.56 \\
  -0.56 \\
  0.00 \\
  +1.81 \\
  -1.81 \\
  +0.71 \\
  +2.02 \\
  -2.73 \\
 \end{pmatrix}
$$

```{r}
c(31.18 +  6*1.94 +  9*-0.37 + 0*6.68 + 0*0.38 + 0*-1.40 + 0.56,
  31.18 +  8*1.94 +  3*-0.37 + 0*6.68 + 0*0.38 + 0*-1.40 - 0.56,
  31.18 +  5*1.94 +  6*-0.37 + 0*6.68 + 1*0.38 + 0*-1.40 + 0.00,
  31.18 +  7*1.94 +  7*-0.37 + 1*6.68 + 1*0.38 + 0*-1.40 + 1.81,
  31.18 +  9*1.94 +  5*-0.37 + 1*6.68 + 1*0.38 + 0*-1.40 - 1.81,
  31.18 + 11*1.94 +  4*-0.37 + 1*6.68 + 0*0.38 + 1*-1.40 + 0.71,
  31.18 + 12*1.94 +  10*-0.37 + 1*6.68 + 0*0.38 + 1*-1.40 + 2.02,
  31.18 + 10*1.94 +  11*-0.37 + 1*6.68 + 0*0.38 + 1*-1.40 - 2.73) |> round()
```

```{r}
snake_tbl |> pull(svl)
```

## Simulation

Dieser Abschnitt beinhaltet eine kurze Simulation in R mit einem Tibble und der Erstellung eines normalverteilten Messwerts. Mehr zu der [Generierung von Daten](#sec-eda-gen-data) dann im entsprechenden Kapitel. Ich habe alles ausgelagert, da es dann hier zu voll wurde. Daher ist es hier eher so eine kleine Spielweise.

```{r}
cov2_fac2_tbl <- tibble(c_1 = rnorm(30, 0, 1),
                        c_2 = rnorm(30, 0, 1),
                        f_a = rep(gl(3, 5), 2),
                        f_b = gl(2, 15),
                        y = 2 + 
                            1 * c_1 + 
                            -1 * c_2 + 
                            2 * as.numeric(f_a) + 
                            3 * as.numeric(f_b) + 
                                rnorm(15, 0, 0.001))
```

Dann schauen wir uns einmal an, ob wir dann den Intercept und die Koeffizienten wiederfinden. Wenn du den Fehler in `rnorm()` von $0.001$ hochsetzt, dann werden auch die Koeffizienten in dem folgenden Modell ungenauer. Hat aber gut geklappt, wir erhalten die gerundeten Koeffizienten, die wir eingestellt hatten einigermaßen wiedergegeben.

```{r}
lm(y ~ c_1 + c_2 + f_a + f_b, cov2_fac2_tbl) |> 
  coef() |> round(2)
```
:::

## Prädiktives Modell

Neben dem klassischen kausalen Modell können wir auch ein prädiktives Modell rechnen. In einem prädiktiven Modell wollen wir wissen, welche Werte unser Messwert für neue Werte der Einflussvariable annehmen würde. Auch in einem prädiktiven Modell rechnen wir erstmal ganz normal eine multiple lineare Regression. Dann nutzen wir das Modell der Regression um neue Werte für unseren Messwert anhand neuer oder alter Werte der Einflussvariable vorherzusagen. Daher können wir auch beides miteinander verbinden. Du schaust erst was das kausale Modell ergibt und lässt dir dann neue Messwerte vorhersagen. Dabei musst du immer beachten, dass die vorhergesagten Messwerte auf der angepassten Ebene der Regression liegen. Daher nennen wir die vorhergesagten Messwerte auch angepasste Messwerte (eng. *fitted*). Wir werden später in der [Klassifikation](#sec-class-basic), der Vorhersage von $0/1$-Werten, noch andere Prädktionen und deren Maßzahlen kennen lernen. Die vorgehensweise ist aber so identisch mit der im [Kapitel zur simplen linearen Regression](#sec-modeling-simple-stat), so dass ich hier nicht nochmal alles wiederhole. Einfach nochmal dort schauen und die Modelle von oben verwenden. Weitere allgemeine Beispiel finden sich auch in den Kapitel zu den [Marginal effect models](#sec-marginal) und dem [Modellieren in R](#sec-modeling-R).

## Weiteres von Interesse

In den folgenden Abschnitten schauen wir nochmal in weitere Dinge von Interesse, die hier direkt mit der multiplen Regression verbunden sind. Deshalb hier nochmal eine Übersicht von statistischen Dingen, die du bei deinen Einflussvariablen beachten musst. Teilweise gehen wir in den folgenden Abschnitten darauf ein oder aber in den folgenden Kapiteln. Wenn das Problem zu groß wurde habe ich das Thema eben ausgelagert.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2.7
#| fig-width: 7
#| fig-cap: "Schemantisches multiples Modell mit einem Messwert $Y$ und verschiedenen Einflussvariablen. Die Einflussvariablen haben verschiedene Herausforderungen und Eigenschaften, die in einer Modellierung beachtet werden müssen. *[Zum Vergrößern anklicken]*"
#| label: fig-model-problem-x

p_problem_x
```

In den folgenden Abschnitten schauen wir uns noch andere Dinge von Interesse in einer multiplen Regression einmal an. Zum einen haben wir ein Problem, wenn unsere Einflussvariablen untereinander zu stark korreliert sind. Das zeige ich dann einmal an den Beinhaaren bei den Flöhen. Auch ist es problematisch, wenn wir eine Einheit gewählt hat, die sehr große Werte beinhaltet. Das kann ich dir gleich einmal an den Yediflöhen aufzeigen. Dann schauen wir nochmal in die Unabhängigkeitsannahme der Einflussvariablen. Neben der Korrelation sollten die Einflussvariablen auch wirklich unabhängig voneinander sein und sich nicht als Modell selbst erklären. Dann am Ende wollen wir natürlich auch noch wissen, was das beste Modell für unsere Daten wäre. Welche Einflussvariablen kann ich den reinnehmen und was ist dann das beste Modell? Darauf gehe ich dann hier auch nochmal ein.

### Einheit der Kovariaten

![Ein seltener Jedifloh, der so machtsensitiv ist, dass seine Fähigkeiten in der Sprungweite extrem erhöht sind.](images/flea_yedi.png){#fig-yedi-flea fig-align="center" width="60%"}

Kommen wir nun nochmal zu einem Problem der Einheit. Wir können einen sehr kleinen Effekt vorliegen haben, der dann signifikant ist. Schnell denken wir dann, dass dieser Effekt sehr klein ust und damit nicht relevant. Wir sprechen aber bei einer Regression immer von der Steigung als Effekt. Wenn sich also die Einheit der Einflussvariable um Eins erhöht, dann steigt der Messwert um den Wert des Koeffizienten der Steigung. Wenn wir also sehr große Werte messen, dann ist die Änderung in einer Einheit sehr klein. Schauen wir uns mal das Beispiel der Jediflöhe an.

Manche Flöhe haben hohe Werte der [Midi-Chlorianer](https://www.jedipedia.net/wiki/Midi-Chlorianer) oder einfach M-Werte. Damit sind diese Flöhe insbesondere sensitiv für die Macht und somit Jediflöhe. Jediflöhe könnten damit auch höhere Sprungweiten vorliegen haben, da die Jediflöhe ja einen teil ihrer MAcht dazu nutzen könnten weiter zu springen. Daher wollen wir mal in einer einfachen simplen Regression mit nur den M-Werten schauen, ob die M-Werte einen Einfluss auf die Sprungweiten haben. Ich lasse mir jetzt nur die Tabelle der Koeffizienten wiedergeben.

```{r}
lm(jump_length ~ M, data = flea_model_tbl) |> 
  summary() |> coef() |> round(3)
```

Wie wir jetzt sehen ist der Effekt mit 0.002cm extrem gering aber dennoch signifkant. Der p-Wert ist kleiner als das Signifikanzniveau $\alpha$ gleich 5%. Ist also der Wert der Midi-Chlorianer nicht relevant? Hier kommt es auf die Einheit und damit die Spannweite der M-Wert an. Die M-Werte laufen von 80.19 bis 25149.36 Anzahl Midi-Chlorianer im Blut. Damit ist eine kleine Änderung in den M-Werten auch nur mit einer kleinen Änderung in den Sprungweiten verbunden. Also Achtung bei Kovariaten mit großer Spannweite und kleinen Einheiten.

Eine Lösung ist es dann die Einheiten zu vergrößern. In unserem Beispiel können wir die M-Werte auf einer Skale *in Tausend* angeben, dann haben wir gleich viel kleinere Werte und die Spannweite ist nicht so groß. Daher ist es immer eine Überlegung wert zu prüfen, ob du Gramm nicht in Kilo darstellen willst oder aber Zentimeter in Meter. Ich habe dir den Zusammenhang in der folgenden Abbildung nochmal veranschaulicht. Die Punkte auf der Abbildung sehen gleich aus, der Koeffizient der Steigung ist es aber nicht mehr. Damit lassen sich die Ergebnisse auch besser interpretieren.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 10
#| fig-cap: "Scatterplot der Sprungweite in [cm] und Anzahl Midi-Chlorianer im Blut. Die lineare Grade und die Gradengleichung wurden ergänzt. Die Punkteverteilung bleibt gleich, aber die Koeffizienten ändern sich durch die angepasste Einheit der M-Werte. **(A)** Die M-Werte auf der Orginalskala. **(B)** Die M-Werte in Tausend. *[Zum Vergrößern anklicken]*"
#| label: fig-model-m-values

p1_einheit <- ggplot(flea_model_tbl, aes(M, jump_length)) +
  theme_modeling() +
  geom_vline(xintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_point() +
  stat_poly_line(color = "#56B4E9", linewidth = 1,
                 fullrange = TRUE, se = FALSE) +
  stat_poly_eq(use_label("eq"), size = 5) +
  labs(x = "Anzahl Midi-Chlorianer im Blut", y = "Sprungweite in [cm]") +
  ylim(NA, 200)

p2_einheit <- ggplot(flea_model_tbl, aes(M/1000, jump_length)) +
  theme_modeling() +
  geom_vline(xintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_point() +
  stat_poly_line(color = "#56B4E9", linewidth = 1,
                 fullrange = TRUE, se = FALSE) +
  stat_poly_eq(use_label("eq"), size = 5) +
  labs(x = "Anzahl Midi-Chlorianer im Blut [in Tausend]", y = "Sprungweite in [cm]") +
  ylim(NA, 200)

p1_einheit + p2_einheit +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

### Confounderanalyse {#sec-confounder}

::: callout-warning
## Achtung, bitte beachten!

Ich gebe hier nur einen kurzen Einblick in die Confounderanalyse, da mir dann aufgefallen ist, dass das Thema dann doch größer wird. Daher bitte dann nochmal ins [Kapitel zur Mediatoranalyse](#sec-modeling-mediator) schauen, wenn du nach dem Lesen meinst, dass du mehr brauchst. Hier also eine kurze Übersicht über die Idee der Confounderanalyse.
:::

In diesem Abschnitt erkläre ich nur einen konzeptionellen Ausschnitt aus der Confounderanalyse. Wir konzentrieren uns hier auf ein Beispiel mit den M-Werten der Flöhe und den Zusammenhang mit den Sprungweiten. Mehr zu Confoundern, Collidern und Mediatoeren gibt es in dem [Kapitel zur Mediatoranalyse](#sec-modeling-mediator) nochmal aufgearbeitet. Ich habe hier beim Schreiben des Kapitels gemerkt, dass das Thema zu groß ist um mal eben in einem Abschnitt abgearbeitet zu werden. Für unsere Betrachtung möglicher Confounder in der Analyse der M-Werte nehme ich hier nicht die M-Werte auf der Originalenskala sondern auf in Tausend, damit mir die Koeffizienten nicht so klein werden.

```{r}
flea_model_tbl <- flea_model_tbl |> 
  mutate(M = M/1000)
```

Betrachten wir nochmal die simple lineare Regression der Anzahl Midi-Chlorianer im Blut in Tausend auf die Sprungweite in \[cm\]. Wir sehen, dass wir einen signifikanten Koeffizienten mit einem positiven Koeffizienten vorliegen haben. Jetzt ist die Frage, ist das jetzt ein wahrer Zusammenhang oder haben wir eventuell Störgrößen (eng. *confounder*) in den Daten vorliegen?

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 6.5
#| fig-cap: "Scatterplot der Sprungweite in [cm] und Anzahl Midi-Chlorianer im Blut. Die lineare Grade und die Gradengleichung wurden ergänzt. *[Zum Vergrößern anklicken]*"
#| label: fig-model-m-values-confounder

ggplot(flea_model_tbl, aes(M, jump_length)) +
  theme_modeling() +
  geom_vline(xintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_point() +
  stat_poly_line(color = "#56B4E9", linewidth = 1,
                 fullrange = TRUE, se = FALSE) +
  stat_poly_eq(use_label("eq"), size = 5) +
  labs(x = "Anzahl Midi-Chlorianer im Blut [in Tausend]", y = "Sprungweite in [cm]") +
  ylim(NA, 200)
```

Was ist also die Idee einer Confounderanalyse? In der folgenden schematischen Darstellung habe ich dir mal einen Fall eines Disturbers (deu. *Störenfrieds*) als Störgröße darsgetellt. Wir wollen den Effekt von X auf Y modellieren. Wir haben aber noch eine andere Einflussvariable als Störer vorliegen. Dieser Störer hat einen Effekt auf X sowie auf Y. Die Interpretation des Zusammenhangs von X auf Y ist so nicht möglich, da der Zusammenhang verzerrt ist. Wir müssen also erstmal den Störer finden. Was in der Theorie irgendwie einleuchtend klingt, ist in der Praxis extrem mühselig.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 2
#| fig-width: 2
#| fig-cap: "Schematische Darstellung eines Disturbers (deu. *Störenfrieds*) als Störgröße. Der kausale Effekt von X auf Y wird durch den Effekt von D gestört. Eine direkte Interpretation des Zusammenhangs von X auf Y ist nicht möglich. *[Zum Vergrößern anklicken]*"
#| label: fig-model-m-dag

set.seed(123)
dagify(
  Y ~ X + C,
  X ~ C
) %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges_fan(aes(label = c("Effekt", "Effekt", "", "")),
                     edge_colour = "gray70", label_size = 5, edge_width = 1,
                     label_colour = "black") +
  geom_dag_text(colour = "black", size = 5.5, parse = TRUE,
                label = c(expression(bold(D)), expression(bold(X)), expression(bold(Y)))) +
  theme_dag() 
```

Betrachten wir also einmal als Beispiel für eine etwas naheliegende Analyse nochmal die Anzahl Midi-Chlorianer im Blut und die Sprungweite. Wir können jetzt einmal schauen, ob es noch andere Einflussvariablen gibt, die die Sprungweite beeinflussen. Damit natürlich dann auch indirekt die Anzahl der Midi-Chlorianer im Blut. Wir schauen uns einmal an, wie es mit der Ernärung und dem Flohschnupfen so aussieht. In der folgenden Abbildung siehts du dann mal den Effekt der Midi-Chlorianer im Blut auf die Sprungweite, wenn wir uns noch die Ernährung mit anschauen. Wir erhalten auf einmal in den Ernärhungsgruppen kaum noch einen Effekt oder gar einen klar negativen Effekt auf die Sprungweiten. Bei der Infektion ist die Lage nicht so eindeutig. Was aber auffällt ist, dass Flöhe mit hoher Anzahl an Midi-Chlorianer im Blut alle Flohschnupfen haben. Ist hier etwa der Flohschnupfen ein Confounder, der auf die Sprungweite und die Midi-Chlorianer im Blut eine Auswirkung hat?

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 10
#| fig-cap: "Scatterplot der Sprungweite in [cm] und Anzahl Midi-Chlorianer im Blut. Die lineare Grade und die Gradengleichung wurden ergänzt. **(A)** Mit der Berücksichtigung der Ernährung der Flöhe. **(B)** Mit der Berücksichtigung der Infektion mit Flohschnupfen. *[Zum Vergrößern anklicken]*"
#| label: fig-model-m-confounding

p1_confounder <- ggplot(flea_model_tbl, aes(M, jump_length, color = feeding)) +
  theme_modeling() +
  geom_vline(xintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_point() +
  stat_poly_line(linewidth = 1,
                 fullrange = TRUE, se = FALSE) +
  stat_poly_eq(use_label("eq"), size = 4, vstep = 0.1) +
  labs(x = "Anzahl Midi-Chlorianer im Blut [in Tausend]", y = "Sprungweite in [cm]",
       color = "Ernährung") +
  ylim(NA, 200) +
  scale_color_okabeito(labels = c("Zuckerwasser", "Blut", "Ketchup")) +
  theme(legend.position = "top")

p2_confounder <- ggplot(flea_model_tbl, aes(M, jump_length, color = as_factor(infected))) +
  theme_modeling() +
  geom_vline(xintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey50") +
  geom_point() +
  stat_poly_line(linewidth = 1,
                 fullrange = TRUE, se = FALSE) +
  stat_poly_eq(use_label("eq"), size = 4, vstep = 0.1) +
  labs(x = "Anzahl Midi-Chlorianer im Blut [in Tausend]", y = "Sprungweite in [cm]",
       color = "Flohschnupfen") +
  ylim(NA, 200) +
  scale_color_okabeito(order = c(7, 5), labels = c("ja", "nein")) +
  theme(legend.position = "top")

p1_confounder + p2_confounder +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Wir können uns hier einmal die drei Modell zusammenbauen um diese dann einmal von den Koeffizienten und den p-Werten miteinander vergleichen zu können. Dann können wir einmal die Modelle untereinander vergleichen. Wir nehmen einmal das Modell nur mit den M-Werten und dann einmal das Modell mit den M-Werten und jeweils der Ernährung und dem Infektionstatus.

```{r}
fit_1 <- lm(jump_length ~ M, data = flea_model_tbl)
fit_2 <- lm(jump_length ~ M + feeding, data = flea_model_tbl)
fit_3 <- lm(jump_length ~ M + infected, data = flea_model_tbl)
```

Wir nutzen hier die tollen Funktionen aus dem [R Paket `{modelsummary}`](https://modelsummary.com/vignettes/get_started.html) und dann dem [R Paket `{tinytable}`](https://vincentarelbundock.github.io/tinytable/) um uns einmal die Modelle im Vergleich anzuschauen. Wir sehen sofort, dass der Effekt der Midi-Chlorianer nicht mehr signifikant wird, wenn wir noch die Ernährung oder aber die Infektion mit ins Modell nehmen. Zwar ist der Flohschnupfen nicht signifikant, aber haben wir hier auch eine verringerte Sprungweite bei den gesunden Flöhen zu den kranken Flöhen. Wir können hier von einem Confoundereffekt ausgehen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-modelsummary-table-confound
#| tbl-cap: "Vergleich der Modelle der Sprungweite und der Midi-Chlorianer sowie potenziellen Störgrößen. Der Interecept wurde aus der Betrachtung entfernt. Der Effekt der Midi-Chlorianer wird nich signifikant, wenn die Ernährung oder der Infektionsstatus mit betrachtet wird."

modelsummary(lst("I" = fit_1, "II" = fit_2, "III" = fit_3), 
             statistic = c("p = {p.value}"),
             coef_map = c("M" = "Midi-Chlorianer",
                          "feedingblood" = "Ernährung (Blut)",
                          "feedingketchup" = "Ernährung (Ketchup)",
                          "infected0" = "Flohschnupfen (nein)"),
             gof_omit = "IC|F|RMSE|Log", stars = TRUE) |> 
  style_tt(i = 1:2, background = "#F0E442") |>
  style_tt(i = c(5:6), background = "#E0E0E0") |> 
  group_tt(j = list("Model" = 2:4))
```

Die Confounderanalyse verlangt sehr viel vor und zurück bei der Modellierung und damit auch Modellbildung. Wir müssen uns verschiedene Modelle anschauen und entscheiden, welche Einflussvariable vermutlich einen Einfluss auf unseren Messwert hat oder nicht. Was in der Theorie dann irgendwie immer plausibel scheint, scheitert in der Praxis meistens an zu wenigen Daten. Wenn der potenzielle Confounder nicht als Einflussvariable in den Daten vorhanden ist, dann kann das beste Modell nichts finden. Der Confounder ist ja nicht erhoben worden.

### Korrelation der Kovariaten

Die Einlfussvariablen haben neben der Einheit noch andere Probleme. Teilweise sind diese Probleme nicht ganz so offensichtlich, wie gleich in meinem Beispiel gewählt. Probleme treten auf, wenn die Einflussvariablen untereinander zu stark miteinander korreliert sind. Mehr zur Korrelation erfährst du im [Kapitel zur Korrelation](#sec-lin-reg-corr). Hier wiederhole ich jetzt nicht die Grundlagen. Wenn also Einflussvariablen sehr stark miteinander korrelaiert sind, dann erklären die Variablen mehr oder minder das Gleiche. In der folgenden Abbildung siehst du den Zusammenhang zwischen der Sprungweite und der Anzahl an Haaren auf den Flohbeinen. Wie es so ist, können wir hier natürlich verschiedene Beine oder die mittlere Anzahl betrachten. Vermeintlich glücklicherweise haben aber alle den gleichen Koeffizienten.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 11
#| fig-cap: "Zusammenhang zwischen der Sprungweite und der Anzahl an Haaren an den Flohbeinen. Eine Regressiongrade wurde für das simple lineare Modell ergänzt. **(A)** Mittlere Anzahl an Haaren über beide Beine. **(B)** Anzahl Haare auf dem linken Bein. **(C)** Anzahl Haare auf dem rechten Bein. *[Zum Vergrößern anklicken]*"
#| label: fig-mult-count-leg

p1_corr_leg <- ggplot(flea_model_tbl, aes(x = count_leg, y = jump_length)) +
  theme_modeling() +
  geom_point() +
  stat_poly_line(linewidth = 1,
                 fullrange = TRUE, se = FALSE, color = "#009E73") +
  stat_poly_eq(use_label("eq"), size = 4, vstep = 0.1) +
  labs(x = "Mittlerer Beinhaare",
       y = "Sprungweite in [cm]")

p2_corr_leg <- ggplot(flea_model_tbl, aes(x = count_leg_left, y = jump_length)) +
  theme_modeling() +
  geom_point() +
  stat_poly_line(linewidth = 1,
                 fullrange = TRUE, se = FALSE, color = "#CC79A7") +
  stat_poly_eq(use_label("eq"), size = 4, vstep = 0.1) +
  labs(x = "Beinhaare linkes Bein",
       y = "Sprungweite in [cm]")

p3_corr_leg <- ggplot(flea_model_tbl, aes(x = count_leg_right, y = jump_length)) +
  theme_modeling() +
  geom_point() +
  stat_poly_line(linewidth = 1,
                 fullrange = TRUE, se = FALSE, color = "#0072B2") +
  stat_poly_eq(use_label("eq"), size = 4, vstep = 0.1) +
  labs(x = "Beinhaare rechtes Bein",
       y = "Sprungweite in [cm]")

p1_corr_leg + p2_corr_leg + p3_corr_leg +
  plot_layout(ncol = 3) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Dann können wir uns auch einmal die Korrelation zwischen den drein Kovariaten anschauen. Wie zu erwarten ist die Korrelation maximal mit Eins. Die Sterne zeigen die Signifikanz an. Das Beispiel ist hier konstruiert, aber in biologischen Systemen oder Laborwerten können wir schnell sehr hohe Korrelationen erreichen. Das Gewicht und der BMI ist sehr hoch korreliert. Blutwerte wie Hämoglobin, Eisengehalt und Sauerstoffsättigung können das Gleiche anzeigen.

```{r}
flea_model_tbl |> 
  select(count_leg, count_leg_left, count_leg_right) |> 
  correlation() |> 
  summary(redundant = TRUE)
```

Naheliegend wäre es jetzt ein Modell zu bauen in dem alle drei Kovariaten enthalten sind. Dann müssen wir uns nicht entscheiden welche wir nehmen und erhalten für jede Kovariate eine Information. Wenn du nochmal auf die Abbildung schaust, wir erwarten hier eigentlich eine signifikante Steigung.

```{r}
cov2_fit <- lm(jump_length ~ count_leg + count_leg_left + count_leg_right, data = flea_model_tbl) 
```

Wenn wir nun die Koeffizienten betrachten, dann werden wir schon stutzig. Wir erhalten eine negative Steigung für die mittlere Anzahl und dann für die beiden Beine dann eine positive Steigung, die auch grob nur halb so groß ist. Das ist schon mal nicht so gut.

```{r}
cov2_fit |> 
  coef() |> round(2)
```

Betrachten wir also einmal das Modell in der Zusammenfassung um zu sehen, wie die Koeffizienten und die Residuen aussehen. Die Modelgüte ist akzeptabel. Was aber auffällt ist, dass keine der Kovariaten signifikant ist. Das ist sehr seltsam, wenn wir die Abbildung betrachten. Wir sehen hier die direkte Folge von hoch korrelierter Kovariaten. Wenn diese hoch korreliert sind, dann werden alle nicht signfikant.

```{r}
#| eval: true
cov2_fit |> summary()
```

Dann vergleichen wir einmal alle drei Modelle mit den tollen Funktionen aus dem [R Paket `{modelsummary}`](https://modelsummary.com/vignettes/get_started.html) und dann dem [R Paket `{tinytable}`](https://vincentarelbundock.github.io/tinytable/). Wir bauen also erstmal das simple Modell mit nur der mittleren Beinanzahl und dann ergänzen wir schrittweise die Anzahl der Haare der linken und rechten Beine. Dadurch sehen wir dann einmal den Effekt der Kovariaten, wenn wir diese zu einem Modell hinzunehmen.

```{r}
fit_4 <- lm(jump_length ~ count_leg, data = flea_model_tbl) 
fit_5 <- lm(jump_length ~ count_leg + count_leg_left, data = flea_model_tbl) 
fit_6 <- lm(jump_length ~ count_leg + count_leg_left + count_leg_right, data = flea_model_tbl) 
```

Jetzt können wir alle drei Modell nebeneinander direkt miteinander vergleichen. Wir sehen hier sehr schön, wie der p-Wert der mitttleren Beinanzahl immer weiter anstiegt je mehr korrelierte Kovariaten in das Modell kommen. Spannenderweise bleibt die Modellgüte immer gleich. Wir sehen also das Problem nicht, wenn wir uns zum Beispiel das Bestimmtheitsmaß nur anschauen. Du musst also immer vorab auf die Korrelation schauen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-modelsummary-table-corrr
#| tbl-cap: "Vergleich der Modelle der Sprungweite und der Anzahl an Haaren an den Beinen. Der Interecept wurde aus der Betrachtung entfernt. Mit steigender Anzahl an hoch korrelierten Kovariaten steigen ebenfalls die p-Werte der Koeffizienten."

modelsummary(lst("IV" = fit_4, "V" = fit_5, "VI" = fit_6), 
             statistic = c("p = {p.value}"),
             coef_map = c("count_leg" = "Mittlere Beinhaare",
                          "count_leg_left" = "Linke Beinhaare",
                          "count_leg_right" = "Rechte Beinhaare"),
             gof_omit = "IC|F|RMSE|Log", stars = TRUE) |> 
  style_tt(i = 1:2, background = "#F0E442") |>
  style_tt(i = c(5:6), background = "#E0E0E0") |> 
  group_tt(j = list("Model" = 2:4))
```

### Variance inflation factor (VIF) {#sec-vif}

Wenn wir uns die Korrelation der Einflussvariablen ansschauen, dann schauen wir ja mehr oder minder immer auf paarweise Vergleiche. Wenn wir aber wissen wollen, ob eine Einflussvariable von den anderen Einflussvariablen teilweise oder ganz erklärt wird, dann nutzen wir den *Variance inflation factor* (abk. *VIF*). Hierzu gibt es dann kein deutsches Wort. Wir wird der *Variance inflation factor* definiert? Im Prinzip haben wir es hier mit einem Verwandten des Bestimmtheitsmaß $R^2$ zu tun. Hier erstmal die Formel für die Berechnung des *Variance inflation factors*.

$$
VIF = \cfrac{1}{1- R^2}
$$

mit

-   $VIF$, dem *Variance inflation factor* für die untersuchte Einflussvariable.
-   $R^2$, dem Bestimmtheitsmaß für die Einflussvariable, wenn die Einflussvariable als Messwert $Y$ im Modell verwendet wird.

Bevor wir dann gleich nochmal zu der Berechnung kommen, hier erstmal die Interpretation der VIF-Werte. Die VIF-Werte helfen dir, den Grad der Multikollinearität in deinem Modell zu bewerten. Den die Multikollinearität beschreibt nichts anderes, als das deine Einflussvariablen sich untereinander selber erklären.

-   **VIF = 1:** Es gibt keine Multikollinearität. Alles ist okay und du kannst dein Modell so verwenden wie gedacht.
-   **VIF zwischen 1 und 5:** Es liegt moderate Multikollinearität vor, die in der Regel unproblematisch ist. Dami ignorieren wir solche VIF-Werte und machen ganz normal weiter.
-   **IF \> 5:** Es gibt eine hohe Multikollinearität, die die Koeffizienten unzuverlässig machen kann. Hier sollten Maßnahmen ergriffen werden. Das heißt wir überlegen, ob wir nicht Einflussvariablen aus unserem Modell entfernen um die VIF-Werte zu senken.
-   **VIF \> 10:** Dies deutet auf eine sehr hohe Multikollinearität hin, die dringend korrigiert werden muss. Auch hier müssen wir dann schauen, welche Einflussvariablen wir entfernen wollen.

Wichtig hier nochmal zu wissen, dass du nicht unbedingt die Variable mit dem hohen VIF-Wert rausschmeißen musst. Manachmal hilft es auch andere Variablen zu entfernen und dann gehen die VIF-Werte global runter. Hier kommt es darauf an, welche Einflussvariablen du wirklich im Modell haben willst und welche eher nicht. Das hängt stark von deiner wissenschaftlichen Fragestellung ab.

Wir bauen uns jetzt einmal ein Modell und wollen dann schauen, in wie weit die Vairablen untereinander unabhängig sind. Dafür nehme ich jetzt einmal einen kleineren Datensatz und zwar nur die jugendlichen Flöhe. Das hat den Grunf, dass wir in den Daten mehr Abhänigkeiten haben. Ich habe die Daten so gebaut, dass es eben auch hohe VIF-Werte gibt.

```{r}
juvenile_flea_tbl <- filter(flea_model_tbl, stage == "juvenile")
```

Dann bauen wir unser Modell. Wir nehmen hier mal nur Kovariate mit ins Modell. Faktisch geht der VIF auch mit faktoriellen Einflussvariablen, dann berechnen wir die sogenannten GVIF-Werte. Hier zeige ich dir die Kovariaten, da es üblicher ist sich die Kovariaten eher anzuschauen.

```{r}
juvenile_fit <- lm(jump_length ~ K + Mg + CRP + Hb + BSG + M, 
                   data = juvenile_flea_tbl)
```

Nachdem wir das Modell angepasst haben können wir auf verschiedene Arten den *Variance inflation factor* berechnen. Wenn dich nicht so richtig interessiert woher der *Variance inflation factor* kommt, dann ist das R Paket `{car}` und das R Paket `{performance}` die richtige Wahl. Ich zeige dir dann im letzten Tab nochmal die händische Durchführung in R. Da wird nochmal klarer wie der VIF-Wert aus dem Bestimmtheitsmaß berechnet wird.

::: panel-tabset
## `{car}`

Wenn wir einfach nur die VIF-Werte brauchen, dann können wir die Funktion `vif()` aus dem R Paket `{car}` nutzen. Wir erhalten hier die VIF-Werte ohne Interpretation wiedergegeben. Wir müssen dann selber schauen, welche Werte groß sind.

```{r}
vif(juvenile_fit)
```

Hier hilft dann nochmal selber eine Überprüfung, damit wir nichts übersehen. Insbesondere wenn du viele Einflussvariablen vorliegen hast, dann ist die folgende Abfrage schon hilfreich. Hier kannst du dann gleich ablesen, welche Variablen einen zu hohen VIF-Wert haben.

```{r}
vif(juvenile_fit) > 5
```

Wir würden jetzt einmal schauen, ob wir nicht Magnesium oder den CRP-Wert aus dem Modell nehmen würden. Du kannst das auch mit dem Hb-Wert oder M-Werten machen. Dann gucken wir wie sich die VIF-Werte ändern und arbeiten uns so vor. Die Variable an der wir am meisten interessiert sind, versuchen wir so lange wie möglich im Modell zu belassen.

## `{performance}`

Wenn wir den *Variance inflation factor* berechnen wollen, dann nutzen wir die Funktion `check_model()`. Wir können uns mit der Funcktion `check_model()` aus dem R Paket `{performance}` auch die Unsicherheit mit angeben lassen. In unserem Beispiel hieft dies gerade nicht sehr viel weiter. Wir bleiben bei den geschätzen Werten und ignorieren das Intervall. Das schöne ist eben, dass wir hier auch gleich eine Abbildung mit der Interpretation erhalten. Das macht die Anwendung dann angenehm einfach.

```{r}
#| message: false
#| echo: false
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Graphische Darstellung des *Variance inflation factors* mit der Funktion `check_model()` mit einer Hilfe zur Interpretation der VIF-Werte."
#| label: fig-stat-modeling-vif

check_model(juvenile_fit, check = "vif")
```

## Händisch in R

Und wie machen wir die VIF Berechnung nun händisch? Wir brauchen erstmal die *Variance inflation factor* Formel in R. Die Funktion baue ich dir einmal nach. Diese können wir dann nutzen um aus einem Bestimmtheitsmaß $R^2$ den entsprechenden *Variance inflation factor* für die Einflussvariable zu berechnen.

```{r}
vif_fct <- function(x) 1/(1-x)
```

Der Witz ist jetzt, dass wir die Einflussvariable für den *Variance inflation factor* nun als Messwert in das Modell setzen und die anderen Einflussvariablen so belassen. Der ursprüngliche Messwert kommt dann in der Berechnung des *Variance inflation factor* nicht mehr vor. Wie du in den folgenden Berechnungen siehst, ist immer die Einflussvariable für den VIF-Wert auf der linken Seite der Tilde und fehlt auf der rechnten Seite dann entsprechend. Die berechneten VIF-Werte entsprechen dann den Werten aus der Funktion `vif()` im R Paket `{car}` aus dem ersten Tab.

```{r}
lm(K ~ Mg + CRP + Hb + BSG + M, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("K")
```

```{r}
lm(Mg ~ K + CRP + Hb + BSG + M, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("Mg")
```

```{r}
lm(CRP ~ K + Mg + Hb + BSG + M, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("CRP")
```

```{r}
lm(Hb ~ K + Mg + CRP + BSG + M, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("Hb")
```

```{r}
lm(BSG ~ K + Mg + CRP + Hb + M, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("BSG")
```

```{r}
lm(M ~ K + Mg + CRP + Hb + BSG, data = juvenile_flea_tbl) |> 
  r2() |>
  pluck("R2") |> vif_fct() |> set_names("M")
```
:::

### Vergleich von Modellen {#sec-model-basic-compare}

Im Folgenden wollen wir einmal verschiedene Modelle miteinander Vergleichen und uns statistisch wiedergeben lassen, was das beste Modell ist. Und hier holen wir auch einmal kurz Luft, denn wir entschieden nur was das statistisch beste Modell ist. Es kann sein, dass ein Modell biologisch mehr Sinn macht und nicht auf Platz 1 der statistischen Maßzahlen steht. Das ist vollkommen in Ordnung. Du musst abwägen, was für sich das beste Modell ist.

Wir bauen uns jetzt fünf Modelle von `fit_7` bis `fit_11`. Jedes dieser Modelle hat andere Einflussvariablen aber den gleichen Messwert. Im Weiteren sortieren wir die Modelle von einfach nach komplex. Ich versuche immmer das einfachste Modell mit der niedrigsten Nummer zu benennen. Im Idealfall benennst du die Modellobjekte nach den Modellen, die in en Objekten gespeichert sind. Oft sind die Modelle aber sehr groß und die Objekte der Fits haben dann sehr lange Namen.

```{r}
fit_7 <- lm(jump_length ~ feeding, data = flea_model_tbl)
fit_8 <- lm(jump_length ~ feeding + stage, data = flea_model_tbl)
fit_9 <- lm(jump_length ~ feeding + stage + weight, data = flea_model_tbl)
fit_10 <- lm(jump_length ~ feeding + stage + count_leg, data = flea_model_tbl)
fit_11 <- lm(jump_length ~ stage + weight, data = flea_model_tbl)
```

Als Ergänzung zum Bestimmtheitsmaß $R^2$ wollen wir uns noch das *Akaike information criterion* (abk. $AIC$) anschauen. Du kannst auch das $R^2$ bzw. das $R^2_{adj}$ für die Modellauswahl nehmen. Das $AIC$ ist neuer und auch für komplexere Modelle geeignet. Es gilt hierbei, je kleiner das $AIC$ ist, desto besser ist das $AIC$. Wir wollen also Modelle haben, die ein kleines $AIC$ haben. Wir gehen jetzt nicht auf die Berechnung der $AIC$'s für jedes Modell ein. Wir erhalten nur ein $AIC$ für jedes Modell. Die einzelnen Werte des $AIC$'s sagen *nichts* aus. Ein $AIC$ ist ein mathematisches Konstrukt. Wir können aber verwandte Modelle mit dem $AIC$ untereinander vergleichen. Daher berechnen wir ein $\Delta$ über die $AIC$. Dafür nehmen wir das Modell mit dem niedrigsten $AIC$ und berechnen die jeweiligen Differenzen zu den anderen $i$ Modellen. In unserem Beispiel ist $i$ dann gleich fünf, da wir fünf Modelle haben.

$$
\Delta_i = AIC_i - AIC_{min}
$$

-   wenn $\Delta_i < 2$, gibt es keinen Unterschied zwischen den Modellen. Das $i$-te Modell ist genauso gut wie das Modell mit dem $AIC_{min}$.
-   wenn $2 < \Delta_i < 4$, dann gibt es eine starke Unterstützung für das $i$-te Modell. Das $i$-te Modell ist immer noch ähnlich gut wie das $AIC_{min}$.
-   wenn $4 < \Delta_i < 7$, dann gibt es deutlich weniger Unterstützung für das $i$-te Modell;
-   Modelle mit $\Delta_i > 10$ sind im Vergleich zu dem *besten* $AIC$ Modell nicht zu verwenden.

Nehmen wir ein $AIC_1 = AIC_{min} = 100$ und $AIC_2$ ist $100,7$ an. Dann ist $\Delta_2=0,7<2$, so dass es keinen wesentlichen Unterschied zwischen den Modellen gibt. Wir können uns entscheiden, welches der beiden Modelle wir nehmen. Hier ist dann wichtig, was auch die Biologie sagt oder eben andere Kriterien, wie Kosten und Nutzen. Wenn wir ein $AIC_1 = AIC_{min} = 100000$ und $AIC_2$ ist $100700$ vorliegen haben, dann ist $\Delta_2 = 700 \gg 10$, also gibt es keinen Grund für das $2$-te Modell. Das $2$-te Modell ist substantiell schlechter als das erste Modell. Mehr dazu kannst du unter [Multimodel Inference: Understanding AIC and BIC in Model Selection](https://faculty.washington.edu/skalski/classes/QERM597/papers_xtra/Burnham%20and%20Anderson.pdf) nachlesen.

Wir können das $\Delta_i$ auch in eine Wahrscheinlichkeit umrechnen. Wir können $p_i$ berechnen und damit die relative im Vergleich zu $AIC_{min}$ Wahrscheinlichkeit, dass das $i$-te Modell den AIC minimiert.

$$
p_i = \exp\left(\cfrac{-\Delta_i}{2}\right)
$$

Zum Beispiel entspricht $\Delta_i = 1.5$ einem $p_i$ von $0.47$ (ziemlich hoch) und ein $\Delta_i = 15$ entspricht einem $p_i =0.0005$ (ziemlich niedrig). Im ersten Fall besteht eine Wahrscheinlichkeit von 47%, dass das $i$-te Modell tatsächlich eine bessere Beschreibung ist als das Modell, das $AIC_{min}$ ergibt, und im zweiten Fall beträgt diese Wahrscheinlichkeit nur 0.05%. Wir können so einmal nachrechnen, ob sich eine Entscheidung für ein anderes Modell lohnen würde. Neben dem $AIC$ gibt es auch das Bayesian information criterion ($BIC$). Auch beim $BIC$ gilt, je kleiner das BIC ist, desto besser ist das BIC.

Du siehst schon, es gibt eine Reihe von Möglichkeiten sich mit der Güte oder Qualität eines Modells zu beschäftigen. Wir nutzen die Funktion `model_performance()` um uns die Informationen über die Güte eines Modells wiedergeben zu lassen. Im folgenden Codeblock habe ich mich nur auf das $AIC$ und das $BIC$ konzentriert.

```{r}
model_performance(fit_7) |> 
  as_tibble() |> 
  select(AIC, BIC)
```

Gut soweit. Du kannst jetzt für jedes der Modelle das $AIC$ berechnen und dann dir die Modelle entsprechend ordnen. Wir müssen das aber nicht tun. Wir können uns auch die Funktion `compare_performance()` zu nutze machen. Die Funktion gibt uns die $R^2$-Werte wieder wie auch die $AIC$ sowie die $s^2_{\epsilon}$ als `sigma` wieder. Wir haben also alles zusammen was wir brauchen. Darüber hinaus kann die Funktion auch die Modelle rangieren. Das nutzen wir natürlich gerne.

```{r}
#| message: false
#| warning: false
comp_res <- compare_performance(fit_7, fit_8, fit_9, fit_10, fit_11, rank = TRUE)

comp_res
```

Anhand der Ausgabe der Funktion `compare_performance()` sehen wir, dass unser Modell `fit_10` das beste Modell ist. In der folgenden Abbildung sehen wir die Ausgabe der Funktion `compare_performance()` nochmal visualisiert. Wir können dann die einzelnen Modelle nochmal besser vergleichen. Auch siehst du hier, ob ein Modell in einem Bereich sehr schlecht ist oder aber nur in einem Bereich sehr gut.

```{r}
#| message: false
#| echo: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Graphische Darstellung der Funktion `compare_performance()` Wir sehen hier die einzelnen Gütekriterien in einer Übersicht dargestellt."
#| label: fig-stat-modeling-compare

plot(comp_res)
```

Zum Ende stellt sich die Frage nach dem statistischen Test. Können wir auch statistisch Testen, ob das Modell `fit_10` signifikant unterschiedlich ist? Ja wir können die Funktion `test_vuong()` nutzen um das erste Modell in der Funktion zu den anderen Modellen zu vergleichen. Wenn du mehrere Modelle miteinander vergleichen möchtest, dann muss du die Funktion mehrfach ausführen.

```{r}
test_vuong(fit_10, fit_7, fit_8, fit_9, fit_11)
```

Zum Abschluss dann auch hier nochmal die Zusammenstellung aller fünf Modell in einer Tabelle durch das R Paket `{modelsummary}`. Wir haben dann alles in einer Tabelle und können die Einflussvariablen alle miteinander vergleichen. Wir sehen dann auch wie sich die Koeffizienten ändern, wenn wir eine Einflussvariable mit ins Modell nehmen oder weglassen. Wir sehen auch hier hier, dass das Modell X das beste Modell ist. Für eine bessere Übersicht habe ich einmal den Intercept entfernt.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-modelsummary-table-comp
#| tbl-cap: "Vergleich der Modelle der Sprungweite und verschiedener Einflussvariablen. Der Interecept wurde aus der Betrachtung entfernt. Die unterschiedlichen Koeffizienten der Einflussvariablen können untereinander verglichen werden. Ebenso wird die Modelgüte für jedes Modell im Vergleich gezeigt."

modelsummary(lst("VII" = fit_7, "VIII" = fit_8, "IX" = fit_9,
                 "X" = fit_10, "XI" = fit_11), 
             coef_map = c("intercept" = "(Intercept)",
                          "feedingblood" = "Ernährung (Blut)",
                          "feedingketchup" = "Ernährung (Ketchup)",
                          "stagejuvenile" = "Entwicklung (juvenile)",
                          "weight" = " Gewicht [mg]",
                          "count_leg" = "Anzahl Beinhaare"),
             gof_omit = "F|Log", stars = TRUE) |> 
  style_tt(i = c(1:2, 5:6, 9:10), background = "#E0E0E0") |>  
  group_tt(j = list("Model" = 2:6))
```

## Referenzen {.unnumbered}
