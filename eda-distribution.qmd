# Verteilung von Daten

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

```{r}
#| warning: false
#| echo: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, see, conflicted,
               ggridges)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("summarise", "dplyr")
cbbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

::: column-margin
Wir besuchen gerne die R Shiny App [The distribution zoo](https://ben18785.shinyapps.io/distribution-zoo/) um mehr über die verschiedenen Verteilungen und deren Parameter zu erfahren.
:::

In diesem Kapitel wollen wir uns mit Verteilungen beschäftigen. @dormann2013parametrische liefert eine weitreichende Übersicht über verschiedene Verteilungen. Natürlich ist diese Übersicht auch nicht abschließend. Es gibt eine sehr große Anzahl an Verteilungen, aber wir werden uns nur mit einer kleinen Auswahl beschäftigen. Die folgenden Verteilungen haben eine praktische Verwendung in der Data Science. Wir wollen uns in diesem Kapitel mit folgenden Verteilungen beginnen.

-   der *Normalverteilung*, die Glockenkurve oder auch *Gaussian* im englischen Sprachgebrauch genannt, die kontinuierliche Zahlen repräsentiert.
-   die *Standardnormalverteilung*, als eine spezielle Form der Normalverteilung mit einer Fläche von Eins unter der Kurve.
-   die *t-Verteilung*, eine abgeleitete Verteilung von der Standardnormalverteilung, die ähnliche Eigenschaften wie die Standardnormalverteilung hat.
-   der *Poissonverteilung*, die diskrete Zähldaten repräsentiert.
-   die *Binomialverteilung*, die $0/1$ Zahlen und damit das Eintreten eines Ereignisses repräsentiert. Bekannt aus den Würfel und Münzwurfbeispielen.
-   die *Uniformverteilung*, eine Sockelverteilung, die über einen Zahlenrum nur einen Wert annimmt.

Wir wollen uns jetzt die verschiedenen Verteilungen einmal in der Anwendung anschauen. Dabei lassen wir viel Mathematik recht und links liegen. Du kannst bei @dormann2013parametrische mehr zu dem Thema statistische Verteilungen anlesen. Dort gibt es auch nochmal mehr Informationen zu den einzelnen Eigenschaften, die eine Verteilung noch so haben kann. Wir konzentrieren uns hier auf die Lageparameter und die Streuung der Verteilungen.

::: column-margin
![](images/angel_01.png){fig-align="center" width="50%"}

Wir halten den mathematischen Teil zu den Verteilungen sehr kurz oder überspringen den Teil ganz. Wir brauchen die Idee der Verteilungen, weil wir später den Methoden sagen müssen wie unser Outcome $y$ verteilt ist. Nur dann können wir die Daten richtig auswerten.
:::

In diesem Kapitel geht es erstmal um das Grundverständnis, das Daten einer Verteilung folgen. Oder noch konkreter, dass unser Outcome $y$ einer Verteilung folgt. Wir müssen später unseren Alogrithmen sagen, welcher Verteilung $y$ entspringt, sonst können wir keine *korrekte* Analyse unser Daten rechnen.

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
pacman::p_load(tidyverse, magrittr, see, readxl)
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten für Verteilungen

Damit wir uns auch eine Verteilung anschauen können bruachen wir *viele* Beobachtungen. Wir haben das ja schon bei den Histogrammen gesehen, wenn wir ein aussagekräftiges Histogramm erstellen wollen, dann brauchen wir mehr als zwanzig Beobachtungen. Daher nehmen wir für dieses Kapitel einmal den Gummibärchendatensatz und schauen uns dort die Variablen `gender`, `height`, `count_bears` und `count_color` einmal genauer an. Wie immer nutzen wir die Funktion `select()` um die Spalten zu selektieren. Abschließend verwandeln wir das Geschlecht `gender` und das `module` noch in einen Faktor.

```{r}
#| message: false

gummi_tbl <- read_excel("data/gummibears.xlsx")  %>%
  select(year, module, gender, height, count_bears, count_color,
         most_liked) %>% 
  mutate(gender = as_factor(gender),
         module = as_factor(module))
```

Wir erhalten das Objekt `gummi_tbl` mit dem Datensatz in @tbl-data-dist-gummi nochmal dargestellt. Wir brauchen nicht alle Spalten aus dem ursprünglichen Datensatz und somit ist die Tabelle etwas übersichtlicher.

```{r}
#| message: false
#| echo: false
#| tbl-cap: Auszug aus den selektierten Daten zu den Gummibärchendaten.
#| label: tbl-data-dist-gummi

gummi_print_tbl <- gummi_tbl %>% 
  mutate(gender = as.character(gender),
         module = as.character(module))
rbind(head(gummi_print_tbl),
      rep("...", times = ncol(gummi_print_tbl)),
      tail(gummi_print_tbl)) %>% 
  kable(align = "c", "pipe")
```

## Die Normalverteilung {#sec-normal}

[Wir sprechen in der Statistik auch von Verteilungs*familien*. Daher schreiben wir in R auch `family = gaussian`, wenn wir sagen wollen, dass unsere Daten einer Normalverteilung entstammen.]{.aside}

Wenn wir von de Normalverteilung sprechen, dann schreiben wir ein $\mathcal{N}$ Symbol - also ein großes N mit Serifen. Die Normalverteilung sieht aus wie eine Glocke, deshalb wird die Normalverteilung auch Glockenkurve genannt. Im englischen Sprachgebrauch und auch in R nutzen wir dagegen die Bezeichnung nach dem "Entdecker" der Normalverteilung, Carl Friedrich Gauß (1777 - 1985). Wir nennen daher die Normalverteilung auch Gaussian-Verteilung.

[*Parameter* sind Zahlen, die eine Verteilungskurve beschreiben.]{.aside}

Eine Normalverteilung wird ruch zwei Verteilungs*parameter* definiert. Eine Verteilung hat Parameter. Parameter sind die Eigenschaften einer Verteilung, die notwendig sind um eine Verteilung vollständig zu beschreiben. Im Falle der Normalverteilung brauchen wir zum einen den Mittelwert $\bar{y}$, der den höchsten Punkt unserer Glockenkurve beschreibt. Zum anderen brauchen wir auch die Standardabweichung $s^2_y$, die die Ausbreitung oder Breite der Glockenkurve bestimmt. Wir beschreiben eine Normalverteilung für eine Stichprobe mit $\bar{y}$ und $s^2_y$ wie folgt.

$$
\mathcal{N}(\bar{y}, s^2_y)
$$

Oder mit mehr Details in folgender Form. Wir können hier Verallgemeinern und schreiben in der Grundgesamtheit mit $\mu = \bar{y}$ und $\sigma^2 = s^2_y$. Das heißt, wenn wir unendlich viele Beobachtungen vorliegen hätten, dann wüssetn wir auch den wahren Mittelwert $\mu$ und die wahre Varianz $\sigma^2$ der Daten.

$$
f(y \mid\mu,\sigma^2)=\cfrac{1}{\sqrt{2\pi\sigma^2}} e^{-\cfrac{(y-\mu)^2}{2\sigma^2}}\quad -\infty<y<\infty
$$

Im Falle der Normalverteilung brauchen wir einen Paramter für den höchsten Punkt der Kurve, sowie einen Parameter für die Ausbreitung, also wie weit geht die Kurve nach links und nach rechts. Je nach $\bar{y}$ und $s^2_y$ können wir verschiedenste Normalverteilungen vorliegen haben. Eine Sammlung von Verteilungen nennen wir auch Familie (eng. *family*).

[Wir haben Varianzhomogenität vorliegen, wenn $s^2_{1} = s^2_{2} = s^2_{3}$ sind. Wir haben Varianzheterogenität vorliegen, wenn $s^2_{1} \neq s^2_{2} \neq s^2_{3}$ sind.]{.aside}

In @fig-normal-02 sehen wir verschiedene Normalverteilungen mit unterschiedlichen Mittelwerten. In @fig-normal-02-1 sehen wir eine Varianzhomogenität vorliegen, da die Varianzen in allen drei Normalverteilungen gleich sind. Wir können auch schreiben, dass $s^2_{1} = s^2_{2} = s^2_{3} = 2$. In @fig-normal-02-2 haben wir Varianzheterogenität vorliegen, da die Varianzen der Normalverteilungen ungleich sind. Wir können hier dann schreiben, dass $s^2_{1} = 6 \neq s^2_{2} = 1 \neq s^2_{3} = 3$ sind. Häufig gehen statistische Verfahren davon aus, dass wir Varianzhomogenität über die Gruppen und daher auch die Normalverteilungen vorliegen haben. Konkret, wenn wir die Sprungweiten in\[cm\] von Hunde- und Katzenflöhen mit einander vergleichen wollen, dann gehen wir erstmal davon aus, dass die Mittelwerte verschieden sind, aber die Varianzen gleich sind.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-normal-02
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramm verschiedener Normalverteilungen mit unterschiedlichen Mittelwerten."
#| fig-subcap: 
#|   - "Drei Normalverteilungen mit Varianzhomogenität."
#|   - "Drei Normalverteilungen unter Varianzheterogenität."
#| layout-nrow: 1
#| column: page


set.seed(20220789)
norm_tbl <- tibble(n1 = rnorm(10000, 10, 2),
                   n2 = rnorm(10000, 20, 2),
                   n3 = rnorm(10000, 0, 2)) %>% 
  gather()

ggplot(data = norm_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(position = position_identity(), alpha = 0.75, color = "black") +
  labs(x = "", y = "Anzahl") +
  xlim(-15, 30) +
  theme(legend.position = "none") +
  scale_fill_okabeito() +
  annotate("text", 0, 3200, label = expression(paste("N(0,2)")),
           color = cbbPalette[4]) +
  annotate("text", 10, 3200, label = expression(paste("N(10,2)")),
           color = cbbPalette[2]) +
  annotate("text", 20, 3200, label = expression(paste("N(20,2)")),
           color = cbbPalette[3]) 

set.seed(20220789)
norm_tbl <- tibble(n1 = rnorm(10000, 10, 1),
                   n2 = rnorm(10000, 20, 3),
                   n3 = rnorm(10000, 0, 6)) %>% 
  gather()

ggplot(data = norm_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(binwidth = 1, position = position_identity(), alpha = 0.75, color = "black") +
  labs(x = "", y = "Anzahl") +
  xlim(-15, 30) +
  theme(legend.position = "none") +
  scale_fill_okabeito() +
  annotate("text", 0, 900, label = expression(paste("N(0,6)")),
           color = cbbPalette[4]) +
  annotate("text", 10, 4100, label = expression(paste("N(10,1)")),
           color = cbbPalette[2]) +
  annotate("text", 20, 1500, label = expression(paste("N(20,3)")),
           color = cbbPalette[3]) 

```

[In einer Normalverteilung liegen 68% der Werte innerhalb $\bar{y}\pm 1 \cdot s_y$ und 95% der Werte innerhalb $\bar{y}\pm 2 \cdot s_y$]{.aside}

Wenn wir eine Normalverteilung vorliegen haben, dann liegen 68% der Werte plus/minus einer Standardabweichung vom Mittelwert. Ebenso liegen 95% der Werte plus/minus zwei Standabweichungen vom Mittelwert. Über 99% der Werte befinden sich innerhalb von drei Standardabweichungen vom Mittelwert. Diese Eigenschaft einer Normalverteilung können wir später noch nutzen um abzuschätzen, ob wir einen relevanten Gruppenunterschied vorliegen haben oder aber ob unsere Daten *unnatürlich* breit streuen.

[Wir nutzen das Wort *approximativ* wenn wir sagen wollen, dass ein Outcome näherungsweise normalverteilt ist.]{.aside}

Schauen wir uns die Normalverteilung einmal am Beispiel unserer Gummibärchendaten und der Körpergröße der Studierenden an. Wir färben das Histogramm nach dem Geschlecht ein. In @fig-normal-01 sehen wir das Ergebnis einmal als Histogramm und einmal als Densityplot dargestellt. Wir können annehmen, dass die Größe *approximativ* normalverteilt ist.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-normal-01
#| fig-cap: "Darstellung der Körpergröße in [cm] für die Geschlechter getrennt."
#| fig-subcap: 
#|   - "Histogramm."
#|   - "Densityplot."
#| layout-nrow: 1
#| column: page

gummi_1_tbl <- gummi_tbl %>% 
  select(height, gender) %>% 
  na.omit()

ggplot(data = gummi_1_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "Anzahl", fill = "Geschlecht") +
  scale_x_continuous(breaks = seq(150, 210, by = 5)) +
  scale_fill_okabeito() 

ggplot(data = gummi_1_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 210, by = 5), limits = c(145, 210)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

```

Wir können die Funktion `rnorm()` nutzen um uns zufällige Zahlen aus der Normalverteilung ziehen zu lassen. Dazu müssen wir mit `n =` spezifizieren wie viele Beobachtungen wir wollen und den Mittelwert `mean =` und die gewünschte Standardabweichung mit `sd =` angeben. Im Folgenden einmal ein Beispiel für die Nutzung der Funktion `rnorm()` mit zehn Werten.

```{r}
rnorm(n = 10, mean = 5, sd = 2) %>% round(2)
```

Du kannst ja mal den Mittelwert und die Standardabweichung der zehn Zahlen ausrechnen. Da wir es hier mit einer Stichprobe mit zehn Beobachtungen zu tun haben, wird der Mittelwert $\bar{y}$ und die Standardabweichung $s_y$ sich von den vorher definierten Mittelwert $\mu_y = 5$ und Standardabweichung $\sigma_y = 2$ der Grundgesamtheit unterscheiden.

Wir können auch aus unseren Gummibärchendaten für die Körpergröße in \[cm\] jeweils den Mittelwert und die Standardabweichung getrennt für die Geschlechter berechnen und dann die theoretische Normalverteilung zeichenen. In @fig-normal-03-2 und @fig-normal-03-4 sehen wir die Verteilung der theoretischen Werte, wenn wir die Mittelwerte und die Standardabweichung aus den Verteilungen in @fig-normal-03-1 schätzen. Spannderweise bildet sich den *zufällig* gezogenen Daten auch eine leichte Schulter bei der Verteilung der Körpergrößen. Auch $n = `r nrow(gummi_1_tbl)`$ vollständige Beobachtungen bedeuten nicht, dass wir eine perfekte Normalverteilung erhalten.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-normal-03
#| fig-cap: "Darstellung der Körpergröße in [cm] für die Geschlechter getrennt. Auf der linken Seite die beobachteten Werte und auf der rechten Seite die theoretischen Werte. Einmal dargestellt als Histogramm und einmal als Densityplot."
#| fig-subcap: 
#|   - "Verteilung der beobachteten Werte."
#|   - "Verteilung der theoretischen Werte."
#| layout-nrow: 2
#| column: page

stat_tbl <- gummi_tbl %>% 
  select(gender, height) %>% 
  na.omit() %>% 
  group_by(gender) %>% 
  summarise(mean = mean(height),
            sd = sd(height),
            n = n())

gummi_theo_tbl <- tibble(height = c(with(filter(stat_tbl, gender == "m"), rnorm(n, mean, sd)),
                                    with(filter(stat_tbl, gender == "w"), rnorm(n, mean, sd))),
                         gender = rep(c("m", "w"), c(stat_tbl$n[1], stat_tbl$n[2])))


ggplot(data = gummi_1_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "Anzahl", fill = "Geschlecht") +
  scale_x_continuous(breaks = seq(150, 215, by = 5)) +
  scale_fill_okabeito() +
  scale_y_continuous(breaks = seq(0, 25, 5), limits = c(0, 25))

ggplot(data = gummi_theo_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(150, 215, by = 5)) +
  scale_y_continuous(breaks = seq(0, 25, 5), limits = c(0, 25))

ggplot(data = gummi_1_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 210, by = 5), limits = c(145, 210)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

ggplot(data = gummi_theo_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 210, by = 5), limits = c(145, 210)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

```

## Die Standardnormalverteilung

Es gibt viele Normalverteilungen. Eiegntlich gibt es unednlich viele Normalverteilunge, da wir für die Parameter Mittelwert $\bar{y}$ und die Standardabweichung $s_y$ beliebige Zahlen einsetzen können. Aber es gibt eine besondere Normalverteilung, so dass diese Verteilung einen eigenen Namen hat. Wir sprechen von der Standardnormalverteilung, wenn der Mittelwert gleich Null ist und die Standardabweichung gleich Eins. Du siehst hier nochmal die Standardnormalverteilung ausgeschrieben.

$$
\mathcal{N}(0, 1)
$$

Folgende Eigenschaften sind der Standardnormalverteilung gegeben. Die Standardnormalverteilung hat eine Fläche von $A = 1$ unter der Kurve. Darüber hinaus liegen 95% der Werte zwischen $\approx -2$ und $\approx 2$. Die einzelnen Werte einer Standardnormalverteilung nennen wir $z$-Werte. Wenn wir eine beliebige Normalverteilung in eine Standardnormalverteilung überführen wollen so machen wir die Umwandlung mit der $z$-Transformation. Und jetzt fahren wir wieder in die Doppeldeutigkeit in R.

$Pr(X \leq x)$ mit `lower.tail = TRUE`

$Pr(X > x)$ mit `lower.tail = FALSE`

```{r}
pnorm(q = 1.96, mean = 0, sd = 1, lower.tail = FALSE) %>% round(3)
```

```{r}
qnorm(p = c(0.025, 0.05), mean = 0, sd = 1, lower.tail = FALSE) %>% round(3)
```

```{r}
qnorm(p = 0.05, mean = 0, sd = 1, lower.tail = TRUE) %>% round(3)
```

![Darstellung von dem Zusammenhang von `pnorm(p = 1.96)` und `qnorm(q = 0.025)`. Mit der Option `lower.tail` bestimmen wir auf welche Seite der Verteilung wir sein wollen.](images/distribution-t.png){#fig-dist-t-01 fig-align="center" width="100%"}

## Die t-Verteilung {#sec-t-dist}

$Pr(X \leq x)$ mit `lower.tail = TRUE`

$Pr(X > x)$ mit `lower.tail = FALSE`

```{r}
pt(q = 2.571, df = 5, lower.tail = FALSE) %>% round(3)
```

```{r}
qt(p = c(0.025), df = c(5, 10, 20, 100), lower.tail = FALSE) %>% round(3)
```

## Die Poissonverteilung {#sec-poisson}

Eine weitere wichtige Verteilung ist die Poissonverteilung. Die Poissonverteilung ist eine diskrete Verteilung. Daher kommen nur ganze Zahlen vor. Damit bildet die Poissonverteilung die Zähldaten ab. Wenn wir also etwas Zählen, dann ist diese Variable mit den gezählten Ergebnissen poissonverteilt. Im Folgenden sehen wir die Poissonverteilung einmal dargestellt.

$$
\mathcal{Pois}(\lambda)
$$

Oder mit mehr Details in folgender Form.

$$
P_\lambda (k) = \frac{\lambda^k}{k!}\, \mathrm{e}^{-\lambda}
$$

Die Poisson-Verteilung gibt dann die Wahrscheinlichkeit einer bestimmten Ereignisanzahl $k$ im Einzelfall an, wenn die mittlere Ereignisrate $\lambda$ bekannt ist. Im Gegensatz zur Normalverteilung hat die Poissonverteilung nur einen Parameter. Den Lageparameter $\lambda$ ausgedrückt durch den griechischen Buchstaben Lambda. Eine Poissonverteilung mit $\mathcal{Pois}(4)$ hat den höchsten Punkt bei vier. Nun hat die Poissonverteilung hat mehrere Besonderheiten. Da die Poissonverteilung keinen Streuungsparameter hat, steigt mit dem $\lambda$ auch die Streuung. Daher haben Poissonverteilungen mit einem großen $\lambda$ auch eine große Streuung. ie Ausbreitung der Kurve ist eine Funktion von $\lambda$ und steigt mit $\lambda$ an. Du kannst diesen Zusammenhang in @fig-pois-00 beobachten.

Darüber hinaus kann eine Poissonverteilung nicht negativ werden. Es kann keine kleinere Zahl als die Null geben. Durch die diskreten Zahlen haben wir auch immer mal Lücken zwischen den Balken der Poissonverteilung. Das passiert besonders, wenn wir eine kleine Anzahl an Beobachtungen haben. Abschließend konvergiert die Poissonverteilung bei großen $\lambda$ hin zu einer Normalverteilung.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-pois-00
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramm verschiedener Poissonverteilungen."

set.seed(20220789)
pois_tbl <- tibble(lambda1 = rpois(1000, 6),
              lambda2 = rpois(1000, 10),
              lambda3 = rpois(1000, 1)) %>% 
  gather()

ggplot(data = pois_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(binwidth = 1, position = position_dodge(0.95), color = "black") +
  labs(x = "", y = "Anzahl") +
  theme(legend.position = "none") +
  scale_x_continuous(breaks = 0:25, limits = c(0,NA)) +
  scale_fill_okabeito() +
  annotate("text", 4, 250, label = expression(paste("Pois(", lambda, " = 1)")),
           color = cbbPalette[4]) +
  annotate("text", 6, 180, label = expression(paste("Pois(", lambda, " = 6)")),
           color = cbbPalette[2]) +
  annotate("text", 10, 150, label = expression(paste("Pois(", lambda, " = 10)")),
           color = cbbPalette[3]) 
```

Schauen wir uns nun einmal die Poissonverteilung im Beispiel an. In @fig-pois-01 sehen wir die Histogramme der Anzahl an Gummibärchen in einer Tüte und die Anzahl an Farben in einer Tüte. Da wir es hier mit Zähldaten zu tun haben, könnte es sich um eine Poissonverteilung handeln. Wie müssen uns nun die Frage stellen, ob die Gummibärchen in einer Tüte und die Anzahl an Farben in einer Tüte *wirklich* eine zufällige Realistierung sind. Daher eine zufällige Stichprobe der Grundgesamtheit. Wir können diese Annahme überprüfen in dem wir die theoretischen Werte für die beiden Poissonverteilung mit $\mathcal{Pois}(10)$ und $\mathcal{Pois}(5)$ genieren.

```{r}
#| message: false
#| echo: false
#| warning: false
#| label: fig-pois-01
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramme der Anzahl an Gummibärchen und die Anzahl an Farben in einer Tüte. Es gibt nicht mehr als sechs Farben."
#| fig-subcap: 
#|   - "Anzahl an Bärchen"
#|   - "Anzahl an Farben"
#| layout-nrow: 1
#| column: page

gummi_2_tbl <- gummi_tbl %>% 
  select(count_bears, count_color) %>% 
  na.omit()

ggplot(data = gummi_2_tbl, aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[2]) +
  scale_x_continuous(breaks = seq(5, 15, by = 1), limits = c(5, 15)) +
  labs(x = "", y = "Anzahl") 

ggplot(data = gummi_2_tbl, aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[3]) +
  #scale_x_continuous(breaks = seq(1, 6, by = 1), limits = c(1, 6)) +
  labs(x = "", y = "Anzahl") 
```

Wir können die Funktion `rpois()` nutzen um uns zufällige Zahlen aus der Poissonverteilung ziehen zu lassen. Dazu müssen wir mit `n =` spezifizieren wie viele Beobachtungen wir wollen und den Mittelwert `lambda =` angeben. Im Folgenden einmal ein Beispiel für die Nutzung der Funktion `rpois()` mit zehn Werten.

```{r}
rpois(n = 10, lambda = 5)
```

[Es gibt neben der Poissonverteilung auch die negative Binomialverteilung sowie die Quasi-Poissonverteilung, die es erlauben einen Streuungsparameter für die Poissonverteilung zu schätzen.]{.aside}

Wir können nun auch aus unseren Gummibärchendaten für die Anzahl an Bärchen in einer Tüte sowie die Anzahl an Farben in einer Tüte die theoretische Poissonverteilung berechnen. In @fig-pois-03 sehen wir die Verteilung der beobachteten Werte für Anzahl an Bärchen in einer Tüte sowie die Anzahl an Farben in einer Tüte und deren theoretischen Verteilung nach dem geschätzen $\lambda = 10$ und $\lambda = 5$. Wir sehen ganz klar, dass die beide Variablen *keine* Zufallsrealisierung sind. Zum einen haben wir das auch nicht erwartet, es gibt nicht mehr als sechs Farben und zum anderen ist zu vermuten, dass Haribo technisch in den Auswahlprozess eingreift. Wir haben auf jeden Fall eine sehr viel kleinere Streuung als bei einer *klassischen* Poissonverteilung anzunehmen wäre.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-pois-03
#| fig-cap: "Darstellung Anzahl an Bärchen und Anzahl an Farben. Es gibt nicht mehr als sechs Farben. Auf der linken Seite die beobachteten Werte und auf der rechten Seite die theoretischen Werte."
#| fig-subcap: 
#|   - "Verteilung der beobachteten Anzahl an Bärchen."
#|   - "Verteilung der theoretischen Anzahl an Bärchen."
#|   - "Verteilung der beobachteten Anzahl an Farben."
#|   - "Verteilung der theoretischen Anzahl an Farben."
#| layout-nrow: 2
#| column: page


stat_color_tbl <- gummi_2_tbl %>% 
  summarise(mean = mean(count_color),
            n = n())

stat_bears_tbl <- gummi_2_tbl %>% 
  summarise(mean = mean(count_bears),
            n = n())

height_max <- 220

ggplot(data = gummi_2_tbl, aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[5]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(1, 20, by = 1), limits = c(1, 20)) +
  scale_y_continuous(breaks = seq(0, height_max, 10), limits = c(0, height_max))

set.seed(20220831)
ggplot(data = tibble(count_bears = rpois(stat_bears_tbl$n, stat_bears_tbl$mean)), 
       aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[6]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(1, 20, by = 1), limits = c(1, 20)) +
  scale_y_continuous(breaks = seq(0, height_max, 10), limits = c(0, height_max))

ggplot(data = gummi_2_tbl, aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[7]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(0, 11, by = 1), limits = c(0, 11)) +
  scale_y_continuous(breaks = seq(0, height_max, 10), limits = c(0, height_max))

set.seed(20220831)
ggplot(data = tibble(count_color = rpois(stat_color_tbl$n, stat_color_tbl$mean)), 
       aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[8]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(0, 11, by = 1), limits = c(0, 11)) +
  scale_y_continuous(breaks = seq(0, height_max, 10), limits = c(0, height_max))

```

In @fig-gummi-years-count schauen wir uns nochmal an in wie weit sich die Füllung der Tütchen im Laufe der Jahre entwickelt hat. Die Daten werden ja schon seit 2018 erhoben. Wir schauen uns daher die Densityplot einmal aufgetrennt für die Jahre 2018 bis heute an. Das Jahr 2020 fehlt, da bedingt durch die Coronapandemie keine Präsenslehre stattfand. Wir sehen, dass sich die Verteilung anscheinend in dem Jahr 2022 langsam nach links zu weniger Bärchen in einer Tüte bewegt. Wir bleiben gespannt auf den weiteren Trend.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-gummi-years-count
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Densityplot der Anzahl an Bärchen in einer Tüte aufgetrennt nach den Jahren der Erhebung. Das Jahr 2020 fehlt bedingt durch die Coronapandemie."

gummi_3_tbl <- gummi_tbl %>% 
  select(count_bears, year) %>% 
  na.omit()

ggplot(data = gummi_3_tbl, aes(x = count_bears, y = fct_rev(as_factor(year)),
                             fill = fct_rev(as_factor(year)))) +
  theme_bw() +
  stat_density_ridges() +
  scale_x_continuous(breaks = seq(5, 15, by = 1), limits = c(5, 15)) +
  labs(x = "Anzahl an Bärchen in einer Tüte", y = "Jahr") +
  theme(legend.position = "none") +
  geom_vline(xintercept = c(6, 7, 8, 9, 10, 11, 12, 13, 14), linetype = 2, alpha = 0.5) +
  scale_fill_okabeito()

```

In @fig-gummi-mostliked betrachten wir die Verteilung der am meisten gemochten Gummibärchen aufgeteilt nach dem angegebenen Geschlecht im Vergeich zu den Gummibärchen in den Tütchen. Wir sehen, dass Haribo die Tütchen sehr gleichmäßig verteilt und auf die Geschmäcker keinerlei Rücksicht nimmt. Entweder weiß Haribo nichts von den Vorlieben seiner Käufer:innen oder aber es ist dann doch zu viel Aufwand die Produktion anzupassen.

```{r}
#| message: false
#| echo: false
#| warning: false
#| label: fig-gummi-mostliked
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| fig-cap: "Histogramme der am liebsten gemochten Gummibärchchen im Vergleich zum Inhalt der Tütchen."
#| fig-subcap: 
#|   - "Anzahl am liebsten gemochten Gummibärchen aufgeteilt nach Geschlecht."
#|   - "Anzahl der Gummibärchen pro Tüte nach Farbe."
#| layout-nrow: 1
#| column: page

gummi_4_tbl <- gummi_tbl %>% 
  select(most_liked, gender) %>% 
  mutate(most_liked = factor(most_liked, 
                             levels = c("darkred", "green", "white", "lightred",
                                        "yellow", "orange", "none"))) %>% 
  na.omit()


ggplot(data = gummi_4_tbl, aes(x = most_liked)) +
  theme_bw() +
  geom_bar(aes(fill = gender), position = "dodge") +
  #scale_x_continuous(breaks = seq(5, 15, by = 1), limits = c(5, 15)) +
  labs(x = "", y = "Anzahl", fill = "Geschlecht") +
  #theme(legend.position = "none") +
  scale_fill_okabeito()


gummi_color_tbl <- read_excel("data/gummibears.xlsx") %>% 
  select(darkred:white) %>% 
  gather(color, count)

count_bag_tbl <- rep(gummi_color_tbl$color, gummi_color_tbl$count) %>% 
  as_tibble() %>% 
  mutate(value = factor(value, 
                        levels = c("darkred", "green", "white", "lightred",
                                   "yellow", "orange", "none")))

ggplot(count_bag_tbl, aes(value)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", 
           fill = c("brown3", "darkolivegreen3", "white", "coral1", "yellow", "orange")) +
  labs(x = "", y = "Anzahl") 


```

## Die Binominalverteilung {#sec-binom}

$$
B(k\mid p,n)=
\begin{cases}
  \binom nk p^k (1-p)^{n-k} &\text{falls} \quad k\in\left\{0,1,\dots,n\right\}\\
  0            & \text{sonst.}
  \end{cases}
$$

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-gummi-binom
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Beispiel für eine Binomialverteilung anhand des Geschlechts. Die fehlenden Angaben wurden entfernt."


ggplot(na.omit(gummi_tbl), aes(gender, fill = gender)) +
  theme_bw() +
  geom_bar() +
  labs(x = "", y = "Anzahl") +
  theme(legend.position = "none") +
  scale_fill_okabeito()

```

## Die Uniformverteilung {#sec-uniform}

$$
f(y)=
\begin{cases}
  \cfrac 1{b-a} & a \le y \le b\\
  0            & \text{sonst.}
\end{cases}
$$

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-gummi-uniform
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Beispiel für eine uniforme Verteilung anhand der Anzahl der Gummibärchen pro Tüte nach Farbe"


ggplot(count_bag_tbl, aes(value)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", 
           fill = c("brown3", "darkolivegreen3", "white", "coral1", "yellow", "orange")) +
  labs(x = "", y = "Anzahl") 

```

## Weitere Verteilungen

::: column-margin
Wir besuchen gerne die R Shiny App [The distribution zoo](https://ben18785.shinyapps.io/distribution-zoo/) um mehr über die verschiedenen Verteilungen und deren Parameter zu erfahren.
:::

Weitere Beispiele finden sich unter [Basic Probability Distributions in R](https://rstudio-pubs-static.s3.amazonaws.com/100906_8e3a32dd11c14b839468db756cee7400.html). Im Weiteren liefert @dormann2013parametrische eine gute Übersicht über verschiedene Verteilungen und deren Repräsentation in R. Das ist nur eine Auswahl an möglichen Verteilungen. Bitte hier nicht ins *rabbit hole* der Verteilungen gehen. Wir benötigen in unserer täglichen Arbeit nur einen kleinen Teil der Verteilungen. Es reicht, wenn du eine Vorstellungen der Verteilungen in diesem Kapitel hat.

## Referenzen {.unnumbered}
