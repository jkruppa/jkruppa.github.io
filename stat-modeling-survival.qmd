```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, openxlsx)
```

# Überlebenszeitanalysen {#sec-survival}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

In diesem Kapitel wollen wir uns nochmal mit der Zeit beschäftigen. Wir haben hier aber keine zeitlichen Messwiederholungen an dem gleichen Subjekt, Tier oder Pflanze vorliegen sondern wir schauen uns an, wie lange es dauert bis ein Ereignis eintritt. Deshalb nennen wir diese Analysen algemein Ereigniszeitanalysen. Häufig schauen wir uns aber die zeit an, die es braucht, bis das Ereignis "tot" für eine Beobachtung eintritt. Daher heißt das Kapitel auch Überlebenszeitanalysen (eng. *survival analysis*).

Überlebenszeitanalysen sind in den Humanwissenschaften und inbesondere in der Onkologie *das* Thema schlechthin. Wir beantworten hier die Fragen nach *3 Monatsmortalität* und wollen wissen, wie viele patienten nach einer Behandlung mit einem Krebsmedikament nach drei Monaten noch leben. Du kanst dir vorstellen, dass es hier eine Menge an Annahmen und Modellen gibt. Wir wollen uns hier in dem Kapitel die Grundlagen anschauen. Da vieles in der Wissenschaft meist in englischer Sprache abläuft, kann ich hier sehr den das Buch von @david2012survival empfehlen. Insbesondere die Einführungskapitel sind sehr gut geschrieben. Diese Detailtiefe wie bei @david2012survival werde ich in diesem Abschnitt nicht erreichen. In den Agrarwissenschaften ist alles ein wenig anders als in den Humanwissenschaften.

Wie bereits erwähnt, konzentriert sich die Überlebensanalyse auf die erwartete Zeitdauer bis zum Auftreten eines Ereignisses von Interesse. Das Ereignis von Interesse ist dann meist ein Rückfall (eng. *relapse*) oder eben tot (eng. *death*). Es kann jedoch sein, dass das Ereignis bei einigen Personen innerhalb des Untersuchungszeitraums nicht beobachtet wird, was zu sogenannten zensierten Beobachtungen führt. Die Zensierung kann auf folgende Weise erfolgen:

-   Ein Patient hat das interessierende Ereignis, wie Rückfall oder Tod, innerhalb des Studienzeitraums (noch) nicht erlebt;
-   ein Patient wird während des Studienzeitraums nicht weiter beobachtet;
-   bei einem Patienten tritt ein anderes Ereignis ein, das eine weitere Beobachtung unmöglich macht.

Diese Art der Zensierung, die als rechte Zensierung (eng. *right censoring*) bezeichnet wird, wird in der Überlebensanalyse in diesem Kapitel behandelt.

::: column-margin
Wir immer gibt es eine gute Auswahl an aktuellen Tutorien [Survival Analysis Basics](http://www.sthda.com/english/wiki/survival-analysis-basics), die hier auch aufgegrifen werden. Ein umfangreicheres Tutorium in R findet sich unter [Survival Analysis in R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html).
:::

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, conflicted, broom,
               survminer, survival, parameters,
               gtsummary, janitor)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

Insgesamt schauen wir uns in diesem Kapitel dann drei Datensätze an. Einmal einen Datensatz der sehr simple ist und nochmal erklärt wie die Datenstruktur in R aussehen muss. Dafür nutzen wir das Überleben von Dodos. Dann einen Datensatz, der etwas komplizierter ist. Wir betrachten hier das Überleben von Fruchtfliegen. Den Abschluss bildet ein Datensatz zu einer klinischen Studie von Lungenkrebs. Der Datensatz wird viel in Beispielen genutzt, so dass ich den Datensatz auch hier nochmal vorstellen möchte.

### Überleben von Dodos

Wir schauen uns hier das Überleben von Dodos mit oder ohne Schnabelstutzen an. Wir schauen dann an jedem Lebenstag, wie viele Dodos verstorben sind. Da wir es hier mit sehr schnell wachsenden Dodos zu tun haben, ist der Datensatz nicht so lang was die Zeit angeht. Wir beobachten nur die ersten 55 Lebenstage (eng. *days of life*, abk. *dol*) bevor die Dodos dann geschlachtet werden. In der @tbl-surv-dodo-1 sehen wir die rohen Daten, die wir in der Form nicht analysieren können. Wir müssen uns hier etwas strecken, damit das Format der Daten für die Überlebenszeitanalyse passt.

```{r}
#| message: false
#| echo: false

n_dodo <- 250

set.seed(20220929)
dodo_raw_tbl <- bind_rows(tibble(dol = 1:55,
                            death = c(rep(0, 5), rpois(50, 3.5)),
                            count = cumsum(c(n_dodo, -1*death[-1])),
                            trt = "none"),
                     tibble(dol = 1:55,
                            death = c(rep(0, 5), rpois(50, 1.75)),
                            count = cumsum(c(n_dodo, -1*death[-1])),
                            trt = "clipped")) %>% 
  select(trt, dol, count, death)

write.xlsx(dodo_raw_tbl, "data/dodo_raw.xlsx", rowNames = FALSE)
```

```{r}
#| message: false
#| echo: false
#| tbl-cap: Rohe Datentabelle mit den jeweiligen Lebenstagen (abk. *dol*) und der Anzahl an lebenden sowie toten Dodos an den entsprechenden Tagen.
#| label: tbl-surv-dodo-1

rbind(head(dodo_raw_tbl, n = 6),
      rep("...", times = ncol(dodo_raw_tbl)),
      tail(dodo_raw_tbl, n = 6)) %>% 
  kable(align = "c", "pipe")
```

Unsere Daten zu den Dodos beinhalten die folgenden Spalten mit den entsprechenden Bedeutungen.

-   **trt**, die Behandlung der Schnäbel mit `none` und `clipped`
-   **dol**, der *day of life* also der Lebenstag der Dodos
-   **count**, die Anzahl an lebenden Dodos an dem entprechenden *day of life*
-   **death**, die Anzahl an tot aufgefundenen Dodos an dem entpsrechenden *day of life*

Wir haben somit $n = `r 2*n_dodo`$ beobachtete Dodos mit jeweils `r n_dodo` für jede der beiden Schnabelbehandlungen. Jetzt brauchen wir aber wie immer einen Datansatz in dem jede Zeile einen beobachteten Dodo entspricht. In der @tbl-surv-dodo-2-example sehen wir welche Art von Tabelle wir bauen müssen.

| dodo_id | trt     | dol | death |
|---------|---------|-----|-------|
| 1       | none    | 6   | 1     |
| 2       | none    | 6   | 1     |
| 3       | none    | 7   | 1     |
| ...     | ...     | ... | ...   |
| 249     | none    | 55  | 0     |
| 250     | none    | 55  | 0     |
| 251     | clipped | 6   | 1     |
| ...     | ...     | ... | ...   |
| 500     | clipped | 55  | 0     |

: Beispielhafte Datentabelle für die Analyse der Dododaten. Jede Zeile entspricht einem beobachteten Dodo und dem entsprechenden Informationen zur Lebensdauer und Schnabelbehandlung. {#tbl-surv-dodo-2-example}

Fagen wir also mit der Information an, die wir haben. Wir wissen wie viele Dodos jeweils zu einem bestimmten Lebenstag gestorben sind. Daher können wir anhand der Spalte `death` die Anzahl an Zeilen entsprechend vervielfältigen. Sind an einem Lebenstag drei Dodos gestorben, dann brauchen wir dreimal eine Zeile mit der Information des Lebenstages und das an diesem Tag ein Dodo gestorben ist. Wir nutzen dazu die Funktion `uncount()`. Dann erschaffen wir noch eine Spalte `death` in der einfach immer eine `1` steht, da ja an diesem Lebenstag ein Dodo verstorben ist.

```{r}
death_tbl <- dodo_raw_tbl %>% 
  uncount(death) %>% 
  mutate(death = c(rep(1, length(.$dol))))
```

Im nächsten Schritt müssen wir die lebenden Dodos *separat für jede Behandlung* ergänzen. Daher spalten wir uns die Daten in eine Liste auf und ergänzen dann die Informationen zu den fehlenden, lebenden Dodos. Alle lebenden Dodos haben die maximale Lebenszeit, sind nicht gestorben und damit bleibt die Anzahl auch konstant.

```{r}
alive_tbl <- death_tbl %>% 
  split(.$trt) %>% 
  map(~tibble(dol = max(.x$dol),
              death = rep(0, last(.x$count)),
              count = last(.x$count))) %>% 
  bind_rows(.id = "trt")
```

Wenn wir die Informationen zu toten und den noch lebenden Dodos gebaut haben, können wir uns dann einen finalen Datensatz zusammenkleben.

```{r}
dodo_tbl <- bind_rows(death_tbl, alive_tbl)
```

In der @tbl-surv-dodo-2 sehen wir den finalen Dododatensatz, den wir uns aus den Informationen zusammengebaut haben. Wir haben hier einmal die Struktur eines Überlebenszeitdatensatz gelernt und das wir manchmal uns ganz schön strecken müssen um die Daten dann auch gut umzubauen. Wir werden am Ende nur die Informationen in der Spalte `dol`, `death` und `trt` nutzen.

```{r}
#| message: false
#| echo: false
#| tbl-cap: Finaler Dododatensatz für die Überlebenszeitanalysen.
#| label: tbl-surv-dodo-2

rbind(head(dodo_tbl, n = 6),
      rep("...", times = ncol(dodo_tbl)),
      tail(dodo_tbl, n = 6)) %>% 
  kable(align = "c", "pipe")
```

### Überleben von Fruchtfliegen

Im folgenden Beispiel in @tbl-surv-2 beobachten wir Fruchtfliegen bis fast alle Insekten verstorben sind. Das ist natürlich das andere Extrem zu den Dododatensatz. Wir testen hier ein Insektizid und am Ende haben wir dann keine lebenden Fruchtfliegen mehr. Das würdest du mit Dodos oder Schweinen nicht machen, denn so lange möchtest du die Tiere ja auch nicht beobachten, bis alle gestorben sind. Bei Fruchtfliegen dauert es eben nicht so lange bis alle Fliegen verstorben sind.

```{r}
#| message: false
#| echo: false

set.seed(20220929)
fruitfly_tbl <- tibble(times_raw = round(c(rpois(50, 10), rpois(50, 14))),
                       status = rbinom(100, 1, 0.8),
                       trt = factor(gl(2, 50), labels = c("fruitflyEx", "control")),
                       sex = sample(factor(gl(2, 50), labels = c("male", "female"))),
                       time = ifelse(sex == "male", times_raw - 2, times_raw + 5),
                       weight = round(c(rnorm(50, 11, 3), rnorm(50, 19, 3)), 2),
                       weight_bin = ifelse(weight <= 15, "low", "high")) %>% 
  select(-times_raw) %>% 
  select(trt, time, status, everything()) %>% 
  arrange(trt, time)

write.xlsx(fruitfly_tbl, "data/fruitfly.xlsx", rowNames = FALSE)
```

```{r}
#| message: false
#| echo: false
#| tbl-cap: Fruchtfliegendatensatz mit verschiedenen Covariaten zu der Behandlung, der Zeit und dem Status der Fruchtfliegen.
#| label: tbl-surv-2

fruitfly_raw_tbl <- fruitfly_tbl %>% 
  mutate(trt = as.character(trt),
         sex = as.character(sex))

rbind(head(fruitfly_raw_tbl, n = 4),
      rep("...", times = ncol(fruitfly_raw_tbl)),
      tail(fruitfly_raw_tbl, n = 4)) %>% 
  kable(align = "c", "pipe")
```

Unsere Daten zu den Fruchtfliegen beinhalten die folgenden Spalten mit den entsprechenden Bedeutungen.

-   **trt**, als die Behandlung mit den beiden Leveln `fruitflyEx` und `control`
-   **time**, den Zeitpunkt des Todes der entsprechenden Fruchfliege
-   **status**, den Status der Fruchtfliege zu dem Zeitpunkt `time`. Hier meist `1` und damit tot, aber ein paar Fruchtfliegen sind bei der Überprüfung entkommen und haben dann eine `0`.
-   **sex**, das Geschlecht der entsprechenden Fruchtfliege
-   **weight**, das Gewicht der entsprechenden Fruchtfliege in $\mu g$.
-   **weight_bin** das Gewicht der entsprechenden Fruchtfliege aufgeteilt in zwei Gruppen nach dem Cutpoint von $15 \mu g$.

### Überleben von Lungenkrebs

Zum Abschluss möchte ich noch den Datensatz `lung` in der @tbl-surv-3 aus dem R Paket `survival` vorstellen. Das hat vor allem den Grund, dass es sich hier um einen klassischen Datensatz zur Überlebenszeitanalyse handelt und ich auch dieses Teilgebiet einmal mit abdecken möchte. Wie schon weiter oben gesagt, Überlebenszeitanalysen kommen eher in dem Humanbereich vor. Darüber hinaus bedienen sich fast alle anderen Tutorien im Internet diesem Datensatz, so dass du dann einfacher die englischen Texte nachvollziehen kannst.

```{r}
#| message: false
#| echo: false
#| tbl-cap: "Der Datensatz `lung` über eine Beobachtungsstudiue Studie zu Lungenkrebs."
#| label: tbl-surv-3

rbind(head(as_tibble(lung), n = 4),
      rep("...", times = ncol(lung)),
      tail(as_tibble(lung), n = 4)) %>% 
  kable(align = "c", "pipe")
```

-   **inst** Institution code
-   **time** Survival time in days
-   **status** censoring status 1=censored, 2=dead
-   **age** Age in years
-   **sex** Male=1 Female=2
-   **ph.ecog** ECOG performance score (0=good 5=dead)
-   **ph.karno** Karnofsky performance score (bad=0-good=100) rated by physician
-   **pat.karno** Karnofsky performance score as rated by patient
-   **meal.cal** Calories consumed at meals
-   **wt.loss** Weight loss in last six months

Trotz seiner Prominenz hat der Datensatz einen Fehler. Wir wollen den Status nicht auf 1/2 kodiert haben sondern auf 0/1. Ebenso wollen wir die Spalte `inst` nicht, da wir die Informationen nicht brauchen. Dann sind noch die Namen der Spalten hässlich, so dass wir da die Funktion `clean_names()` nutzen um einmal aufzuräumen.

```{r}
lung_tbl <- lung %>% 
  as_tibble() %>% 
  mutate(status = recode(status, `1` = 0, `2` = 1)) %>% 
  clean_names() %>% 
  select(-inst)
```

## Die `Surv()` Funktion

```{r}
#| echo: true
#| message: false
#| warning: false
#| eval: false

Surv(time, death)
```

Für den Dododatensatz haben wir dann folgende Zusammenhänge.

-   `dol` in den Daten `dodo_tbl` ist gleich `time` in dem `Surv()` Objekt
-   `death` in den Daten `dodo_tbl` ist gleich `death` in dem `Surv()` Objekt

Bei dem Fruchfliegendatensatz sieht die Sachlage dann so aus.

-   `time` in den Daten `fruitfly_tbl` ist gleich `time` in dem `Surv()` Objekt
-   `status` in den Daten `fruitfly_tbl` ist gleich `death` in dem `Surv()` Objekt

Für den Lungenkrebsdatensatz haben wir dann folgende Zuordnung.

-   `time` in den Daten `lung_tbl` ist gleich `time` in dem `Surv()` Objekt
-   `status` in den Daten `lung_tbl` ist gleich `death` in dem `Surv()` Objekt

## Visualisierung über Kaplan Meier Kurven

Wir können nur kategoriale Variablen in einer Kaplan Meier Kurve darstellen.

### Dodos

```{r}
trt_fit <- survfit(Surv(dol, death) ~ trt, data = dodo_tbl)
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-surv-1
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "test."
ggsurvplot(trt_fit, data = dodo_tbl, risk.table = TRUE,
           surv.median.line = "hv",
           ggtheme = theme_light(),
           palette = cbbPalette[2:8])
```

### Fruchtfliegen

```{r}
trt_fit <- survfit(Surv(time, status) ~ trt, data = fruitfly_tbl)
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-surv-2
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "test."

ggsurvplot(trt_fit, data = fruitfly_tbl, risk.table = TRUE,
           surv.median.line = "hv",
           ggtheme = theme_light(),
           palette = cbbPalette[2:8])
```

```{r}
weight_fit <- survfit(Surv(time, status) ~ weight_bin, data = fruitfly_tbl)
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-surv-3
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "test."

ggsurvplot(weight_fit, data = fruitfly_tbl, risk.table = TRUE,
           surv.median.line = "hv",
           ggtheme = theme_light(),
           palette = cbbPalette[2:8])
```

### Lungenkrebs

```{r}
null_fit <- survfit(Surv(time, status) ~ 1, data = lung_tbl)
```

```{r}
null_fit %>% 
  summary(times = 365.25)
```

```{r}
null_fit
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-surv-4
#| fig-align: center
#| fig-height: 6
#| fig-width: 5
#| fig-cap: "test."

ggsurvplot(null_fit, data = lung_tbl, risk.table = TRUE,
           surv.median.line = "hv",
           ggtheme = theme_light(),
           palette = cbbPalette[2:8])
```

```{r}
lung_fit <- survfit(Surv(time, status) ~ ph_ecog, data = lung_tbl)
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-surv-5
#| fig-align: center
#| fig-height: 6
#| fig-width: 5
#| fig-cap: "test."

ggsurvplot(lung_fit, data = lung_tbl, risk.table = TRUE,
           surv.median.line = "hv",
           ggtheme = theme_light(),
           palette = cbbPalette[2:8])
```

```{r}
survdiff(Surv(time, status) ~ ph_ecog, data = lung_tbl)
```

## Cox Proportional-Hazards Modell

::: column-margin
Auch im Fall des Cox Proportional-Hazards Modells kann ich hier nur eine Übersicht geben. Es findet sich natürlich auch ein Tutorium zum [Cox Proportional-Hazards Model Tools](http://www.sthda.com/english/wiki/cox-proportional-hazards-model)
:::

```{r}
#| message: false

coxph(Surv(time, status) ~ trt + sex + weight, data = fruitfly_tbl) %>% 
  model_parameters()
```

```{r}
#| message: false

coxph(Surv(time, status) ~ trt + sex + weight_bin, data = fruitfly_tbl) %>% 
  model_parameters()
```

## Random Forests Modell

Im @sec-class-tree beschreiben wir auch die Random Forest Methode zur Klassifikation. Mit Klassifikation meine ich, dass wir versuchen einer Beobachtung eine Ereignisklasse zuzuordnen. Im Kontext der Ereigniszeitanalyse bietet sich natürlich dann auch an einen maschinellen Lernalgorithmus mit der Aufgabe zu betrauen das Überleben einer Beobachtung zu schätzen.

https://rviews.rstudio.com/2017/09/25/survival-analysis-with-r/

## Referenzen {.unnumbered}
