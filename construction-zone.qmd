```{r echo = FALSE}
#| message: false
#| warning: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc, performance, parameters,
               latex2exp, see, patchwork, mfp, multcomp, emmeans, janitor, effectsize,
               broom, ggmosaic, tinytable, 
               conflicted)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::filter)
cb_pal <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
            "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
cbbPalette <- cb_pal
```

# Baustelle {#sec-construction}

*Letzte Änderung am `r format(fs::file_info("construction-zone.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="100%"}

## Bessere Schriftart? {.unnumbered}

[Adding Custom Fonts to ggplot in R](https://gradientdescending.com/adding-custom-fonts-to-ggplot-in-r/)

[Aesthetic specifications](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)

Die Sache mit der Schriftart in `{ggplot}`.

```{r}
library(ggrepel)
```

[Getting started with `{ggrepel}`](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html) [{`ggtext`}: Improved text rendering support for ggplot2](https://wilkelab.org/ggtext/)

```{r}
update_geom_defaults("label", 
                     list(family = "IBM Plex Sans Condensed"))
update_geom_defaults(ggtext::GeomRichText, 
                     list(family = "IBM Plex Sans Condensed"))
update_geom_defaults("label_repel", 
                     list(family = "IBM Plex Sans Condensed"))
```

```{r}
ggplot(tibble(x = 1:3, y = 1:3), aes(x,y)) +
  theme_minimal(base_family = "IBM Plex Sans Condensed") +
  geom_point() +
  labs(x = "Hallo", y = "Mehr zesz")
```

## `{gganimate}`

[Datanovia](https://www.datanovia.com/en/blog/gganimate-how-to-create-plots-with-beautiful-animation-in-r/)

[Cheat sheet `{gganimate}`](https://rstudio.github.io/cheatsheets/gganimate.pdf)

## SQL als `{dbplyr}`?

[Das R Paket `{dbplyr}`](https://dbplyr.tidyverse.org/) [Database Queries With R](https://solutions.posit.co/connections/db/getting-started/database-queries/)

## S-values

Jetzt kommt mal was Neues in dem Sinne, dass wir hier mal eine neue statistische Maßzahl einführen, die es erst seit 2020 mit ursprünglichen Arbeit von @rafi2020semantic mit dem Titel [Semantic and cognitive tools to aid statistical science: replace confidence and significance by compatibility and surprise](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-020-01105-9) gibt. Wir führen hier den S-Wert (eng. *S-value*) oder auch Überrasschungswert (eng. *surprisal value*) ein. Zu dem S-Wert hat @rothman2021rothman in der Veröffentlichung [Rothman Responds to “Surprise!”](https://academic.oup.com/aje/article/190/2/194/5869592?login=false) nochmal einen eigenen Kommentar abgegeben. Es haben sich dann weitere Arbeiten angeschossen. Unter Anderem von @cole2021surprise und der Veröffentlichung [Surprise!](https://academic.oup.com/aje/article/190/2/191/5869593?login=false) sowie der Arbeit von @shafer2021testing und der entsprechenden Veröffentlichung [Testing by Betting: A Strategy for Statistical and Scientific Communication](https://academic.oup.com/jrsssa/article/184/2/407/7056412?login=false#396831406). Darüber hinaus gibt es auch noch von @mansournia2022p die Veröffentlichung [P-value, compatibility, and S-value](https://www.sciencedirect.com/science/article/pii/S2590113322000153#bi0005). Alle drei gemeinsam arbeiten das Problem des p-Wertes und deren Interpretierbarkeit ab. Am Ende möchte ich hier auch nicht die Kritik am S-Wert auslassen. In dem Blogpost [‘S-values’, ‘p-values’ and conceptualising statistics](https://corplingstats.wordpress.com/2020/11/02/s-values/) wird nochmal auf die Probleme des S-Wertes eingegangen. Auch wird hier nochmal sehr viel Hintergrund zum statistsichen Testen gegeben, was jetzt nicht jeder bruacht um den S-Wert zu interpretieren.

Kommen wir erstmal zur mathematischen Beschreibung des $S$-Wertes. Dabei ist der S-Wert eine logarithmische Transformation des p-Wertes. Das klingt jetzt erstmal komplizierter als es ist. Wir berechnen den S-Wert wie folgt.

$$
\mbox{S-value} = -\log_2(\mbox{p-value})
$$

mit

-   $p-value$, dem berechnteten p-Wert aus einem statistsichen Test oder Modell
-   $-\log_2$, dem negativen binären Logarithmus

Damit können wir jeden p-Wert in einen S-Wert übersetzen indem wir einfach den p-Wert transformieren. Warum sollten wir das tun? Da der p-Wert eine bedingte Wahrscheinlichkeit ist, haben wir häufig Probleme den p-Wert intuitiv zu interpretieren. Hier kann dann der S-Wert helfen, der eben durch die Transformation keine Wahrscheinlichkeit mehr ist.

Eigenschaften des $S$-Wertes

:   -   Der $S$-Wert ist *keine* Wahrscheinlichkeit und liegt damit *nicht* im Intervall $[0,1]$.
    -   Der $S$-Wert hat eine intuitive Interpretation, die auf der Beobachtung aller Köpfwürfe bei einem fairen Münzwurf beruht.
    -   Der $S$-Wert beschreibt damit eine Anzahl oder Bits an Informationen.
    -   Der $S$-Werte liefern widerlegende Informationen gegen die Nullhypothese.

Beginnen wir also eimal damit den S-Wert im Sinne des fairen Münzwurf zu interpretieren. Dabei gelten folgende Hypothesen für unsere Überlegung.

$$
\begin{aligned}
H_0 &= \mbox{Die Münze ist fair, es gilt}\; Pr(Kopf) = 0.5\\
H_A &= \mbox{Die Münze ist unfair, es gilt}\; Pr(Kopf) \neq 0.5
\end{aligned}
$$

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-theo-s-value-coin
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"

library(emojifont)

ggplot(tibble(x = 1:4, y = 1:4), aes(x,y)) +
  theme_void() +
  geom_emoji("slightly_smiling_face", x = 2.5, y = 4, color = "black", size = 20) +
  geom_emoji("slightly_smiling_face", x = c(2,3), y = 3, color = "black", size = 20) +
  geom_emoji("slightly_smiling_face", x = c(1.5, 2.5, 3.5), y = 2, color = "black", size = 20) +
  geom_emoji("slightly_smiling_face", x = 1:4, y = 1, color = "black", size = 20) +
  annotate("text", x = 5.5, y = 4:1, 
           label = c(expression(frac(1, 2)~"="~0.5),
                     expression(frac(1, 2) %.% frac(1, 2)~"="~0.25),
                     expression(frac(1, 2) %.% frac(1, 2) %.% frac(1, 2)~"="~0.125),
                     expression(frac(1, 2) %.% frac(1, 2) %.% frac(1, 2) %.% frac(1, 2)~"="~0.0625))) +
  annotate("text", x = 0.1, y = 4:1, label = c("S-value = 1", "S-value = 2", 
                                                "S-value = 3", "S-value = 4"), 
           fontface = 2, size = 4) +
  scale_x_continuous(limits = c(-0.1, 6)) +
  scale_y_continuous(limits = c(0.5, 4.5)) +
  labs(title = "Der S-Wert und der Münzwurf", 
       subtitle = "S-Wert und Wahrscheinlichkeit Kopf nacheinander zu werfen") +
  theme(plot.title = element_text(size = 17),
        plot.subtitle = element_text(size = 12, face = "italic")) 

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-t-p-s
#| tbl-cap: "foo."

tibble(t = c(1, 1.96, 2, 3, 4),
       p = pt(t, Inf, lower.tail = FALSE) * 2,
       s = -log2(p)) |> 
  mutate(p = round(p, 4),
         s = round(s)) |> 
  set_names(c("Teststatistik $T_D$", "p-Wert", "S-Wert")) |> 
  tt(width = 1, align = "c", theme = "striped")
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-theo-s-value
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 7
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"


s_tbl <- tibble(t = sort(c(seq(0, 4, by = 0.1), 1.96)),
                p = pt(t, Inf, lower.tail = FALSE)*2,
                s = -log2(p),
                s_y = s/(max(s))) |> 
  mutate_if(is.numeric, round, 4) |> 
  filter(t != 2.0 & t != 1.9) |> 
  pivot_longer(cols = c("p", "s_y"),
               values_to = "values",
               names_to = "grp") |> 
  mutate(grp = factor(grp, labels = c("p-value", "S-value")))

ggplot(s_tbl, aes(t, values, color = grp)) +
  theme_minimal() +
  geom_hline(yintercept = 0.05, color = "#CC79A7", linetype = 1) +
  geom_hline(yintercept = 0.3099, color = "#0072B2", linetype = 1) +
  geom_vline(xintercept = 1.96, color = "gray70", linetype = 1, size = 1) +
  annotate("rect", xmin = 1.96, xmax = 4, ymin = 0, ymax = 0.05, fill="#E69F00", alpha = 0.15) +
  annotate("rect", xmin = 1.96, xmax = 4, ymin = 0.3099, ymax = 1, fill="#0072B2", alpha = 0.1) +
  geom_point() +
  geom_line() +
  scale_y_continuous(sec.axis = sec_axis(name = "S-value", ~ . * 11.47,
                                         breaks = c(0.3099, 0.5, 0.75, 1) * 11.47,
                                         labels = round(c(0.3099, 0.5, 0.75, 1) * 11.47)),
                     breaks = c(0.05, 0.25, 0.5, 0.75, 1),
                     labels = c("5%", "", "", "", "")) +
  scale_x_continuous(breaks = c(0, 1, 1.96, 3, 4)) +
  annotate("text", x = c(1, 3), y = 0.9, label = c("Nicht signifikant", "Signifikant"),
           size = 5, fontface = 2) +
  annotate("text", x = c(1.25, 3.25), y = 0.5, label = c("p-values", "S-values"),
           size = 4.5, fontface = 3) +
  geom_curve(x = 1.25, y = 0.47, xend = 1, yend = 0.35, linewidth = 0.25,
             arrow = arrow(length = unit(0.02, "npc"), type = "closed"),
             curvature = -0.5, color = "gray50") +
  geom_curve(x = 3.25, y = 0.53, xend = 3.4, yend = 0.72, linewidth = 0.25,
             arrow = arrow(length = unit(0.02, "npc"), type = "closed"),
             curvature = 0.5, color = "gray50") +
  scale_color_okabeito() +
  labs(x = expression(Teststatistik~T[D]),
       y = "p-value", color = "", title = "Die Teststatistik, der p-Wert und der S-Wert",
       subtitle = "Wie änderen sich p-Wert und S-Wert in Abhängigkeit von der Teststatistik?") +
  theme(legend.text = element_text(size = 14),
        legend.title = element_text(size = 14, face = 2),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.x = element_text(size = 14),        
        plot.title = element_text(size = 17),
        plot.subtitle = element_text(size = 12, face = "italic"),
        plot.caption = element_text(size = 12),
        legend.position = "none",
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank()) 
```

In dem R Paket `{marginaleffects}` sind die S-Werte mit in der Ausgabe von Funktionen implementiert. Sonst müssen wir noch die S-Werte aus den p-Werten händisch selber berechnen, was aber auch nicht so das Problem ist.

```{r}
tibble(p = c(0.05, 2.3e-3, 0.23, 0.01),
       s = -log2(p))
```
