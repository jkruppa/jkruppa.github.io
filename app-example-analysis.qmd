```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, openxlsx)
```

# Beispielhafte Auswertungen {#sec-beispiel-auswertung}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, readxl, 
               broom, multcomp, emmeans, 
               conflicted, effectsize, report,
               see, metR)

## resolve some conflicts with same function naming
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Isoplethendiagramm für Norddeutschland

https://geocompr.robinlovelace.net/index.html

https://www.dwd-shop.de/index.php/default/kostenfreie-informationen.html

https://www.dwd.de/DE/leistungen/klimadatendeutschland/beschreibung_tagesmonatswerte.html

https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html#buehneTop

```{r}
#| message: false
#| echo: true
#| warning: false

weather_tbl <- read_table("data/day_values_osnabrueck.txt") %>% 
  mutate(JJJJMMDD = as.Date(as.character(JJJJMMDD), "%Y%m%d"),
         day = as.numeric(format(JJJJMMDD, "%d")), 
         month = as.numeric(format(JJJJMMDD, "%m")), 
         year = as.numeric(format(JJJJMMDD, "%Y"))) %>% 
  select(month, day, TG, TN, TM, TX) %>% 
  na.omit() %>% 
  gather(temp, grad, TG:TX) %>% 
  mutate(temp = as_factor(temp))

```

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-weather
#| fig-align: center
#| fig-height: 10
#| fig-width: 10
#| fig-cap: "Densityplot der Verteilungen vor und nach der Imputation."
#| column: page

ggplot(weather_tbl, aes(month, day, z = grad)) +
  theme_minimal() +
  geom_contour_filled(bins = 13) +
  geom_contour(binwidth = 2, color = "black") +
  facet_wrap(~ temp, ncol = 2) + 
  scale_fill_brewer(palette = "Spectral", direction = -1) +
  scale_x_continuous(breaks = 1:12) +
  geom_vline(xintercept = 1:12, alpha = 0.9, linetype = 2)

```

## Analyse von Anzahlen

In dieser sehr simplen Analyse haben wir zwei Gruppen vorliegen. Die Gruppe 1 ist hat zwei Level oder Behandlungen abgekürzt mit I und II. Die Gruppe 2 hat insgesamt vier Level oder eben Behandlungen, die wir mit A, B, C und D bezeichnen. Wir haben jetzt für die jeweiligen Kombinationen auf dem Feld etwas *gezählt*. Wir haben also für jede dieser Kombinationen nur eine Zahl. Es ergbit sich somit die folgende Matrix an Zahlen.

```{r}
rel_mat <- matrix(c(45, 14, 4, 0,
                    25, 32, 5, 1), nrow = 2, byrow = TRUE,
                  dimnames = list(c("I", "II"), c("A", "B", "C", "D")))
rel_mat
```

Nun können wir den $\mathcal{X}^2$-Test nutzen, um zu testen, ob die Zahlen in der Matrix bzw. auf unseren Feld gelcihverteilt sind. Die Nullhypothese lautet, dass es keinen Zusammenhang zwischen der Gruppe 1 und der Gruppe 2 auf dem Feld gibt. Die Zahlen sind also rein zufällig in dieser Anordnung.

```{r}
#| warning: false
chisq.test(rel_mat)
```

Wir erhalten einen sehr kleinen $p$-Wert mit $0.003$. Wir können daher die Nullhypothese ablehnen, da der $p$-Wert kleiner ist als das Signifikanzniveau $\alpha$ mit 5%. Wir haben ein signifikantes Ergebnis. Wir können von einen Zusamenhang zwischen den beiden Gruppen ausgehen.

Mit Cramers V können wir auch noch die Effektstärke für einen $\mathcal{X}^2$-Test berechnen.

```{r}
cramers_v(rel_mat) 
```

Der Effekt ist mit $0.33$ nicht besonders stark. Du kannst Cramers V wie die Korrelation interpretieren. Ein V von 0 bedeutet keinen Zusammenhang und ein V von 1 einen maximalen Zusammenhang. Wir wollen uns die Daten dann nochmal in einer Abbidlung anschauen. Dafür müssen wir die Matrix erstmal in einen Datensatz umwandeln und die Gruppen zu Faktoren machen.

```{r}
plot_tbl <- rel_mat %>% 
  as_tibble(rownames = "group1") %>% 
  gather(A:D, key = "group2", value = "value") %>% 
  mutate(group1 = as_factor(group1),
         group2 = as_factor(group2))
```

In @fig-app-count-1 sehen wir die Matrix der Zähldaten für die beiden Gruppen nochmal visualisiert. Beim betrachten fällt auf, dass die beiden Level C und D kaum Zähldaten enthalten. Hier wäre zu überlegen die beiden Level aus der Analyse herauszunehmen und einen klassischen $\mathcal{X}^2$-Test auf einer 2x2 Kreuztabelle zu rechnen.

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: Barplot der Zähldaten aus der Matrix. 
#| label: fig-app-count-1

ggplot(plot_tbl, aes(x = group2, y = value, fill = group1)) +
  theme_bw() +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(x = "Gruppe 2", y = "Anzahl", fill = "Gruppe 1") +
  scale_fill_okabeito() 
```

## Auswertung von Gewichten

```{r}
#| echo: false
data_tbl <- expand_grid(trt = 1:3, 
                        block = 1:3,
                        rep = 1:4) %>% 
  mutate(rsp = 10 + 2 * trt + block + rnorm(n(), 0, 2),
         trt = factor(trt, labels = c("low", "mid", "high")),
         block = factor(block, labels = c("I", "II", "III")))
```

```{r}
#| echo: false
data_tbl %>% 
  mutate(rsp = round(rsp, 2)) %>% 
  kable(align = "c", "pipe")
```

### Explorative Datenanalyse (EDA)

```{r}
ggplot(data_tbl, aes(trt, rsp, color = block)) +
  geom_boxplot()
```

```{r}
#| message: false

stat_tbl <- data_tbl %>% 
  group_by(trt, block) %>% 
  summarise(mean = mean(rsp),
            sd = sd(rsp),
            se = sd/sqrt(n()))

ggplot(stat_tbl, aes(x = trt, y = mean, fill = block)) + 
    geom_bar(position = position_dodge(), stat = "identity") +
    geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),
                  width = 0.2,
                  position = position_dodge(.9))
```

### Lineares Modell

```{r}
fit_1 <- lm(rsp ~ trt + block, data = data_tbl)

```

### ANOVA

```{r}
fit_1 %>% anova
```

### Gruppenvergleich mit dem `multcomp` Paket

https://broom.tidymodels.org/reference/tidy.glht.html

```{r}

fit_1 %>% 
  glht(linfct = mcp(trt = "Tukey")) %>% 
  tidy %>% 
  select(contrast, estimate, adj.p.value) %>% 
  mutate(across(where(is.numeric), round, 4))



```

### Gruppenvergleich mit der `emmeans` Paket

https://broom.tidymodels.org/reference/tidy.emmGrid.html

```{r}
fit_1 %>% 
  emmeans("trt") %>% 
  contrast(method = "pairwise") %>% 
  tidy %>% 
  select(contrast, estimate, adj.p.value) %>% 
  mutate(across(where(is.numeric), round, 4))

```

## Auswertung von Boniturnoten

```{r}
#| echo: false 

data_tbl <- tibble(block = 1:5,
                   A = c(2,3,4,3,2),
                   B = c(7,9,8,9,7),
                   C = c(6,5,4,7,4),
                   D = c(2,4,1,2,3),
                   E = c(4,5,3,7,6)) %>%
  gather(key = "variety", value = "rating", A:E) %>% 
  mutate(variety = as_factor(variety),
         block = factor(block, labels = c("I", "II", "III", "IV", "V"))) %>% 
 select(variety, block, rating)


data_tbl <- tibble(block = rep(1:3, each = 5),
                   A = c(2,3,3,4,1,3,2,2,4,4,2,2,3,1,2),
                   B = c(8,9,8,9,7,7,7,8,8,7,8,9,7,9,8),
                   C = c(6,5,5,6,4,4,5,3,6,4,7,6,4,6,4),
                   D = c(2,4,1,2,2,2,4,4,1,3,3,4,2,1,3),
                   E = c(4,4,2,7,5,4,3,4,7,7,5,5,4,6,6)) %>%
  gather(key = "variety", value = "rating", A:E) %>% 
  mutate(variety = as_factor(variety),
         block = factor(block, labels = c("I", "II", "III"))) %>% 
  select(variety, block, rating) %>% 
  arrange(variety, block)  

#data_tbl <- tibble(A = sample(1:9, 18, replace = TRUE, 
#                              prob = c(0, 0, 0, 0, 0.1, 0.2, 0.4, 0.2, 0.1)),
 #                  B = sample(1:9, 18, replace = TRUE, 
  #                            prob = c(0, 0, 0.1, 0.2, 0.4, 0.2, 0.1, 0, 0)),
   #                C = sample(1:9, 18, replace = TRUE, 
    #                          prob = c(0, 0, 0, 0.1, 0.2, 0.4, 0.2, 0.1, 0)),
     #              D = sample(1:9, 18, replace = TRUE, 
      #                        prob = c(0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.3))) %>% 
  #gather(key = "trt", value = "rating") %>% 
  #mutate(trt = as_factor(trt), 
   #      block = rep(gl(3, 6), 4),
    #     block = factor(block, labels = c("I", "II", "III"))) %>% 
#  select(trt, block, rating)

```

```{r}
#| echo: false
data_tbl %>% 
  kable(align = "c", "pipe")
```

### Explorative Datenanalyse (EDA)

```{r}
#| message: false

ggplot(data_tbl, aes(variety, rating, color = block)) +
  geom_boxplot() +
  geom_dotplot(aes(fill = block), binaxis = "y", stackdir='center', 
               position=position_dodge(0.8))  

```

```{r}
#| message: false

ggplot(data_tbl, aes(variety, rating, fill = block)) +
  geom_dotplot(binaxis = "y", stackdir='center', 
               position=position_dodge(0.8)) +
  stat_summary(fun = median, fun.min = median, fun.max = median,
               geom = "crossbar", width = 0.5, 
               position=position_dodge(0.8)) 

```

### Friedman Test

```{r}

#friedman.test(rating ~ variety | block, data = data_tbl)

data_tbl <- tibble(Block = 1:4,
                   Sorte_1 = c(2,3,4,3),
                   Sorte_2 = c(7,9,8,9),
                   Sorte_3 = c(6,5,4,7),
                   Sorte_4 = c(2,4,1,2),
                   Sorte_5 = c(4,5,3,7)) %>%
  gather(key, value, Sorte_1:Sorte_5)

friedman.test(value ~ key | Block, data = data_tbl)


```

## Auswertung von Infektionsstatus
