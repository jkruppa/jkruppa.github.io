```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, patchwork)
```

# Beta Regression {#sec-beta}

*Letzte Änderung am `r format(fs::file_info("stat-modeling-beta.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

link zu test auf anteile

wirkungsgrad?

Selten n

Im folgenden Kapitel

Daher sieht unser Modell wie folgt aus. Wir haben ein $y$ und $p$-mal $x$. Wobei $p$ für die Anzahl an Variablen auf der rechten Seite des Modells steht. Im Weiteren ist unser $y$ normalverteilt. Das ist hier sehr wichtig, denn wir wollen ja eine multiple gaussian lineare Regression rechnen.

$$
y \sim x_1 + x_2 + ... + x_p 
$$

::: callout-tip
## Weitere Tutorien für die Beta Regression

Wie immer gibt es auch für die Frage nach dem Tutorium für die Beta Regression verschiedene Quellen. Ich kann noch folgende Informationen und Hilfen empfehlen.

-   [A guide to modeling proportions with Bayesian beta and zero-inflated beta regression models](https://www.andrewheiss.com/blog/2021/11/08/beta-regression-guide) hilft besonders, wenn du tiefer in die Matrie einsteigen willst. Du erhälst bei dem Tutorium einen vollständigen Überblick über die Möglichkeiten. Weit mehr als ich hier mache.
-   Das Tutorium [Beta Regression for Percent and Proportion Data](https://rcompanion.org/handbook/J_02.html) leidet etwas unter dem Mangel an erklärenden Text. Hier wurde anscheinend erst der R Code generiert und der Text sollte folgen. Das schneit hier aber (noch) nicht der Fall zu sein. Als Überblick lohnt sich das Tutorium aber dennoch.
-   [What is the intuition behind beta distribution?](https://stats.stackexchange.com/questions/47771/what-is-the-intuition-behind-beta-distribution) erklärt nochmal was die Idee der Beta Regression eigentlich ist und was eine Betaverteilung eigentlich beschreibt.
-   Das R Paket `{betareg}` und die entsprechende Vignette [Beta Regression in R](https://cran.r-project.org/web/packages/betareg/vignettes/betareg.pdf) liefert wichtige Informationen über die Umsetzung der Beta Regression in R.
-   [Causal inference with beta regression](https://solomonkurz.netlify.app/blog/2023-06-25-causal-inference-with-beta-regression/) liefert eine sehr umfangreiche Überbick über die Beta Regression und das Testen mit der ANOVA. Dann aber auch nicht in dem klassischen Ansatz, den ich hier normalerweise rechne, sondern als bayesianische Variante.
-   Genauso betrachtet das Tutorium [Model Estimation by Example - Bayesian Beta Regression](https://m-clark.github.io/models-by-example/bayesian-beta-regression.html) auch die bayesianische Variante der Beta Regression, so dass du hier vermutlich eher weniger fündig wirst. Ich fand den Überblick aber gut und schön zu lesen -- vorallem war er auch nicht so lang.
:::

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, broom, betareg, car,
               see, performance, parameters, agridat, mfp,
               emmeans, multcomp, rcompanion, ggbeeswarm,
               conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflicts_prefer(dplyr::summarise)
cb_pal <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
            "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

Wie immer schauen wir uns verschiedene Datensätze an, Visualisieren die Zusammenhänge und rechnen dann verschiedene Modelle, die passen könnten. Beginnen möchte ich mit einem Datensatz zu dem Jagederfolg in \[%\] von Schneefüchsen in verschiedenen Habitaten. Die Daten sind etwas gekürzt, wir haben nur den Jagederfolg und keine Informationen zu den Habitaten. Des Weiteren wollen wir schauen, ob der Jagderfolg der Eisfüche von der standardisierten Schneehöhe in \[cm\] abhängt. Wir haben hier mehr oder minder die Schneehöhe in dem Habit gemittelt. Der Eisfuchs jagt ja nicht immer an der perfekt gleichen Stelle, wo wir die Schneehöhe kennen.

```{r}
hunting_tbl <- read_excel("data/hunting_fox.xlsx") %>% 
  mutate(proportion = round(success/attempts, 2))
```

In der @tbl-beta-fox siehst du einen Auszug aus den Daten. Wir haben die Schneehöhe gemessen und geschaut von wie vielen Anläufen `attempts` eine Maus unter dem Schnee zu fangen erfolgreich war `success` oder eben ein Fehlschlag `fail`. Daraud haben wir dann die Erfolgsrate `proportion` berechnet. Wir haben einfach den Anteil der Erfolge eine Maus zu fangen an den gesamten Versuchen berechnet.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-beta-fox
#| tbl-cap: "Auszug aus dem Daten zu dem Jagderfolg in [%] von Eisfüchsen in abhängigkeit von der Schneehöhe in [cm]."

hunting_raw_tbl <- hunting_tbl %>% 
  mutate_all(as.character)
  

rbind(head(hunting_raw_tbl, 4),
      rep("...", times = ncol(hunting_raw_tbl)),
      tail(hunting_raw_tbl, 4)) %>% 
  kable(align = "c", "pipe")

```

Im Weiteren schauen wir uns einen Datensatz zu Brokkoli an. Wir wollen hier einmal schauen, ob wir das Zielgewicht von $500g$ erreichen. Wir sind aber daran interessiert die Rate von untergewichtigen Brokkoli möglichst klein zu halten. Deshalb schauen wir uns in dieser Auswertung den Anteil von Brokkoli unter der Zielmarke von $500g$ für zwei Düngezeitpunkte sowie drei Düngestufen an. Wir müssen hier jetzt die Daten etwas mehr aufbereiten, da wir mehr Informationen in den Daten haben als wir wirklich brauchen.

```{r}
#| message: false
broc_tbl <- read_excel("data/broccoli_weight.xlsx") %>% 
  filter(fert_time %in% c("early", "late")) %>% 
  mutate(fert_time = factor(fert_time, levels = c("early", "late")),
         fert_amount = as_factor(fert_amount),
         block = as_factor(block)) %>%
  select(fert_time, fert_amount, block, weight) %>% 
  filter(weight <= 500) %>% 
  mutate(proportion = round(weight/500, 2))
```

In der @tbl-beta-broc siehst du einmal den Auszug aus den Brokkolidaten. Wir wollen jetzt sehen, ob wir in den Behandlungsfaktoren einen Unterschied bezüglich der Anteile der untergewichtigen Brokkoliköpfe finden. Tendenziell wollen wir eine Kombination finden, die uns natürlich möglichst schwere Köpfe beschert.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-beta-broc
#| tbl-cap: "Auszug aus dem Daten zu den Zielgewichten von Brokkoli zu zwei Düngezeitpunkten und drei Düngestufen."

broc_raw_tbl <- broc_tbl %>% 
  mutate_all(as.character)
  
rbind(head(broc_raw_tbl, 4),
      rep("...", times = ncol(broc_raw_tbl)),
      tail(broc_raw_tbl, 4)) %>% 
  kable(align = "c", "pipe")

```

Abschließend schauen wir nochmal in das R Paket `{agridat}` und nehmen von dort den Datensatz `salmon.bunt` welcher eine Pilzinfektion von Weizenlinien beschreibt. Mehr dazu dann auf der Hilfeseite [Fungus infection in varieties of wheat](https://kwstat.github.io/agridat/reference/salmon.bunt.html) in der Vignette zum R Paket. Wir haben zwei Wiederholungen `rep`, die auch so nicht helfen. Deshalb mittlere ich mit `summarise()` über die beiden Wiederholungen die Prozente der Piulzinfektionen des Weizen. Ich möchte später die Faktoren `gen` für die genetischen Linien und die Pilzarten `bunt` für die Anteile der Pilzinfektionen sortiert haben. Das mache ich dann einmal mit der Funktion `fct_reorder()` welche mir erlaubt einen Faktor nach einer anderen Variable zu sortieren.

```{r}
#| message: false
#| warning: false
data(salmon.bunt)
fungi_tbl <- salmon.bunt %>% 
  as_tibble() %>% 
  select(gen, bunt, rep, percent = pct) %>% 
  group_by(gen, bunt) %>% 
  summarise(percent = mean(percent)) %>% 
  mutate(gen = fct_reorder(gen, percent),
         bunt = fct_reorder(bunt, percent))
```

In der @tbl-beta-fungi siehst du dann einmal den Auszug aus unseren Weizendaten mit einer Pilzinfektion. Wir haben 10 genetische Linien sowie 20 Pilzarten vorliegen. Daher ist der Datensatz ziemlich groß, was die Möglichkeiten der Faktorkombinationen angeht.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-beta-fungi
#| tbl-cap: "Auszug aus dem Daten zu den Kichererbsen in Brandenburg."

fungi_raw_tbl <- fungi_tbl %>% 
  ungroup() %>% 
  mutate_all(as.character) 
  
rbind(head(fungi_raw_tbl, 4),
      rep("...", times = ncol(fungi_raw_tbl)),
      tail(fungi_raw_tbl, 4)) %>% 
  kable(align = "c", "pipe")

```

Damit habe wir dann einige spannende Datensätze vorliegen, die wir nutzen können um die verschiedenen Aspekte der Beta Regression anzuschauen. Nicht immer muss es ja eine Beta Regression sein, wir haben auch die Möglichkeit unsere Fragestellung mit anderen Modellen eventuell anders oder gar besser zu beantworten.

## Visualisierung

```{r}
#| warning: false
#| message: false
#| label: fig-beta-fox-scatter
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."

hunting_tbl %>% 
  ggplot(aes(snow_height, proportion)) +
  theme_minimal() +
  geom_point() +
  labs(y = "Jagderfolg [%]", x = "Standardisierte Schneehöhe [cm]") +
  ylim(0, 1)
```

```{r}
#| warning: false
#| message: false
#| label: fig-beta-broc
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."

broc_tbl %>% 
  ggplot(aes(x = fert_amount, y = proportion, color = fert_time)) +
  theme_minimal() + 
  labs(y = "[%] erreichtes Zielgewicht", x = "Düngemenge [mg/l]",
       color = "Düngezeitpunkt") +
  scale_y_continuous(breaks = seq(0, 1, by = 0.1)) +
  geom_beeswarm(dodge.width = 0.8) +
  theme(legend.position = "top") +
  scale_color_okabeito()
```

```{r}
#| warning: false
#| message: false
#| label: fig-beta-fungi
#| fig-align: center
#| fig-height: 4
#| fig-width: 8
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."


fungi_tbl %>% 
  ggplot(aes(x = gen, y = bunt, fill = percent)) +
  theme_minimal() +
  geom_tile()+
  scale_fill_gradientn(colors = c("#375997", "gray", "firebrick"),
                       breaks = seq(0, 100, 10), limits = c(0, 100)) + 
  labs(y = "Art des Pilzes", x = "Genetische Linie des Weizens",
       fill = "[%] infiziert")

```

## Fit des Modells

### ... mit der Gaussian Regression

```{r}
hunting_lm_fit <- lm(proportion ~ snow_height, data = hunting_tbl)
```

```{r}
#| message: false
#| warning: false
hunting_lm_fit %>% 
  model_parameters()
```

```{r}
hunting_lm_fit %>% r2()
```

### ... mit dem R Paket `{betareg}`

```{r}
hunting_beta_fit <- betareg(proportion ~ snow_height | snow_height, data = hunting_tbl)
```

```{r}
#| message: false
#| warning: false
hunting_beta_fit %>% 
  model_parameters(exponentiate = TRUE)
```

$$
\mbox{Änderung in Odds %:}\; (OR-1) * 100
$$

$$
\mbox{Änderung in Odds %:}\; (0.94-1) * 100 = -6\%
$$

```{r}
hunting_beta_fit %>% r2()
```

```{r}
#| warning: false
#| message: false
#| label: fig-beta-fox-diagnostic
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."
#| fig-subcap: 
#|   - "Alter nach Geschlecht"
#|   - "Körpergröße nach Geschlecht"
#|   - "test"
#|   - "test"
#| layout-nrow: 2

plot(hunting_beta_fit)
```

```{r}
hunting_beta_fit %>% Anova()
```

### ... mit einer logistischen Regression

```{r}
hunting_log_fit <- glm(cbind(hunting_tbl$success, hunting_tbl$fail) ~ snow_height, 
                       data = hunting_tbl, family = binomial(link="logit"))
```

```{r}
#| message: false
#| warning: false
hunting_log_fit %>% 
  model_parameters(exponentiate = TRUE)
```

Hier greifen wir auf das R Paket `{rcompanion}` zurück. Wir rechnen auch kein *echtes* Bestimmtheitsmaß $R^2$ aus, sondern den Vergleich zum Null-Modell.

```{r}
hunting_log_fit %>% 
  nagelkerke() %>% 
  pluck("Pseudo.R.squared.for.model.vs.null")
```

```{r}
hunting_log_fit %>% Anova()
```

```{r}
#| warning: false
#| message: false
#| label: fig-beta-fox-predict
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."

hunting_tbl %>% 
  ggplot(aes(snow_height, proportion)) +
  theme_minimal() +
  geom_point() +
  geom_line(aes(y = predict(hunting_log_fit, type = "response"), color = "log")) +
  geom_line(aes(y = predict(hunting_lm_fit, type = "response"), color = "lm")) +
  geom_line(aes(y = predict(hunting_beta_fit, type = "response"), color = "betareg")) +
  scale_color_manual(name = "Modell", values = cb_pal[2:4])
```

::: callout-note
## Wo ist die mathematische Formel?

::: panel-tabset
## Mit `nls()`

```{r}
lm(log(proportion) ~ snow_height, hunting_tbl)
```

```{r}
nls(proportion ~ b0 - I(snow_height^b1), data = hunting_tbl, 
    start = c(b0 = exp(1.0324), b1 = -0.0354))
```

Dann können wir uns auch schon die Gleichung zusammenbauen.

$$
proportion = 3.196 - snow\_height^{0.248}
$$

## Mit `mfp()`

```{r}
mfp(proportion ~ fp(snow_height), data = hunting_tbl)
```

Dann erhalten wir folgende Gleichung.

$$
proportion = 0.9741 -2.4216 \cdot \left(\cfrac{snow\_height}{100}\right)^3
$$
:::

```{r}
nls_func <- \(x){3.196 - x^(0.248)}
mfp_func <- \(x){0.9741 - 2.4216 * (x/100)^3}
```

```{r}
#| warning: false
#| message: false
#| label: fig-beta-fox-predict-non
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| fig-cap: "Ausgabe ausgewählter Modelgüteplots der Funktion `check_model()`."

hunting_tbl %>% 
  ggplot(aes(snow_height, proportion)) +
  theme_minimal() +
  geom_point() +
  geom_function(fun = nls_func, aes(color = "nls"), linetype = 'dashed') +
  geom_function(fun = mfp_func, aes(color = "mfp"), linetype = 'dashed') +
  scale_color_manual(name = "Modell", values = cb_pal[2:3])
```
:::

## Gruppenvergleich {#sec-mult-comp-beta-reg}
