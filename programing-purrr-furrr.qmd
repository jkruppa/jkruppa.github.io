# Mit `purrr` und `furrr` {#sec-purrr-furrr}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: callout-caution
## Was soll das hier? Ziemlich wild alles...

Dieses Kapitel dient dazu *fortgeschrittene* Programmierung in R zu präsentieren. Teilweise nutze ich komplexeren Code bei der [Auswertung von den Beispielen](#sec-beispiel-auswertung). Wenn dich also Programmieren interessiert, dann kannst du dir hier noch was anschauen.
:::

In diesem Kapitel geht es hauptsählich um [Iterationen](https://r4ds.had.co.nz/iteration.html#iteration). Das heißt wir wollen immer das Gleiche auf verschiedene unterschiedliche Dinge anwenden. In unserem Fall ist das "Gleiche" eine Funktion `function(...){}` in R und das "Unterschiedliche" sind Einträge in einer Liste `lst()` oder einem Datensatz `tibble()`. Wir wolln also zum Beispiel auf vrschiedenen Datensätzen mit fünf unterschiedlichen Outcomes immer wieder eine multiple lineare Regression rechnen. Anstatt also per Copy&Paste fünfmal den Code zu kopieren, wollen wir alle Datensätze in einer Liste speichern und die Liste dann in einem Schwung auswerten.

Wie wir die Daten in Gruppen zusammenfassen ist unterschiedlich möglich. Ich präsentiere hier zum einen die Funktion `split()`, die Daten in Listen aufteilt sowie die Funktion `nest()` die Daten in ein `tibble` zusammenfaltet. Beide Varianten haben so ihre Vor- und Nachteile. Wie immer kommt es dann auf die Anwendung an und was du machen willst.

Es lohnt sich hierbei die Listen bzw. die Datensätze, über die dann iteriert werden soll, so gleich wie irgendwie möglich zu bauen. Das heißt, dass wir die gleiche Anzahl an Spalten mit den gleichen Spaltennamen vorliegen haben wollen. Das erleichtert dann die spätere Anwendung mit `map()`.

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, rstatix, 
               janitor, purrr, furrr, see,
               readxl, tictoc, multcompView, 
               parameters,
               conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("extract", "magrittr")

```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Die Daten

```{r}
soil_tbl <- read_excel("data/soil_1fac_data.xlsx") %>% 
  mutate(variante = str_c(variante, "_", amount),
         variante = as_factor(variante),
         across(where(is.numeric), round, 2)) %>% 
  select(-amount) %>%
  extract(1:8, 1:4) %>% 
  pivot_longer(cols = fe:no3, 
               names_to = "outcome",
               values_to = "rsp") 
```

```{r}
spinach_tbl <- read_excel("data/spinach_metal_data.xlsx") %>% 
  mutate(trt = as_factor(trt),
         sample = as_factor(sample),
         block = as_factor(block)) %>% 
  pivot_longer(cols = fe:zn,
               names_to = "outcome",
               values_to = "rsp") %>% 
  mutate(outcome = as_factor(outcome))
```

## Daten aufteilen...

### ... mit `split()`

```{r}
soil_lst <- soil_tbl %>%
  split(.$outcome) 

soil_lst
```

### ... mit `nest()`

```{r}
spinach_nest_tbl <- spinach_tbl %>% 
  group_by(sample, outcome) %>% 
  nest() 

spinach_nest_tbl
```

Mit `unnest()` lässt sich dann die genestete Struktur wieder in einen normalen Datensatz zurückführen.

## Mit `purrr` über Daten {#sec-purrr}

Das [R Paket purrr](https://purrr.tidyverse.org/) erlaubt es sehr effizient immer das Gleiche auf Listeneinträgen oder genereller auf Daten anzuwenden. Wir können uns dabei selber eine Funktion schreiben oder aber schon implementierte Funktionen anwenden. Gehen wir eimal alle Funktionen durch. Wir werden hier nicht alle zeigen, aber es ist gut einmal zu wissen, welche Funktionen es gibt.

::: column-margin
Schaue auch mal in das Cheat Sheet des R Paketes `purrr` rein: [Apply functions with purrr::cheat sheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_purrr.pdf)
:::

-   `map()` erlaubt über eine Liste von Datensätzen ein Funktion anzuwenden. Dabei können wir dann die einzelnen Listeneinträge über `.x` an die Funktionen weitergeben. Siehe hierzu auch [Basic map functions](https://dcl-prog.stanford.edu/purrr-basics.html).
-   `map2()` erlaubt es über zwei gleichlange Vektoren zu laufen. Wir können hier zwei Optionen in der Form `.x`, `.y` an die Funktion weitergeben. Siehe hierzu auch [Map with multiple inputs](https://dcl-prog.stanford.edu/purrr-parallel.html).
-   `pmap()` kann nun über eine Liste an Vektoren laufen und somit mehrere Inputoptionen verarbeiten. Damit ist `pmap()` die Generalisierung der `map()` Funktion. Siehe hierzu auch [Map with multiple inputs](https://dcl-prog.stanford.edu/purrr-parallel.html).
-   `walk()` ist ein *silent* `map()`. Damit können wir Daten in eine Datei schreiben, ohne ein Output wieder zubekommen.
-   `imap()` können wir nutzen, wenn wir den Index $i$ wieder haben wollen. Das heißt, wir wollen über einen Vektor laufen und brauchen dafür den Index. Hier hilft die `imap()` Familie.
-   `modify()`können wir anwenden, wenn wir nur Spalten modifizieren oder mutieren wollen. Wir haben einen Datensatz und wollen alle `character` Spalten in einen Faktor umwandeln. Siehe hierzu auch [Modify elements selectively](https://purrr.tidyverse.org/reference/modify.html).

Schauen wir uns die Anwendung von der Funktion `map()` auf eine Liste an.

```{r}
soil_lst %>%
  map(select, -outcome) %>% 
  map(head, 1)
```

```{r}
soil_lst %>%
  map(~head(.x, 1))
```

```{r}
soil_lst %>% 
  map(~games_howell_test(rsp ~ variante, data = .x)) %>% 
  map(~mutate(.x, contrast = str_c(.x$group1, "-", .x$group2))) %>% 
  map(pull, p.adj, contrast) %>% 
  map(~multcompLetters(.x)$Letters) %>% 
  bind_rows(.id = "outcome") 
```

Wir können auch auch auf genesteten Daten die Funktion `map()` anwenden.

```{r}
spinach_nest_tbl %>%
  mutate(model = map(data, ~lm(rsp ~ trt + block, data = .x)))
```

```{r}
spinach_nest_tbl %<>%
  mutate(model = map(data, ~lm(rsp ~ trt + block, data = .x))) %>% 
  mutate(anova = map(model, anova)) %>% 
  mutate(parameter = map(anova, model_parameters)) %>% 
  select(sample, outcome, parameter) 
```

```{r}
spinach_nest_tbl %>%
  unnest(parameter) %>% 
  clean_names() %>% 
  mutate(across(where(is.numeric), round, 2)) %>% 
  filter(parameter != "Residuals") %>% 
  select(sample, outcome, parameter, p)
```

## Mit `furrr` parallel über Daten {#sec-furrr}

Warum geht es den jetzt hier? Wenn du `purrr` und die Funktionen `map()` verstanden hast, dann geht natürlich alles auch in paralleler Berechnung. Die parallele Berechnung ist in dem [R Paket furrr](https://furrr.tidyverse.org/) implementiert. Das heißt wir müssen nur die Funktionsnamen ändern und schon rechnet sich alles in Parallel. Wir nutzen also nicht nur einen Kern von unseren Rechnern sondern eben alles was wir haben.

```{r}
no_cores <- availableCores() - 1
no_cores
```

```{r}
plan(sequential)

tic()
nothingness <- future_map(c(2, 2, 2), ~Sys.sleep(.x))
toc()
```

Der folgende Code sollte ca. 2 Sekunden dauern, wenn der Code parallel läuft. Wir haben einen kleinen Overhead in `future_map()` durch das Senden von Daten an die einzelnen Kerne. Es gibt auch einmalige Zeitkosten für `plan(multisession)`, um die Kerne einzurichten.

```{r parallel-session}
#| cache: true

plan(multisession, workers = 3)

tic()
nothingness <- future_map(c(2, 2, 2), ~Sys.sleep(.x))
toc()
```

## progressr: An Introduction

[progressr: An Introduction](https://cran.r-project.org/web/packages/progressr/vignettes/progressr-intro.html)
