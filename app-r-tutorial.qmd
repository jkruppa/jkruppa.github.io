```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, openxlsx)
```

# Tutorium in R

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

In diesem Kapitel gibt es eine etwas *wilde* Sammlung an Fragen und Antworten, die im Rahmen des R Tutoriums aufkamen. Vielleicht findest du ja was, was dich inspiriert.

-   Wie setze ich um einen farbigen Punkt einen schwarzen Rand? (siehe @sec-black-circle-point)
-   Wie kann ich die Anordnung der Nutzungen bzw. Behandlungen in einer Grafik definieren? (siehe @sec-order-x-names)
-   Wie kann ich die Anordnung der Fehlerbalken in einem Barplot verändern? (siehe @sec-order-error-bars)

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
pacman::p_load(tidyverse, magrittr, readxl, broom, broom.mixed, 
               multcomp, emmeans, performance, lme4, effectsize)
```

Schaue dir bitte erst den R Code zu deiner Frage an und dann kannst du die Pakete noch nachinstallieren. Es werden sich hier sicherlich eine Menge ansammeln.

## Wie setze ich um einen farbigen Punkt einen schwarzen Rand? {#sec-black-circle-point}

In ggplot können wir verschiedene Typen von Punkte auswählen - auch `shape` genannt. Der `shape` mit der Nummer 21 hat die Möglichkeit die Füllung `fill` anders zu wählen, als die Randfarbe über `color`. Daher können wir die Punkte nach dem Faktor `trt` einfärben und setzen dann in dem `geom_point()` die Randfarbe auf `black`. Wir könnten da auch jede andere Farbe nehmen.

```{r}
#| echo: true
#| message: false
#| label: fig-r-tutorium-01
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Farbige Punkte mit einem schwarzen Rand."

plot_tbl <- tibble(x = 1:10,
                   y = rnorm(10, 5, 1),
                   trt = rep(c("A", "B"), each = 5)) %>% 
  mutate(trt =  as_factor(trt))

ggplot(plot_tbl, aes(x, y, fill = trt)) +
  geom_point(color = "black", shape = 21, size = 4) +
  theme_bw() 

```

## Wie kann ich die Anordnung der Nutzungen bzw. Behandlungen in einer Grafik definieren? {#sec-order-x-names}

Häufig ist es so, dass unser Behandlungs oder Nutzenspalte eine bestimmte Ordnung hat. Wenn wir die Ordnung beibehalten wollen, wie die Ordnung auch im Datensatz ist, dann können wir nach dem Einlesen der Daten die Funktion `as_factor()` nutzen. Dann bleibt die *ursprüngliche* Ordnung erhalten.

Wenn wir eine andere Ordnung haben wollen, dann können wir mit der Funktion `factor()` und der Option `level =` eine neue Ordnung der *existierenden* Level vorgeben.

Für die Umbenennung in R empfehle ich die Funktion [`recode()`](https://dplyr.tidyverse.org/reference/recode.html).

```{r}
#| echo: true
#| message: false
#| label: fig-r-tutorium-02
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Neuordnung des Faktors `trt` für die Boxplots."

plot_tbl <- tibble(y = rnorm(20, 5, 1),
                   trt = rep(c("Gemüse", "Obst", "Strauch", "Brache"), 
                             each = 5)) %>% 
  mutate(trt =  factor(trt, level = c("Obst", "Strauch", "Brache", "Gemüse")))

ggplot(plot_tbl, aes(trt, y, fill = trt)) +
  geom_boxplot() +
  theme_bw() +
  theme(legend.position = "none")

```

## Wie kann ich die Anordnung der Fehlerbalken in einem Barplot verändern? {#sec-order-error-bars}

In dem @sec-eda-ggplot haben wir uns ja nur mit Balkendiagrammen mit einem Faktor beschäftigt. Das heist, wir haben den Faktor auf die x-Achse gelegt und schon hatten wir den Plot. Wenn wir zwei Faktoren haben, dann müssen wir über die Option `position = position_dodge()` etwas spielen. Wir können auch die Position und des Abstand etwas ändern. Ich habe hier `0.9` für die Fehlerbalken in `position = position_dodge()` probiert und es sieht ziemlich gut aus.

```{r}
#| echo: true
#| message: false
#| label: fig-r-tutorium-03
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Fehlerbalken für einen Barplot mit zwei Faktoren."

plot_tbl <- expand_grid(site = 1:4, 
                        trt = 1:2, 
                        rep = 1:5) %>% 
  mutate(site = factor(site, labels = c("A", "B", "C", "D")),
         trt = factor(trt, labels = c("new", "old")),
         rsp = rnorm(n(), 10, 2))

stat_tbl <- plot_tbl %>% 
  group_by(site, trt) %>% 
  summarise(mean = mean(rsp),
            sd = sd(rsp))

ggplot(stat_tbl, aes(x = site, y = mean, group = trt, fill = trt)) + 
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),
                width = 0.2, position = position_dodge(0.9)) +
  theme_bw() +
  labs(fill = "Behandlung")


```

## Auswertung von Pflugdaten

```{r}

plowing_file <- file.path("data/plowing_data.xlsx")

plowing_lst <- plowing_file %>% 
  excel_sheets() %>% 
  rlang::set_names() %>% 
  map(read_excel, path = plowing_file)

plowing_lst <- plowing_lst %>% 
  map(~arrange(.x, day, block, variant)) %>% 
  map(~mutate(.x, 
              block = as_factor(block),
              variant = as_factor(variant),
              day = as_factor(day))) 

```

## Keimung

```{r}
germ_tbl <- read_excel("data/germination_data.xlsx")


```

## Schweine

```{r}
pig_tbl <- read_excel("data/pig_feed_data.xlsx")


```

## Kohlenstoff/Nitrat

```{r}
carbon_tbl <- read_excel("data/carbon_data.xlsx") %>% 
  mutate(c2n = c_o/n,
         c_m2c_o = c_m/c_o)


```

## Lichtintensität

```{r}
intensity_tbl <- read_excel("data/light_intensity_data.xlsx") %>% 
  mutate(rack = as_factor(rack),
         layer = as_factor(layer),
         light_intensity = factor(light_intensity, 
                                  labels = c("low", "mid", "high")))
```

```{r}
#| echo: false

#intensity_tbl %>% 
 # kable(align = "c", "pipe")

```

```{r}

fit_1 <- lm(growth ~ light_intensity + rack + layer, data = intensity_tbl)

fit_1 %>% anova %>% tidy

```

```{r}

fit_1 %>% glht(linfct = mcp(light_intensity = "Tukey")) %>% tidy

```

```{r}

marginal <- emmeans(fit_1, "light_intensity")
tidy(marginal) %>% 
  mutate_if(is.numeric, round, 2)

```

```{r}
marginal %>% contrast(method = "pairwise") %>% tidy %>% 
  mutate_if(is.numeric, round, 2)
```

## Komplexes Weizenbeispiel

Wir wollen uns nun ein kpmplexeres Datenbeispiel anschauen. In diesem Beispiel liegen zum einen die Daten in einem ungünstigen Wide-Format vor und müssen über `gather()` erst in das Long-Format gebracht werden. Zum anderen entstehen dadurch ungünstige Einträge in der `key`-Spalte, so dass wir hier nochmal einen regulären Ausdruck benötigen um den `character` Vektor umwandeln zu können.

Als wäre dies nicht schon kompliziert genug, schauen wir uns nicht nur ein Outcome an, sondern in der Summe die Outcomes Weizenhöhe, Chlorophyllgehalt sowie Frisch- und Trockengewichte. Der Weizen wurde in vier Blöcken angezogen und zu verschiedenen Zeitpunkten gemessen. Hierdurch entsteht ein komplexer Versuchsaufbau.

### Weizenhöhe

Die Höhe der Weizenpflanzen \[cm\] wurde in vier Blöcken an insgesamt neun Tagen gemessen. Die Datei `corn_plant_height.csv` beinhaltet die Daten des Versuchs. Für die folgende Auswertung nehmen wir an, das die Weizenhöhe normalverteilt ist. Wie beginnen mit einer exploratven Datenanalyse udn schauen uns die Daten einmal an.

#### Exlorative Datenanalyse

```{r}
#| message: false

plant_tbl <- read_csv2("data/corn_plant_height.csv") %>% 
  gather(key = "day", value = "height", "1...3":"9...47") %>% 
  mutate(day = str_replace(day, "...\\d+", ""),
         day = as_factor(day),
         treatment = as_factor(treatment),
         block = factor(block, labels = c("I", "II", "III", "IV")))

```

In der `csv`-Datei sind die die Tage jeweils fünfmal mit einer 1 bis 9 in den Spalten abgebildet. Wir nutzen die Funktion `read_csv2` um mit dem deutschen Format der `csv`-Datei umgehen zu können. Die Funktion `read_csv2` erkennt das `;` als Separator. Da R nicht mit gleichen Benennungen in den Spalten umgehen kann, setzt R hinter jeden Spaltennamen, der gleich ist drei Punkte und eine fortlaufende Zahl. Mit der Funktion `gather()` können wir die Spalten `1...3` bis `9...47` untereinanderkleben. Abschließend müssen wir noch den `...[Zahl]`-Teil loswerden. Das machen wir über den regulären Ausdruck in der Funktion `str_replace()`. Reguläre Ausdrücke musst du nicht verstehen, sind aber sehr mächtige Werkzeuge im Umgang mit großen Datensätzen.

Schauen wir uns nun einmal die Daten an. Unser Outcome (Y) ist `height` und auf X wollen wir das `treatment`. Das wollen wir die Boxplots noch nach dem Tag einfärben und jeweils ein Subplot für die vier Blöcke bauen.

```{r}
#| column: page
#| fig-height: 7
#| fig-width: 14
#| label: fig-crop-boxplot-1
#| fig-cap: "An 39 Hunden wurde die Anzahl an Flöhen gezählt."


ggplot(plant_tbl, aes(x = treatment, y = height, fill = day)) +
  geom_boxplot() +
  facet_wrap(~ block) +
  labs(x = "Behandlung", y = "Weizenhöhe [cm]", fill = "Messtag") +
  theme_bw()
```

@fig-crop-boxplot-1 zeigt den entsprechenden Boxplot. Du siehst, dass du auf den ersten Blick nichts siehst. Bei einer so großen Datenmenge ist es selbst mit einem guten `ggplot()` schwer etwas zu erkennen. Hier müssen wir uns mehrere Fragen stellen...

-   ... wollen wir wirklich alle Blöcke getrennt auswerten?
-   ... wollen wir uns wirklich alle Tage anschauen? Oder geht es nicht eher um die Pflanzenhöhe **am Ende** des Versuches?
-   ... wollen wir wirklich alle `treatment` Stufen vergleichen?

```{r}
#| fig-align: center
#| label: fig-crop-boxplot-2
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "An 39 Hunden wurde die Anzahl an Flöhen gezählt."

plant_tbl %>% 
  filter(block == "I") %>% 
  filter(day %in% c(6, 7, 8, 9)) %>% 
  ggplot(aes(x = treatment, y = height, fill = day)) +
  geom_boxplot() +
  facet_wrap(~ block) +
  labs(x = "Behandlung", y = "Weizenhöhe [cm]", fill = "Messtag") +
  theme_bw()
```

@fig-crop-boxplot-2 zeigt einen Auschnitt in dem wir nur nach Block I und den Tagen 6 bis 9 gefiltert haben. In diesem Fall könnten wir auf den vollen Datensatz weitermachen *oder* vorab über `filter()` einen kleinern Datensatz bauen, der unsere Fragestellung bgut beantworten kann. Wir gehen jetzt den steinigeren Weg und analysieren den ganzen Datensatz - das muss nicht der bessere Weg sein!

#### Lineares Modell mit `lm()`

Wir beginnen mit einer ANOVA und müssen dafür ein lineare Modell schätzen. Dafür nutzen wir erst die Funktion `lm()` und anschließend mit dem Ergebnis des linearen Modells die Funktion `anova()` um eine Varianzanalyse durchzuführen.

```{r}
fit_height <- lm(height ~ treatment + day + block + 
                   treatment:day + treatment:block, 
                 data = plant_tbl)

fit_height %>% anova
```

Wir konzentrieren uns auf die Spalte `Pr(>F)` welche den p-Wert beinhaltet. Wir schauen welcher p-Wert kleiner ist als $\alpha = 5\% = 0.05$. Alle p-Werte sind signifikant. Mindestens zwei `treatment` Level unterscheiden sich, mindestens zwei `day` Level unterschieden sich und mindestens zwei `block` Level unterscheiden sich. Abschließend ist auch der Interaktionsterm zwischen den Behandlungen und den Tagen sowie den Behandlungen und den Blöcken signifikant.

```{r}
fit_height %>% anova %>% eta_squared(partial = FALSE)
```

```{r}
fit_height_lme <- lmer(height ~ treatment + block + (1|day), 
                       data = plant_tbl)

fit_height_lme %>% summary

fit_height_lme %>% 
  tidy(conf.int = TRUE, effects = "fixed")

model_performance(fit_height_lme) 

r2(fit_height_lme)

conf_tbl <- glht(fit_height_lme, linfct = mcp(treatment = "Tukey")) %>% 
  tidy(conf.int = TRUE) %>% 
  arrange(estimate) %>% 
  mutate(contrast = as_factor(contrast))

ggplot(conf_tbl, aes(x = contrast, y = estimate, 
                     ymin = conf.low, ymax = conf.high)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, color = "red") +
  labs(x = "", y = "Mittelwertsdifferenz der Weizenhöhe [cm]") +
  coord_flip() +
  theme_bw()
```

### Chlorophyllgehalt

```{r}
#| message: false

chlorophyl_tbl <- read_csv2("data/corn_chlorophyl.csv") %>% 
  gather(key = "day", value = "chlorophyl", "1...3":"3...62") %>% 
  mutate(day = str_replace(day, "...\\d+", ""),
         day = as_factor(day),
         treatment = as_factor(treatment),
         block = factor(block, labels = c("I", "II", "III", "IV"))) %>% 
  filter(chlorophyl >= 20 & chlorophyl <= 100)

```

```{r}
#| column: page
#| fig-height: 7
#| fig-width: 14

ggplot(chlorophyl_tbl, aes(x = treatment, y = chlorophyl, fill = day)) +
  geom_boxplot() +
  facet_wrap(~ block) +
  labs(x = "Behandlung", y = "Chlorophyllgehalt", fill = "Messtag") +
  theme_bw()
```

### Frisch- und Trockenmasse

```{r}
#| message: false

burn_tbl <- read_csv2("data/corn_burning.csv") %>% 
  gather(key = "day_outcome", value = "drymatter", "1_FM":"3_TMperc") %>%
  separate(day_outcome, c("day", "outcome")) %>% 
  mutate(day = as_factor(day),
         treatment = as_factor(treatment),
         block = factor(block, labels = c("I", "II", "III", "IV")),
         outcome = as_factor(outcome)) 

```

```{r}
burn_tbl %>% 
  filter(outcome == "FM") %>% 
  ggplot(aes(x = treatment, y = drymatter, color = day)) +
  geom_point() +
  ##facet_wrap(~ block, scales = "free_y") +
  labs(x = "Behandlung", y = "Gewicht", fill = "Messtag") +
  theme_bw()
```
