```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, simstudy)
```

# Lineare gemischte Modelle {#sec-mixed}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: column-margin
Dieses Kapitel basiert auf dem tollen [Tutorium von Gabriela K Hajduk](https://ourcodingclub.github.io/tutorials/mixed-models/). Die Daten und Inhalte wurden von mir angepasst und teilweise gekürzt sowie inhaltlich angepasst.
:::

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, conflicted, broom, see,
               multcomp, emmeans, lme4, broom.mixed,
               parameters, ggridges, scales, performance)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

In diesem fiktiven Datenbeispiel wollen wir uns die Testscores eines Intelligentest bei $N = 480$ Drachen anschauen. Wir sind dafür an acht Berge gefahren und haben die dortigen Drachen an den drei Flanken des Berges getestet. Daher hat der Faktor `mountain_range` acht Level mit Bavarian, Ligurian, Emmental, Central, Maritime, Southern, Julian, und Sarntal. Die drei Flanken des Berges bilden wir im Faktor `site` mit den Leveln north, east und south ab. In @fig-mountain-site sehen wir eine Skizze für drei Berge mit den jeweiligen Flanken, wo gemessen wurde.

![Beispiel für drei der acht Berge mit *Bavarian*, *Central* und *Julian*. Auf jeden der acht Berge wurden an drei Seiten *north*, *east* und *south* die Testscores der dort lebenden Drachen erhoben.](images/mountain.png){#fig-mountain-site fig-align="center" width="90%"}

Die Daten liegen in dem Datensatz `dragons.csv` ab. Wir müssen aber noch einen Faktor `body_length_cat` bilden in dem wir die `body_length` der einzelnen Drachen in Kategorien umwandeln. Wir wollen später noch Gruppenvergleiche rechnen und brauchen daher einen Faktor mit Leveln. Daher nutzen wir die Funktion `case_when()` um einen Faktor mit fünf Größenkategorien zu bilden. Danach müssen wir wie immer noch die `character` Spalten in die entsprechenden Faktoren umwandeln.

```{r}

dragons_tbl <- read.csv2("data/dragons.csv") %>% 
  mutate(body_length_cat = 
           case_when(body_length < 170 ~ "tiny",
                     body_length >= 170 & body_length < 180 ~ "small",
                     body_length >= 180 & body_length < 200 ~ "medium",
                     body_length >= 200 & body_length < 220 ~ "large",
                     body_length >= 220 ~ "gigantic"),
         body_length_cat = as_factor(body_length_cat),
         mountain_range = as_factor(mountain_range),
         site = factor(site, labels = c("north", "east", "south"))) %>% 
  select(test_score, body_length, body_length_cat, everything())

```

Es ergibt sich dann der Datensatz wie in @tbl-dragon gezeigt. Wir belassen die Körperlänge der Drachen in der kontinuierlichen Form nochmal mit in den Daten.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-dragon
#| tbl-cap: Datensatz der Testscores für die Drachen auf verschiedenen Bergen und dort an verschiedenen Flanken der Berge.
#| column: page

dragons_raw_tbl <- dragons_tbl %>% 
  mutate(body_length_cat = as.character(body_length_cat),
         mountain_range = as.character(mountain_range),
         site = as.character(site))

rbind(head(dragons_raw_tbl, n = 4),
      rep("...", times = ncol(dragons_raw_tbl)),
      tail(dragons_raw_tbl, n = 4)) %>% 
  kable(align = "c", "pipe")
```

Bevor wir mit dem Modellieren beginnen, wollen wir erstmal visuell überprüfen, ob unser Outcome $y$ mit dem Testscore auch normalverteilt ist. Wir benötigen für das *klaissche* lineare gemischte Modell ein normalverteiltes Outcome $y$. In @fig-mixed-1 sehen wir das Histogramm der Verteilung des Testscores für alle $N = 480$ Drachen.

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: Histogramm des Testscores über alle Datenpunkte zur Überprüfung der Annahme der Normalverteilung. Wir sehen eine approximative Normalverteilung des Testscores.
#| label: fig-mixed-1

ggplot(dragons_tbl, aes(test_score)) +
  geom_histogram() +
  theme_bw() 
```

Wir können in der @fig-mixed-2 auch nochmal schauen, ob die Annahme der annährenden Normalverteilung für unseren Testscore auch für jedes Level unseres Faktors der Körperlängen gegeben ist. Wir sehen auch hier, dass der Testscore einer Normalverteilung über alle Kategorien der Körperlänge folgt.

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: Histogramm des Testscores aufgeteilt nach Kategorie der Körpergröße zur Überprüfung der Annahme der Normalverteilung. Wir sehen eine approximative Normalverteilung des Testscores für alle Kategorien der Körpergröße.
#| label: fig-mixed-2

ggplot(dragons_tbl, aes(y = body_length_cat, x = test_score, fill = body_length_cat)) +
  theme_bw() +
  stat_density_ridges() +
  theme(legend.position = "none") +
  scale_fill_okabeito() 
```

Natürlich können wir uns hier noch weitere Abbildungen erstellen, aber hier soll es erstmal reichen. Wir sehen, dass der Testscore einer Normalverteilung folgt und dass die Varianzen vermutlich homogen sind, da die Histogramme ungefähr gleich breit sind. Ja, ein wenig unterscheiden sich die Verteilungen, aber so gravierend ist es erstmal nicht.

## Modellierung

Simples Gaussian lineare Modell mit einem Faktor $f_1$:

$$
y \sim f_1
$$

Multiples Gaussian lineares Modell mit einem Faktor $f_1$ und einem Blockfaktor $b_1$:

$$
y \sim f_1 + b_1
$$

Multiples Gaussian lineares gemischtes Modell mit einem festen Faktor $f_1$ und einem zufälligen Blockfaktor $z_1$:

$$
y \sim f_1 + 1|z_1
$$

Multiples Gaussian lineares gemischtes Modell mit einem festen Faktor $f_1$ und einem zufälligen Blockfaktor $z_2$ genested in einem einem zufälligen Blockfaktor $z_1$:

$$
y \sim f_1 + 1|z_1/z_2
$$

```{r}
#| message: false
#| warning: false

lm_simple_fit <- lm(test_score ~ body_length_cat, data = dragons_tbl)

lm_simple_fit %>% model_parameters()

```

```{r}
#| message: false
#| warning: false

lm_mountain_fit <- lm(test_score ~ body_length_cat + mountain_range, data = dragons_tbl)
lm_mountain_fit %>% model_parameters()
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-3

ggplot(dragons_tbl, aes(x = body_length_cat, y = test_score, fill = body_length_cat)) +
  theme_bw() +
  geom_boxplot() +
  theme(legend.position = "none") +
  scale_fill_okabeito() 
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-4

ggplot(dragons_tbl, aes(sample = test_score)) +
  stat_qq() + stat_qq_line(color = "red") +
  theme_bw() +
  scale_color_okabeito()
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-5

ggplot(dragons_tbl, aes(mountain_range, test_score, fill = mountain_range)) +
  geom_boxplot() +
  theme_bw() +
  theme(legend.position = "none") +
  scale_fill_okabeito()
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-6

ggplot(dragons_tbl, aes(x = body_length_cat, y = test_score, fill = mountain_range)) +
  geom_boxplot(position = position_dodge(preserve = "single")) +
  theme_bw() +
  scale_fill_okabeito() +
  labs(fill = "Mountain")
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-7

ggplot(dragons_tbl, aes(x = body_length_cat, y = test_score, fill = mountain_range)) +
  geom_boxplot(position = position_dodge(preserve = "single")) +
  theme_bw() +
  scale_fill_okabeito() +
  labs(fill = "Mountain") +
  theme(legend.position = "none") +
  facet_wrap(~ mountain_range) 
```

```{r}
#| message: false
#| warning: false

lmer_1_fit <- lmer(test_score ~ body_length + (1 | mountain_range), data = dragons_tbl)
lmer_1_fit %>% model_parameters()
```

```{r}
#| message: false
#| warning: false

lmer_1_fit %>% model_performance()
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-8

augment(lmer_1_fit) %>% 
  ggplot(aes(x = .fitted, y = .resid)) + 
  geom_point() +
  geom_hline(yintercept = 0, color = "red") +
  theme_bw() +
  scale_color_okabeito()
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-9

ggplot(tibble(.resid = resid(lmer_1_fit)), aes(sample = .resid)) + 
  stat_qq() + 
  stat_qq_line(color = "red") +
  theme_bw()
```

```{r}
#| message: false
#| warning: false

lmer_2_fit <- lmer(test_score ~ body_length + (1|mountain_range/site), data = dragons_tbl) 
lmer_2_fit %>% model_parameters()
```

```{r}
#| message: false
#| warning: false

lmer_2_fit %>% model_performance()
```

```{r}
#| message: false
#| warning: false

compare_performance(lm_simple_fit, lm_mountain_fit, lmer_1_fit, lmer_2_fit,rank = TRUE)
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: foo
#| label: fig-mixed-10

ggplot(dragons_tbl, aes(x = body_length, y = test_score, colour = site)) +
  facet_wrap(~mountain_range, nrow=3) +
  theme_bw() +
  geom_point() +
  geom_line(data = cbind(dragons_tbl, pred = predict(lmer_2_fit)), aes(y = pred)) +
  theme(legend.position = "none") +
  scale_color_okabeito() 
```

```{r}
#| message: false
#| warning: false

lmer_3_fit <- lmer(test_score ~ body_length_cat + (1 | mountain_range/site), data = dragons_tbl)
lmer_3_fit %>% model_parameters()
```

```{r}
res_lmer <- lmer_3_fit %>% 
  emmeans(~ body_length_cat) 
```

```{r}
res_lmer_cld <- res_lmer %>% 
  cld(adjust = "bonferroni", Letters = letters) %>% 
  tidy() %>% 
  select(body_length_cat, estimate, conf.low, conf.high, .group) %>% 
  mutate(across(where(is.numeric), round, 2))

res_lmer_cld 
```

```{r}
#| message: false
#| echo: true
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| fig-cap: Scatterplot der Behandlungsgruppen zusammen mit den 95% Konfidenzintervall und dem *compact letter display*.
#| label: fig-cld-rcbd

ggplot() +
  theme_bw() +
  geom_point(data = dragons_tbl, aes(x = body_length_cat, y = test_score)) +
  geom_text(data = res_lmer_cld, 
            aes(x = body_length_cat , y = estimate, label = .group),
            position = position_nudge(x = 0.2), color = "red") +
  geom_errorbar(data = res_lmer_cld,
                aes(ymin = conf.low, ymax = conf.high, x = body_length_cat),
                color = "red", width = 0.1,
                position = position_nudge(x = 0.1)) +
  geom_point(data = res_lmer_cld, 
             aes(x = body_length_cat , y = estimate),
             position = position_nudge(x = 0.1), color = "red") +
  scale_color_okabeito() +
  labs(x = "Körperlänge in Kategorien", y = "Testscore", 
       caption = "Schwarze Punkte stellen Rohdaten dar.
       Rote Punkte und Fehlerbalken stellen bereinigte Mittelwerte mit 95% Konfidenzgrenzen pro Behandlung dar.
       Mittelwerte, mit einem gemeinsamen Buchstaben, sind nicht signifikant unterschiedlich.")

```

```{r}
res_lmer_tbl <- res_lmer %>% 
  contrast(method = "pairwise") %>% 
  tidy(conf.int = TRUE) %>% 
  mutate(p.value = pvalue(adj.p.value),
         across(where(is.numeric), round, 2)) %>% 
  select(contrast, estimate, p.value,
         conf.low, conf.high) 

res_lmer_tbl
```

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: Abbildung der 95% Konfidenzintervallefür alle paarweisen Vergleiche der Behandlungsgruppen.
#| label: fig-emmeans-rcbd-ci

ggplot(res_lmer_tbl, aes(contrast, y=estimate, ymin=conf.low, ymax=conf.high)) +
  geom_hline(yintercept=0, linetype="11", colour="grey60") +
  geom_errorbar(width=0.1) + 
  geom_point() +
  coord_flip() +
  theme_bw()  +
  labs(x = "Vergleich", y = "Mittelwertsunterschied des Gewichtes [kg/ha]",
       caption = "Schwarze Punkte stellen die bereinigten Mittelwertsunterschiede mit 95% Konfidenzgrenzen dar.
       Enthält ein 95% Konfidenzintervalle die 0 ist es nicht signifikant unterschiedlich.")
```

## Nested

https://stats.stackexchange.com/questions/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified

https://www.statology.org/nested-anova-in-r/
