```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc,
               grid, agricolae, patchwork, desplot, modelr, see)
```

# Fortgeschrittene Designs {#sec-experimental-design-advanced}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: callout-important
## Auf ein Wort zum Umfang des Kapitels

Ich werde mich in diesem Kapitel für das Erste auf die wichtigen experimentellen Design beschränken. Wenn sich aus deer Lehre oder Beratungstätigkeit noch Bedarf an weiteren experimentellen Designs ergibt, werde ich die Designs entsprechend ergänzen. Insbesondere hier gilt, dass [DSFAIR](https://schmidtpaul.github.io/DSFAIR/DesigningExperiments.html) einen sehr umfangreichen Überblick liefert.

**Wenn dir ein experimentelles Design fehlt, dann schreibe mir gerne eine Mail und ich schaue, dass ich das experimentelle Design ergänze.**

Siehe dazu auch das Inhaltsverzeichnis von dem R Paket `agricolae` mit [Experimental Designs with agricolae](https://myaseen208.com/agricolae/articles/ExperimentalDesign.html) einmal genauer an. Auch ist es sehr hilfreich sich Datenbeispiele auf [agridat - Datensätze mit Abbildungen in `desplot`](https://kwstat.github.io/agridat/reference/index.html) anzuschauen.
:::

In diesem Kapitel wollen wir uns mit der Erstellung von komplexeren experimentellen Designs beschäftigen.

-   [Randomized complete block design (RCBD, 3-faktoriell)](#sec-rcbd-3fac)
-   [Split plot design (3-faktoriell) oder Spaltanlage](#sec-split)
-   [Subsampling](#sec-subsampling)
-   [Incomplete block design (3-faktoriell und 2-faktoriell)](#sec-incomplete)
-   [Strip plot design (3-faktoriell) oder Streifenanlage](#sec-strip-plot)

Dabei ist zu Bedenkne, dass diese Designs sehr viel Aufwand in der Anlegen der Anlage sowie der praktischen Auswertung auf dem Feld bedürfen. Hier musst du dich dann nochmal beraten lassen, bevor du mit einem Experiment startest. Wir schauen uns jetzt aber erstmal einen Überblick über die gängigsten komplexeren experimentellen Designs an.

In der @fig-exp-adv-1 sehen wir einmal die Übersicht über die drei häufigsten komplexeren experimentellen Designs mit dem RCBD (3-faktoriell), dem Split plot Design (3-faktoriell) sowie dem Subsampling eines RCBD (2-faktoriell). Die drei experimentellen Designs werden immer mal wieder etwas durcheinander gewirbelt. Du kannst dir im Prinzip die Sachlage wie folgt vorstellen. Im RCBD (3-faktoriell) werden die beiden Behandlungsfaktoren über die Blöcke randomsiert. Die beiden Behandlungen sind vollkommen durcheinander in der @fig-exp-adv-1-1. Im Fall eines Split plot Design (3-faktoriell) wird eine Behandlung innerhalb der anderen Behandlung über die Blöcke randomisiert. Wir haben also eine Spaltanlage vorliegen, da wir immer eine Behandlung in einer Spalte randomisieren. Das ist schon in der @fig-exp-adv-1-2 zu sehen. Die Farben bilden die zweite Behandlung ab. Innerhalb einer Spalte ist dann die erste Behandlung randomisiert. Das Subsampling nimmt jetzt eine Behandlung raus. Wir haben dann nur noch eine Behandlung als Faktor, die wir in den Blöcken randomisieren. Die Idee des Subsamplings ist nun, dass wir wiederholt Pflanzen innerhalb der Behandlung messen. Wir mitteln jetzt aber nicht über die Pflanzen in einem Block sondern nehmen alle Pflanzen mit in die statistische Auswertung. Das ist eigentlich die zentrale Idee des Subsamplings, wie wir das machen, ist dann die andere Frage. In der @fig-exp-adv-1-3 sehen wir schön wie sich die Pflanzen-ID's über das Feld verteilen. Die Farben stellen die vier Behandlungslevel dar.

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-1
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "Vergleich der drei häufigsten komplexeren experimentellen Designs mit dem RCBD (3-faktoriell), dem Split plot Design (3-faktoriell) sowie dem Subsampling eines RCBD (2-faktoriell). Die Zahlen bei dem Subsampling stellt die ID's der individuellen Beobachtungen dar."
#| fig-subcap: 
#|   - "Sechs Eisendüngerbehandlung (Text: fe_1 bis fe_6) sowie vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) in vier Blöcken."
#|   - "Sechs Eisendüngerbehandlung (Text: fe_1 bis fe_6) sowie vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) in vier Blöcken."
#|   - "Vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) mit den individuellen Beobachtungen in vier Blöcken."
#| layout-nrow: 1
#| column: page


trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4

## rcbd
fac2rcbd_out <- design.ab(trt = c(n_trt_fac2_fert, n_trt_fac1_soil), 
                          design = "rcbd",
                          r = n_block, 
                          seed = 42)

fac2rcbd_out$bookRowCol <- fac2rcbd_out$book %>%
  bind_cols(expand.grid(rows = 1:n_trt_fac2_fert,
                        cols = 1:(n_trt_fac1_soil*n_block))) %>% 
  mutate(trt_fac2_fert = paste0("fe_", A),
         trt_fac1_soil = paste0("soil_", B),
         block = paste0("Block ", block))

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = trt_fac2_fert, cex = 1, shorten = "no", col=trt_fac1_soil,
        data = fac2rcbd_out$bookRowCol,
        main = "Randomized complete block design (3-faktoriell)", 
        show.key = FALSE, key.cex = 0.5)

## split plot
splitplot_out <- design.split(trt1 = trt_fac1_soil,
                              trt2 = trt_fac2_fert,
                              r = n_block,
                              seed = 42)


splitplot_out$bookRowCol <- splitplot_out$book %>% 
  mutate(block = paste0("Block ", block),
         cols = plots %>% str_sub(2,3) %>% as.integer,
         rows = splots %>% as.integer)

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = trt_fac2_fert, cex = 1, shorten = "no", col=trt_fac1_soil,
        data = splitplot_out$bookRowCol ,
        main = "Split plot design (3-faktoriell)",
        show.key = FALSE, key.cex = 0.5)

## subsampling

rcbd_long_tbl <- expand_grid(block = 1:4, 
                             trt = 1:4,
                             rep = 1:6) %>% 
  mutate(trt = factor(trt, labels = trt_fac1_soil),
         block = factor(block, labels = str_c("Block ", 1:4)),
         pid = 1:n(),
         pid_text = str_pad(1:96, width = 2, pad = "0")) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) 

rcbd_plot_tbl <- rcbd_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))

desplot(data = rcbd_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell)", 
        text = pid_text, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 



```

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, agricolae, dae, desplot,
               conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("set_names", "magrittr")
cbbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Randomized complete block design (RCBD, 3-faktoriell) {#sec-rcbd-3fac}

Das Maximum des machbaren ist eigentlich ein dreifaktorielles Modell im *randomized complete block design*. Natürlich geht auch noch mehr, aber der Grundsatz ist eigentlich, dass wir uns maximal zwei Behandlungsfaktoren und dann ein bis zwei Cluster anschauen. Die Cluster sind dann meist einmal der klassische Block plus ein Faktor für verschiedene Lokalisationen. Wir nehmen hier jetzt einmal zwei Behandlungsfaktoren und dann noch einen klassischen Block dazu. Beide Behandlungsfaktoren sind ineinander und dann natürlich im Block genestet. Hier aber erstmal das Modell mit den drei Faktoren für den besseren Überblick. Wir haben einmal die Düngung `fert`, dann den Faktor Boden `soil` sowie die verschiedenen Blöcke durch `block`.

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

mit

-   dem Faktor Dünger `fert` und den sechs Düngestufen als Level `fe_1` bis `fe_6`.
-   dem Faktor Boden `soil` und den vier Bodenarten als Level `soil_1` bis `soil_4`.
-   dem Faktor Block `block` und den zwei Leveln `block_1` und `block_2`.

Die Struktur der Daten ist wie folgt gegeben. Jedes Level der Düngerstufe `fert` ist in dem Faktor des Bodens `soil` enthalten. Die beiden Behandlungen sind dann wiederum jeweils vollständig in den Blöcken `block` vorhanden. In der @fig-mermaid-adv-rcbd sehen wir einmal den Zusammenhang zwischend den drei Faktoren

```{mermaid}
%%| label: fig-mermaid-adv-rcbd
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    A(fert):::factor --- B(((nestet))) --> E(block):::factor
    C(soil):::factor --- D(((nestet))) --> E
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

Wir wollen uns jetzt die Daten einmal selber erstellen und das R Paket `agricolae` nutzen um uns ein passendes Design zu bauen. Abschließend schauen wir uns den Versuchsplan einmal mit `desplot` an.

::: callout-tip
## Modell zur Auswertung

Wir rechnen ein multiples lineares Modell für die statistische Analyse.

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ soil + fert + soil:fert + block +, data = rcbd_3f_tbl)
```
:::

### ... mit `expand_grid()`

Bei dem *randomized complete block design* haben wir ja Glück, wir müssen nur darauf achten, das die einzelnen Beobachtungen innerhalb der Blöcke vollständig randomisiert sind. Daher Randomisieren wir ganz am Ende einmal die Saplte `fert` und die Spalte `soil` durch. Wir hätten uns das `mutate()` auch sparen können und stattdessen einfach die Funktion `slice_sample(prop = 1)` nutzen. Die Funktion permutiert dann alles innerhalb der gruppierten Blöcke durch. Mach wie es dir besser gefällt und du es besser nachvollziehen kannst.

```{r}
three_fct_long_tbl <- expand_grid(block = 1:2, soil = 1:4, fert = 1:6) %>% 
  mutate(block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4)),
         fert = factor(fert, label = str_c("fe_", 1:6))) %>% 
  group_by(block) %>% 
  mutate(fert = sample(fert), # Randomisierung fert
         soil = sample(soil)) # Randomisierung soil
three_fct_long_tbl
```

Jetzt mache ich es etwas anders bei der Erstellung des Grids der Spalten und Zeilen. Ich will später beim `desplot()` für die Blöcke durch `| block` separieren. Daher setzte ich die Spaltennummerierung `cols` jeweils auf 1 bis 4 und bilde die Blöcke durch ein davor geschaltetes `rep` ab. Wenn du die Variable `rep` nicht möchtest, kannst du auch die `cols` auf 1 bis 8 setzten, darfst dann aber nicht für die Blöcke durch `rep` separieren.

```{r}
three_fct_plot_tbl <- three_fct_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, cols = 1:4, rows = 1:6))
```

In der @fig-exp-adv-6 sehen wir dann einmal das *randomized complete block design* mit drei Faktoren einmal dargestellt. Wir sehen gut, wie die zwei Behandlungen vollständig randomisiert wurden. Beachte, dass die Farben den Faktor `soil` darstellen und die Labels dann den Faktor `fert`. Du kannst mit der Option `show.key = FALSE` auch die Legende ausschalten. Bei sehr komplexen Designs mit vielen Faktorstufen ist es dann doch mal ratsam, sich die Legende mit ausgeben zu lassen.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-6
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "Randomized complete block design (3-faktoriell) für die Faktoren Dünger `fert` sowie `soil` vollständig randomisiert in den beiden Blöcken."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", 
        col = soil, 
        data = three_fct_plot_tbl ,
        main = "Randomized complete block design (3-faktoriell)",
        show.key = TRUE)
```

Auch hier können wir dann den Versuchsplan relativ einfach raus schreiben. Ich entferne noch die Spalte `rep`, da ich die Spalte nicht weiter brauchen werde. Dann wären wir auch schon mit dem Design fertig.

```{r}
#| eval: false
#| message: false
#| warning: false
three_fct_plot_tbl %>% 
  select(-rep) %>% 
  write_xlsx("template_sheet.xlsx")
```

### ... mit `agricolae`

Jetzt bauen wir unser Design nochmal in `agricolae` nach. Hier brauchen wir dann aber alles als Vektor, sonst wird es zu unübersichtlich in den Funktionen. Darüber hinaus ist es dann auch mal was anders und du siehst nochmal eine andere Art den Code zu schreiben. Prinzipiell hätten wir auch im vorherigen Teil alles erstmal in Vektoren lagern können. Aber gut, hier erstmal alle Level der Faktoren vorbereiten und die Anzahl der Blöcke auf vier gesetzt. Dann brauchen wir noch die Länge der Level, also die Anzahl an Düngerstufen und Bodenarten. Dafür nutzen wir die Funktion `distinct_n()`.

```{r}
trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4
```

Dann können wir schon das *randomized complete block design* mit drei Faktoren über die Funktion `design.ab()` erstellen. Wie immer heißt die Wiederholung auch hier `r`, das ist zwar sehr einheitlich aber manchmal auch verwirrend. Auch musst die beiden Vektoren aneinanderkleben damit die Funktion funktioniert.

```{r}
rcbd_fac3_obj <- design.ab(trt = c(n_trt_fac2_fert, n_trt_fac1_soil), 
                           design = "rcbd",
                           r = n_block, 
                           seed = 42)
```

Dann können wir auch schon unser Ergebnis der Funktion einmal aufarbeiten. Wie immer fehlt das Positionsgrid, so dass wir hier nochmal tätig werden müssen. Dann wollen wir noch die Faktoren wieder umbenennen, so dass auch die Level passen. Am Ende wähle ich noch die Spalten aus, die wir dann später brauchen werden. Meistens müssen wir auch bei den komplexeren Designs und der Nutzung von `agricolae` im Nachgang sehr viel selber machen. Teilweise lohnt es sich da für mich nicht, für zwei Zeilen Code eine Funktion zu nutzen, der ich dann auch noch sehr viel Nachprogrammieren muss. Man merkt hier eben auch das Alter von dem R Paket `agricolae`.

```{r}
rcbd_fac3_book_tbl <- rcbd_fac3_obj$book %>%
  bind_cols(expand.grid(rows = 1:n_trt_fac2_fert,
                        cols = 1:(n_trt_fac1_soil*n_block))) %>% 
  mutate(trt_fac2_fert = str_c("fe_", A),
         trt_fac1_soil = str_c("soil_", B),
         block = paste0("Block ", block)) %>% 
  select(block, fert = trt_fac2_fert, soil = trt_fac1_soil, rows, cols)
```

Natürlich hat die Funktion auch keinen `sketch`, wenn man ihn braucht. Das haben wir ja jetzt schon selber mit dem Positionsgrid programmiert. In der @fig-exp-adv-2 siehst du dann das Ergebnis des Versuchsplans. Wir haben hier nochmal zwei Blöcke zusätzlich zu dem obigen Beispiel genommen, dann siehst du nochmal schöner, wie sich die beiden Behandlungen in den Blöcken randomisieren.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-2
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "Randomized complete block design (3-faktoriell) für die Faktoren Dünger `fert` sowie `soil` vollständig randomisiert in den vier Blöcken."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = rcbd_fac3_book_tbl,
        main = "Randomized complete block design (3-faktoriell)", 
        show.key = TRUE, key.cex = 1)
```

## Split plot design (3-faktoriell) {#sec-split}

Die Spaltanalse (eng. *split plot design*) ist eine häufig genutzte Variante, wenn wir eine Behandlungsfaktor nur in einem anderen Level eines zweiten Behandlungsfaktor randomisieren können. Wir können also eine Feldspur nur auf eine Art mechanisch bearbeiten und geben dann aber pro Feldspur verschiedene Dünger auf. Oder wir können in einen Stahl nur auf eine Art Futter zuführen, aber verschiedene Arten von Futter. Das gleiche kannst du dir auch mit einer Klimakammer vorstellen in der wir verschiedene Pflanzenlinien stellen können.

Beide Behandlungsfaktoren sind ineinander und dann natürlich im Block genestet. Hier aber erstmal das Modell mit den drei Faktoren für den besseren Überblick. Wir haben einmal die Düngung `fert`, dann den Faktor Boden `soil` sowie die verschiedenen Blöcke mit `block`.

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

mit

-   dem Faktor Dünger `fert` und den sechs Düngestufen als Level `fe_1` bis `fe_6`.
-   dem Faktor Boden `soil` und den vier Bodenarten als Level `soil_1` bis `soil_4`.
-   dem Faktor Block `block` und den zwei Leveln `block_1` und `block_2`.

In der @fig-mermaid-splitplot sehen wir die Abhängigkeitsstruktur des *split plot designs*. Wir haben den Faktor `fert` den wir in den Faktor `soil` nesten. Den Faktor `soil` nesten wir dann wiederrum in die Spalten `cols` des Blocks. Deshalb nennen wir das ja auch eine Spaltanlage. Ein Faktor ist immer in den Spalten angeordnet und der andere Faktor in der Spalte randomisiert. Wie immer wird es vielleicht klarer, wenn du dir dazu die @fig-exp-adv-5 als Ergebnis des Versuchsdesigns anschaust.

```{mermaid}
%%| label: fig-mermaid-splitplot
%%| fig-width: 6
%%| fig-cap: "Abhängigkeitsstruktur des *split plot design*. Der Faktor `soil` ist in den Spalten `cols` der Blöcke randomisiert und der zweite Faktor `fert` innerhalb des anderen Faktors und somit auch in den Spalten."
flowchart LR
    A(fert):::factor --- B(((nestet))) --> C(soil):::factor --- D(((nestet))) --> E(cols) --- F(block):::factor
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

::: callout-tip
## Modell zur Auswertung

Wir rechnen ein komplexeres gemischtes Modell mit allen möglichen zufälligen Effekten.

```{r}
#| eval: FALSE
fit <-  lmer(yield ~ soil + fert + soil:fert + 
               (1|block) + (1|block:fert) + (1|block:soil), 
             data = split_tbl)
```

Oder können überlegen ein gemischtes Modell mit weniger zufälligen Effekten zu rechnen.

```{r}
#| eval: FALSE
fit <-  lmer(yield ~ soil + fert + soil:fert + 
               (1|block), 
             data = split_tbl)
```

Die Entscheidung kannst du dann mit der [Modellselektion](https://jkruppa.github.io/stat-modeling-basic.html#sec-model-basic-compare) durchführen.
:::

Jetzt haben wir die volle Auswahl an Möglichkeiten. Ich zeige einmal wie man händisch das *split plot designs* erstellt. Dann schauen wir uns die Erstellung in `agricolae` einmal an und dann zeige ich noch die Variante in `dae`, die mich echt einiges an Zeit und Nerven gekostet hat. In sich ist das Paket `dae` ja logisch, aber die Dokumentation lässt für mich etwas zu wünschen übrig. Dennoch hier einmal die volle Dreifaltigkeit der Versuchsdesignerstellung, wenn ich mir schon die Mühe gemacht habe.

### ... mit `expand_grid()`

Ja, selber machen ist hier etwas mühsamer, aber wenn du die Schritte nachvollziehst, dann wird dir vermutlich das *split plot design* sehr viel klarer. Als erstes erschaffen wir die zwei Blöcke und die vier Bodenarten. Dabei sind in jedem Block die vier Bodenarten genestet. Dann gruppieren wir nach Block und randomiseren einmal die Bodenarten je Block. Im nächsten Schritt erweitern wir dann jede Block/Boden-Kombination um die sechs Düngerstufen. Dann gruppieren wir wieder, aber diesmal für jede Block/Boden-Kombination, um hier dann einmal die Düngestufen zu randomisieren. Dann lösen wir alle Gruppen auf und setzen fürunsere Faktoren dann noch die richtigen Labels.

```{r}
splitplot_long_tbl <- expand_grid(block = 1:2, 
                                  soil = 1:4) %>% 
  group_by(block) %>%             # Gruppieren nach block
  mutate(soil = sample(soil)) %>% # Randomisieren von soil in block
  expand_grid(fert = 1:6) %>%   
  group_by(block, soil) %>%       # Gruppieren nach block und soil
  mutate(fert = sample(fert)) %>% # Randomisieren von fert in block und soil
  ungroup() %>% 
  mutate(fert = factor(fert, label = str_c("fe_", 1:6)),
         block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4))) 
splitplot_long_tbl
```

Da ich auch gleich wieder für die Blöcke separieren möchte, baue ich mir für jeden Block `rep` nochmal vier Spalten, je eine Spalte für eine Bodenbehandlung, und dann nochmal sechs Zeilen, eine für jede Düngestufe. Dann verbinden wir den randomisirten Datensatz mit den Pflanzgrid und schon können wir uns das *split plot design* einmal anschauen.

```{r}
splitplot_plot_tbl <- splitplot_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, 
                        cols = 1:4, 
                        rows = 1:6))
```

In der @fig-exp-adv-5 siehst du einmal das *split plot design* dargestellt. Hier wird auch nochmal schön das Randomisierungsmuster klar. Du siehst auch warum das *split plot design* im Deutschen auch Spaltanlage heißt. Der Dünger ist in Spalten des Bodenfaktores randomisiert. Jeder Block hat also seine eigene Randomiserung der Böden.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-5
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "Split plot design (3-faktoriell) für die Faktoren Dünger `fert` sowie `soil` randomisiert in den zwei Blöcken. Der Faktor `fert` ist in dem Faktor `soil` genestet und randomisiert."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = splitplot_plot_tbl ,
        main = "Split plot design (3-faktoriell)",
        show.key = TRUE)
```

### ... mit `agricolae`

Jetzt machen wir das Ganze nochmal mit dem R Paket `agricolae`. Hier müssen wir wieder die Vektoren mit den Faktoren und Leveln vorab erschaffen. Auch brauchen wir die Anzahl an Leveln für jeden Faktor. Am Ende randomisieren wir hier mal in vier Blöcke, einfach um es etwas anders zu machen.

```{r}
trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4
```

Für die Erstellung des *split plot design* nutzen wir die Funktion `design.split()`. Hier ist es wichtig, unbedingt die `serie = 0` als Option zu setzen. Wir brauchen die so entstehende Information in der Spalte `plots` sonst klappt es im Folgenden nicht die `plots` gleich den Spalten `cols` zu setzen. Ja, ich weiß, ist alles super suboptimal, aber so ist es eben in `agricolae`. Du musst noch einges machen, damit die Funktion auch einen visualisierbare Ausgabe wiedergibt.

```{r}
splitplot_obj <- design.split(trt1 = trt_fac1_soil,
                              trt2 = trt_fac2_fert,
                              r = n_block,
                              seed = 42, serie = 0)
```

Leider gibt es kein `sketch`-Objekt gerade hier wo man eins gebrauchen könnte. Deshalb also nochmal alles umbauen und die Zeilen `rows` und Spalten `cols` entsprechend ergänzen. Ich nenne jetzt nochmal ein wenig die Variablen um, einfach damit hier nicht immer das Gleiche passiert. Wichtig ist, dass wir hier immer für die Blöcke separieren. Wir müssen also in `desplot` definitiv die Option `| block` setzen, sonst klappt es mit der Darstellung nicht.

```{r}
splitsplot_book_tbl <- splitplot_obj$book %>% 
  mutate(block = str_c("Block ", block),
         cols = plots, 
         rows = as.numeric(splots)) %>% 
  select(block, fert = trt_fac2_fert, soil = trt_fac1_soil, rows, cols)
```

In der @fig-exp-adv-3 siehst du das Ergebnis der Versuchsplanerstellung mit `agricolae`. Wir kriegen faktisch das Gleiche raus, gut die Faktoren sind anders permutiert, aber das wundert uns jetzt nicht. Am Ende musst du entscheiden, was dir besser gefällt. Je komplexer die Randomisierung ist, desto einfacher ist die Nutzung der `agricolae` Funktionen. Beim *split plot design* ist es so eine Sache, es lohnt sich bei sehr großen Anlagen dann schon.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-3
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "Split plot design (3-faktoriell) für die Faktoren Dünger `fert` sowie `soil` randomisiert in den vier Blöcken. Der Faktor `fert` ist in dem Faktor `soil` genestet und randomisiert."
desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = splitsplot_book_tbl ,
        main = "Split plot design (3-faktoriell)",
        show.key = TRUE)
```

### ... mit `dae`

Auch das R Paket `dae` liefert die Möglichkeit ein *split plot design* zu erstellen. Die Idee von `dae` ist ja ein mehr generalisiertes Framework für die Erstellung von Versuchsplänen anzubieten. Deshalb gibt es ja nur die Funktion `designRandomize()`, die ein gegebenes Design nach feststehenden Regeln randomisiert. Die IDee ist gut, aber dafür musst du dich realtiv tief in das Paket `dae` einarbeiten. Für mich war dieser kurze Code für das *split plot design* schon recht langwierig aus den Beispielen aus den [Notes on the use of dae for design](https://cran.r-project.org/web/packages/dae/vignettes/DesignNotes.pdf) herzuleiten. Prinzipiell ist es ja nicht schwer, aber es ist schon etwas mehr Auswand.

Wie funktioniert nun die Erstellung eines *split plot design*? Wir bauen uns erstmal unser Design der Positionen mit den Blöcken, Mainplots `MPlots` sowie den Subplot `SubPlots`. Dabei ist es wichtig zu wissen, dass die Subplots in den Mainplots genestet sind. Die Mainplots sind dann wiederum in den Blöcken genestet. Ja, hier hast du dann ein Paket spezifisches Naming der Optionen. Im zweiten Schritt packen wir dann den Faktor Boden `soil` und den Faktor `fert` zu den Positionen hinzu. Wichtig ist das `times = 4` am Ende, was nochmal die Faktorkombinationen von `soil` und `fert` jeweils in der Anzahl der Blöcke wiederholt. Wir haben ja hier vier Blöcke vorliegen, dass vergisst man ja mal schnell.

```{r}
split_sys <- cbind(fac.gen(list(Blocks = 4, MPlots = 4, SubPlots = 6)),
                   fac.gen(list(soil = str_c("soil_", 1:4),
                                fert = str_c("fe_", 1:6)), times = 4)) 
split_sys %>% 
  as_tibble()
```

An der Ausgabe siehst du ganz schön, wie die Spalte Mainplots zu dem Faktor `soil` passt sowie die Spalte Subplots zu dem Faktor `fert`. Die Herausforderung ist nun, dass das R Paket `dae` davon ausgeht, dass du weißt, was ein *split plot design* ist und wie es aufgebaut ist. Es gibt also wenig Hilfestellung innerhalb der Funktionen. Dafür sind die Funktionen super flexibel und du kannst dir deine eigenen kreativen Designs bauen - wovon ich abrate.

Im nächsten Schritt nutzen wir die Funktion `designRandomize()` um die Faktoren `soil` und `fert` den Positionen in der Spalte `Block`, `MPlots` und `SubPlots` randomisiert zuzuweisen. Deshalb sind ja auch die Faktoren `soil` und `fert` der Option `allocated` (deu. *zugeteilt*) zugewiesen, da die beiden Faktoren ja den Spalten `Block`, `MPlots` und `SubPlots` als Empfänger (eng. `recipient`) zugeteilt werden. Soweit so gut, dass sagt aber noch nichts über das *Wie* der Zuteilung aus. Das machen wir dann mit der Option `nestet.recipients`. Der Option sagen wir jetzt wer in was genestet ist. Und durch diese Zuordnung erschaffen wir ein *split plot design*. Die Mainplots sind in den Blöcken genestet und dann die Subplots in den Mainplots und den Blöcken. Ja, da muss man erstmal drauf kommen. Hat bei mir gedauert, bis ich das hingekriegt habe.

```{r}
split_lay <- designRandomize(allocated = split_sys[c("soil", "fert")],
                             recipient = split_sys[c("Blocks", "MPlots", "SubPlots")],
                             nestet.recipients = list(MPlots = "Blocks",
                                                      SubPlots = c("MPlots", "Blocks")),
                             seed = 235805)
split_lay %>% 
  as_tibble()
```

Und wir haben eine Randomisierung. Leider wissen wir nicht, ob die so geklappt hat, es ist ja wirklich schwer zusehen. Deshalb wollen wir uns die Ausgabe mal visualisieren. Das Gleiche Problem wie schon eben haben wir mit der Visualisierung mit `designGGPlot()`. Die Hilfeseite ist etwas unterkomplex für die Möglichkeiten der Funktion. So musste ich auch hier recht lange Rumspielen, bis ich die folgende @fig-exp-adv-4 erstellen konnte. Der Witz ist eigentlich hier, dass wir eine interne Funktion nutzen und auch das Objekt aus `designRandomize()` übergeben. Dennoch müssen wir uns selber mit den `row.factors()` und den `column.factors()` alles zusammenkleben.

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-4
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "foo."

designGGPlot(split_lay, labels = "fert", cellalpha = 0.75, cellfillcolour.column = "soil",
             row.factors = c("Blocks", "SubPlots"), column.factors = c("MPlots"),
             blockdefinition = rbind(c(6, 1)),
             blocklinecolour = "black", title = NULL)
```

## Subsampling {#sec-subsampling}

Die zentrale Idee des Subsamplings ist, dass wir nicht über die Pflanzen in unseren Blöcken mitteln. Wir nehmen also alle Pflanzen in unserem Block mit in die Analyse. Oder aber wir mitteln nicht das Gewicht der Ferkel für jede Bucht, sondern wollen die Gewichte individuell mit betrachten. Wir messen die Beobachtungen innerhalb der Behandlung und nehmen diese individuellen Beobachtungen auch mit ins Modell. Damit haben wir eigentlich das gleiche Modell wie auch bei dem RCBD mit zwei Faktoren. Nur das wir eben in den Blöcken und Behandlungen nicht einen Mittelwert über alles haben, sondern eben sechs individuelle Werte für die sechs Beobachtungen in einer Behandlung/Block-Kombination in unserem Beispiel.

Das generelle Modell unterscheidet sich nicht von einem RCBD. Wir haben zwei Faktoren, einmal die Behandlung und einmal einen Block vorliegen.

$$
y \sim \overbrace{trt}^{f_1} + \underbrace{block}_{f_2} 
$$

mit

-   dem Faktor Behandlung `trt` und den vier Behandlungsstufen als Level `ctrl`, `A`, `B` und `C`.
-   dem Faktor Block `block` und den vier Leveln `block_1` bis `block_4`.

```{mermaid}
%%| label: fig-mermaid-sub-1
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    A(trt):::factor --- B(((nestet))) --> C(block):::factor 
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

```{mermaid}
%%| label: fig-mermaid-sub-2
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    A(tray) --- B(((nestet))) --> C(trt):::factor --- D(((nestet))) --> E(cols) --- F(block):::factor
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

Jetzt kommt es darauf an, wie die individuellen Pflanzen in den Behandlungen stehen. Eventuell ist alles durcheinander gemischt, das heißt, die Pflanzen sind in den Behandlungen und Blöcken randomisiert. Dann ist es recht einfach mit einem linearen Modell zu machen.

Wenn du aber die Pflanzen in einem Pflanztray oder irgendwie anders fixierst hast, dann macht es schon einen Unterschied. In dem Fall sind die Pflanzen ja individuell nicht unabhängig voneinander. Die Pflanzen sind ja in einem Tray zusammen. Dann nutzen wir ein lineares gemischtes Modell.

Im Folgenden generieren wir einmal beide Fälle, wobei der zweite Fall - Pflanzen stehen zusammen - als Subsampling angesehen wird. Häufig kann dies auch bei Tierversuchen passieren, wenn zum Beispiel Ferkel in einer Bucht in einem Stahl stehen. Da aber ab und zu beides vorkommt, hier dann einmal beides. Wir können das Subsampling nur selber mit `expand_grid()` durchführen, da weder das R Paket `agricolae` noch das R Paket `dae` eine entsprechende Implementierung der Funkationalität zur Generierung eines Datensatzes mit Subsampling aufweist.

::: callout-tip
## Modell zur Auswertung

Vollständig im Block randomisiert, wir rechnen ein lineares Modell.

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ trt + block + trt:block, data = subsampling_tbl)
```

Behandlung im Block randomisiert, dass heißt, dass die Pflanzen zusammen in einem Tray stehen, wir rechnen ein gemischtes Modell. Der Tray-Effekt wird dann im zufälligen Effekt `(1 | trt:block)` modelliert.

```{r}
#| eval: FALSE
fit <- lmer(drymatter ~ trt + block + (1 | trt:block), data = subsampling_tbl)
```
:::

Das Subsampling geht nur im Selbermachen, also machen wir das dann einmal mit der Funktion `expand_grid()`. Als erstes erstellen wir einmal ein Design mit vier Blöcken und vier Behandlungen. Dann ergänzen wir noch pro Behandlung sechs individuelle Beobachtungen. Am Ende randomisieren wir einmal über die Behandlungen in den Blöcken. Wichtig ist hier, dass wir die Daten nach den Blöcken gruppieren müssen und schon vorher alle individuellen Pflanzen generieren.

```{r}
subsampling_long_tbl <- expand_grid(block = 1:4, 
                                    trt = 1:4,
                                    rep = 1:6) %>% 
  mutate(trt = factor(trt, labels = c("ctrl", "A", "B", "C")),
         block = factor(block, labels = str_c("Block ", 1:4)),
         pid = 1:n(),
         pid_text = str_pad(1:96, width = 2, pad = "0")) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) ## Randomisierung in den Blöcken
```

Dann bauen wir noch unser Grid auf. Wir wollen insgesamt sechzehn Spalten, dass sind die Blöcke/Behandlungs-Kombinationen. Dann brauchen wir noch jeweils sechs Zeilen für die individuellen Pflanzen. Dann können wir die Daten schon nehmen und in der @fig-exp-adv-10-1 visualisieren. Bevor wir die Abbildung besprechen, generieren wir uns nochmal die anderen Daten, wo die Behandlungen in den Blöcken randomisiert werden.

```{r}
subsampling_plot_tbl <- subsampling_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))
```

Eine andere Möglichkeit ist, dass unsere Pflanzen in einem Pflanztray stehen. Damit haben wir keine Randomisierung mehr in den Blöcken, sondern wir können nur unsere Behandlungen in den Blöcken randomisieren. Die Positionen in den Trays sind ja fix. Daher Randomisieren wir erst den Faktor der Behandlungen in den gruppierten Blöcken. Dann ergänzen wir noch die sechs individuellen Pflanzen.

```{r}

subsampling_tray_long_tbl <- expand_grid(block = 1:4, 
                                        trt = 1:4) %>% 
  mutate(trt = factor(trt, labels = trt_fac1_soil),
         block = factor(block, labels = str_c("Block ", 1:4))) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) %>% # Randomisierung der Behandlungen in den Blöcken
  expand_grid(rep = str_pad(1:6, width = 2, pad = "0"))

```

Jetzt bauen wir uns noch das Grid für die Positionen zusammen, da bleibt alles beim alten. Wir brauchen auch wieder sechzehn Spalten, dass sind die Blöcke/Behandlungs-Kombinationen. Dann noch die sechs Zeilen für das Pflanzentray. In der @fig-exp-adv-10-2 sehen wir einmal das Ergebnis der Randomisierung. Alle Pflanzen sind jetzt in einer Spalte randomisiert, die eben das Tray der Pflanzung entspricht.

```{r}
subsampling_tray_plot_tbl <- subsampling_tray_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))
```

In der @fig-exp-adv-10 sehen wir nochmal die beiden Arten des Subsamplings miteinander vergleichen. In der @fig-exp-adv-10-1 sind alle Behandlungen mit ihren sechs Wiederholungen zufällig im Block verteilt. Im anderen Fall sehen wir in der @fig-exp-adv-10-2, wenn die Pfanzen zusammen in einem Tray stehen und alle die gleiche Behandlung kriegen. Es können aber auch Schweine in einer Bucht sein und die Blöcke sind dann die einzelnen Ställe.

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-10
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "Verschiedene Arten des Subsamplings. Einmal vollständig innerhalb der Blöcke randomsiert und einmal die Behandlung randomisiert."
#| fig-subcap: 
#|   - "... vollständig innerhalb Block randomisiert (`subsampling_plot_tbl`)."
#|   - "... Behandlungen innerhalb Block randomisiert (`subsampling_tray_plot_tbl`)."
#| layout-nrow: 1
#| column: page

desplot(data = subsampling_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell, vollständig randomisiert)", 
        text = pid_text, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 

desplot(data = subsampling_tray_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        #out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell, Behandlung randomisiert)", 
        text = rep, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 

```

## Incomplete block design {#sec-incomplete}

Einmal als 3-faktorielles Design

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

mit

-   dem Faktor Dünger `fert` und den sechs Düngestufen als Level `fe_1` bis `fe_6`.
-   dem Faktor Boden `soil` und den vier Bodenarten als Level `soil_1` bis `soil_4`.
-   dem Faktor Block `block` und den zwei Leveln `block_1` und `block_2`.

```{mermaid}
%%| label: fig-mermaid-incomplete-1
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    A(fert):::factor -.- B(((nestet))) -.-> E(block):::factor
    C(soil):::factor -.- D(((nestet))) -.-> E
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

Einmal als 2-faktorielles Design

$$
y \sim \overbrace{trt}^{f_1} + \underbrace{block}_{f_2} 
$$

```{mermaid}
%%| label: fig-mermaid-incomplete-2
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    C(trt):::factor -.- D(((nestet))) -.-> E(block):::factor
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

::: callout-tip
## Modell zur Auswertung

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ trt + cols + rows, data = lsd_tbl)
```
:::

### ... mit `expand_grid()` (3-faktoriell)

```{r}
incomplete_long_tbl <- expand_grid(block = 1:2, soil = 1:4, fert = 1:6) %>% 
  mutate(block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4)),
         fert = factor(fert, label = str_c("fe_", 1:6))) %>% 
  group_by(block) %>% 
  mutate(fert = sample(fert),
         soil = sample(soil)) 

incomplete_long_tbl
```

```{r}
incomplete_plot_tbl <- incomplete_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, cols = 1:4, rows = 1:6)) %>% 
  filter(rows <= 4)
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-7
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "foo."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = incomplete_plot_tbl,
        main = "Incomplete block design (3-faktoriell)",
        show.key = TRUE)
```

```{r}
#| eval: false
#| message: false
#| warning: false
incomplete_plot_tbl %>% 
  select(-rep) %>% 
  write_xlsx("template_sheet.xlsx")
```

### ... mit `agricolae` (2-faktoriell)

```{r}
#| message: false
#| warning: false
bib_obj <- design.bib(trt = c("ctrl", "A", "B", "C"),
                      k = 3, seed = 543, serie = 2)
```

```{r}
bib_book_tbl <- bib_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "block", "trt"))
bib_book_tbl
```

```{r}
bib_plot_tbl <- bib_book_tbl %>%
  mutate(cols = as.numeric(block)) %>% 
  group_by(cols) %>% 
  mutate(rows = 1:n())
```

```{r}
bib_obj %>% 
  pluck("sketch") %>% 
  t()
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-8
#| fig-align: center
#| fig-height: 3
#| fig-width: 6
#| fig-cap: "foo."
desplot(trt ~ cols + rows, flip = TRUE,
        text = trt, cex = 1, shorten = "no",
        out1 = block,
        data = bib_plot_tbl,
        main = "Incomplete block design (2-faktoriell)", 
        show.key = FALSE)
```

## Strip plot design (3-faktoriell) {#sec-strip-plot}

Das Streifenparzellenversuch (eng. *strip plot design*) orientiert sich an dem [Strip-plot experiment of rice](https://kwstat.github.io/agridat/reference/gomez.stripplot.html) aus @gomez1984statistical. Du findest dann das Datenbeispiel auch in `agridat` als `data(gomez.stripplot)`. Ich habe versucht jetzt die Daten in der Form nachzubauen und somit kannst du dann auch ähnliche Experimente planen.

Ein Streifenparzellenversuch (eng. *strip plot design*) mit drei Wiederholungen `block`, Sorte `trt_gen` als horizontaler Streifen und Stickstoffdünger `trt_nitro` als vertikaler Streifen.

$$
y \sim \overbrace{trt_{gen}}^{f_1} + \underbrace{trt_{nitro}}_{f_2} + \overbrace{block}^{f_3}
$$

mit

-   dem Faktor Behandlung `trt_gen` und den sechs Linien als Level `G_1` bis `G_6`.
-   dem Faktor Dünger `trt_nitro` und den drei Düngestufen als Level `0`, `60` und `120`.
-   dem Faktor Block `block` und den drei Leveln `1` bis `3`.

```{mermaid}
%%| label: fig-mermaid-stripplot
%%| fig-width: 6
%%| fig-cap: "text"
flowchart LR
    A(trt_gen):::factor --- B(((nestet))) ---> C(rows) --- E(block):::factor
    F(trt_nitro):::factor --- G(((nestet))) ---> H(cols) --- E
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

::: callout-tip
## Modell zur Auswertung

```{r}
#| eval: FALSE
fit <- lmer(yield ~ trt_gen + nitro + trt_gen:nitro + 
              (1 | block) + (1 | block:nitro) + 
              (1 | block:trt_gen), 
            data = stripplot_tbl)
```
:::

```{r}
trt_gen <- str_c("G", 1:6)
n_trt_gen <- n_distinct(trt_gen)
trt_nitro <- c(0, 60, 120)
n_trt_nitro <- n_distinct(trt_nitro)
n_block <- 3
```

Erst der kurze Vektor dann der lange

```{r}
strip_obj <- design.strip(trt1 = trt_nitro, 
                          trt2 = trt_gen, 
                          r = n_block, serie = 2, seed = 543)
```

```{r}
strip_plot_tbl <- strip_obj$book %>% 
  bind_cols(expand_grid(cols = 1:(n_trt_nitro*n_block), rows = 1:n_trt_gen))
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-9
#| fig-align: center
#| fig-height: 5
#| fig-width: 7
#| fig-cap: "foo."
desplot(trt_gen ~ cols*rows,
        out1 = block, 
        out2 = trt_nitro, out2.gpar = list(col = "grey", lty = 1), 
        col.regions = cbbPalette, 
        text = trt_nitro, cex = 1,
        show.key = TRUE, data = strip_plot_tbl, shorten = "no",
        main = "Strip plot design (3-faktoriell)")
```

## Referenzen {.unnumbered}
