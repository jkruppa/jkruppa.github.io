```{r echo = FALSE}
#| message: false
#| echo: false
#| warning: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc, plyr, broom,
               patchwork, ggforce, see, sjPlot, tinytable, conflicted)
set.seed(202434)
conflicts_prefer(dplyr::summarise)
conflicts_prefer(dplyr::summarize)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(dplyr::select)
conflicts_prefer(magrittr::set_names)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::desc)
source("stat-tests-anova_plot/repeated_plots.R")
```

# Die repeated / mixed ANOVA {#sec-anova-mixed}

*Letzte Änderung am `r format(fs::file_info("stat-tests-anova-mixed.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

> *"I never once failed at making a light bulb. I just found out 99 ways not to make one." --- Thomas A. Edison*

![](images/caution.png){fig-align="center" width="100%"}

::: {.callout-caution appearance="simple"}
## Stand des Kapitels: Konstruktion (seit 02.2025)

Dieses Kapitel wird in den nächsten Wochen geschrieben. Ich plane zum Ende des SoSe 2025 eine neue Version des Kapitels erstellt zu haben. Während das Kapitel entsteht, funktioniert so manaches dann nicht so wie es soll.
:::

In diesem Kapitel soll es dann um Messwiederholungen gehen. Wir haben also irgendwas wiederholt gemessen. Damit haben wir auch eine Zeitvariable mit in den Daten. Hier müssen wir dann etwas aufpassen, ob wir wirklich eine repeated oder mixed ANOVA rechnen wollen oder nicht doch irgendwie eine Zeitreihe vorliegen haben. Die Frage, die du dir stellen musst ist hierbei eigentlich recht einfach. Wenn du ein Interesse an einem wie auch immer gearteten Gruppenvergleich hast und du diese Gruppen über die Zeit gemessen hast, dann bist du hier in diesem Kapitel richtig. Wenn es um eine ANOVA geht, dann geht es auch immer um einen Gruppenvergleich. Ansonsten könntest du eine Prognose wollen und das wäre dann eher eine klassische Zeitreihe.

::: {layout="[15,85]" layout-valign="top"}
![](images/angel_01_small.png){fig-align="center" width="100%"}

> Hier eine kurze Warnung. Häufig wird die repeated und die mixed ANOVA in einen Topf geworfen. Die beiden Verfahren unterscheiden sich aber konzeptionell. Darüber hinaus hast du meistens in den Agrarwissenschaften eine mixed ANOVA vorliegen, wenn du mit Messwiederholungen gearbeitet hast und keine repeated ANOVA.
:::

## Allgemeiner Hintergrund

Die gemischte ANOVA (eng. *mixed ANOVA*) und die ANOVA für Messwiederholungen (eng. *repeated ANOVA*) sind eng miteinander verwandt. Vermutlich ist dies auch der Grund, warum es bei beiden Verfahren so viele Verwirrungen gibt. Ebenso finden sich auch verschiedene Namen zu den beiden ANOVA Algorithmen, aber wir bleiben einmal hier bei den beiden Namen. Die beiden Verfahren basieren auf Messwiederholungen. Daher messen wir wiederholt an einer Beobachtung einen Messwert. Der Unterschied liegt in dem Versuchsdesign und welche Beobachtung welche Behandlung erhält. Wir haben haben meistens in den Agrarwissenschaften eine *mixed ANOVA* vorliegen.

Was haben die *mixed ANOVA* und die *repeated ANOVA* gemeinsam?

:   In beiden Fällen haben wir Messwiederholungen in unseren Daten. Das heißt, wir messen wiederholt an dem gleichen Subjekt einen Messwert. Wir messen also weiderholt die Größe einer Pflanze oder die Milchleistung einer Kuh.

Oder um den Sachstand nochmal mit einem Zitat zu untermauern, habe ich aus dem Handbuch der SPSS Statistik einmal folgende Einordnung gefunden. Hier ist nochmal wichtig, was eigentlich mit den einzelnen Beobachtungen (eng. *subject*) passiert.

> *"However, the fundamental difference is that in a mixed ANOVA, the subjects that undergo each condition (e.g., a control and treatment) are different, whereas in a two-way repeated measures ANOVA, the subjects undergo both conditions (e.g., they undergo the control and the treatment)."* --- [Two-way repeated measures ANOVA using SPSS Statistics](https://statistics.laerd.com/spss-tutorials/two-way-repeated-measures-anova-using-spss-statistics.php#:~:text=A%20mixed%20ANOVA%20is%20very,factors%20on%20the%20dependent%20variable.)

Das klingt jetzt etwas kompliziert und deshalb habe ich dir den Zusammenhang einmal in der folgenden @fig-ggplot-theo-intro visualisiert. Nehmen wir einmal an, du hast einen Behandlungsfaktor $f_A$ mit drei Leveln. Jedes Level steht für eine Art der Behandlung. Wenn wir uns jetzt eine mixed ANOVA anschauen, dann haben wir drei Individuen vorliegen, die wiederholt in der gleichen Art der Behandlung gemessen werden. Das Individium mit der $ID_1$ erhält nur die Behandlung $A.3$ wiederholt verabreicht oder steht unter dieser Behandlung. Dann messen wir wiederholt den Messwert.

Etwas anders sieht es dann bei der repeated ANOVA aus. Hier haben wir ein Individum was alle Behandlungen über alle Zeitpunkte erhält. Damit erhät das Individium $ID_1$ erst die Behandlung $A.3$ viermal und danach dann die beiden anderen Behandlungen auch jeweils viermal wiederholt gemessen. Das ist ein großer konzeptioneller Unterschied in dem Versuchsdesign zwischen der mixed und der repeated ANOVA. In beiden ANOVA Typen wird wiederholt gemessen. In der repeated ANOVA erhält jedes Individum aber auch alle Behandlungen über die Zeit.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-intro
#| fig-align: center
#| fig-height: 6
#| fig-width: 7
#| fig-cap: "Konzeptionelle Darstellung der mixed und repeated ANOVA in einem Flussdiagramm mit unterschiedlichen Individuen für einen Behandlungsfaktor mit drei Leveln als Arten der Behandlung. **(A)** In der mixed ANOVA werden pro Art der Behandlung ein Individum wiederholt gemessen. **(B)** In der repeated ANOVA wird ein Individum wiederholt für jede Art der Behandlung gemessen. *[Zum Vergrößern anklicken]*"

mixed_theo_fac2_p + repeated_theo_fac2_p +
  plot_layout(ncol = 1) +
  plot_annotation(tag_levels = 'A') +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))

```

Bevor wir jetzt weiter in das Modell und die einzelnen Besonderheiten der mixed ANOVA und repeated ANOVA einsteigen nochmal der Hinweis, dass wir hier natürlich auch wieder *nur* global einen Fakor testen. Das heißt, du weißt natürlich wieder nicht, welcher paarweise Vergleich innerhalb eines Faktors einen signifikanten Unterschied ausmacht, wenn du eine signifikante ANOVA vorliegen hast. Dann musst du wieder weiter machen mit einem Post-hoc Test. Auch hier hilft nochmal die Vingette von `{afex}` mit [ANOVA and Post-Hoc Contrasts](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html). Oder wie es @gueorguieva2004move mit der wissenschaftlichen Veröffentlichung [Move Over ANOVA](https://jamanetwork.com/journals/psych/articlepdf/481967/ynv20002.pdf?casa_token=5gc0qQuqNFUAAAAA:SJWnX8rH6__-lxXqiF0FDGQISXgXE0JQlRgtY7EE76IFnuECNjsOvKzUIwu9hmZFrKdLJbIahfQ) und der Nutzung von linearen gemischten Modellen wie folgt beschreibt.

> *"Mixed-effects models use all available data, can properly account for correlation between repeated measurements on the same subject, have greater flexibility to model time effects, and can handle missing data more appropriately. Their flexibility makes them the preferred choice for the analysis of repeated measures data"* --- @gueorguieva2004move

Warum machen wir das nicht immer? Also wir nutzen immer ein lineares gemischtes Modell? Das hat meistens mit der geringen Anzahl an Beobachtungen in den Gruppen und allgemein mit zu wenigen Gruppen zu tun. Häufig reicht eben das Design und die Wiederholungen nicht aus für ein sauberes gemischtes Modell. Deshab ist dann eine Lösung sich die Sachlage einmal in einer mixed oder repeated ANOVA anzuschauen. Es gilt wie immer, komplexe Fragestellungen kann man meistens nicht in einem einfachen Satz beantworten. Hier kommt es dann auch wieder auf die konkrete Fragestellung an.

#### Welche Pakete gibt es eigentlich? {.unnumbered .unlisted}

Wenn um die Anwendung der mixed oder repeated ANOVA in R geht, dann haben wir eine Menge Pakete zur Auswahl. Wie immer macht die Fragestellung und das gewählte Modell den Großteil der Entscheidungsindung aus. Ich zeige dir später in der Anwendung dann auch alle Pakete einmal, gebe dir dann aber auch immer eine Empfehlung mit. Normalerweise brauchen wir einen normalverteilten Messwert $y$ und Varianzhomogenität in den Faktoren. In den letzten Jahren wurden aber noch weitere Implementierungen der ANOVA entwickelt, so dass hier auch Alternativen vorliegen.

Gehen wir jetzt mal die Pakete durch. Wir immer gibt es einiges an Möglichkeiten und ich zeige dir hier eben die Auswahl. Es gibt hier das ein oder andere noch zu beachten, aber da gehe ich dann bei den jeweiligen Methoden drauf ein. Es macht eben dann doch einen Unterschied ob ich eine einfaktorielle oder komplexere ANOVA rechnen will. Nicht alles geht in allen R Pakten oder gar Excel.

Der Standard mit der Funktion `aov()` aus `{base}`

:   Die Standardfunktion `aov()` erlaubt es eine mixed oder repeated ANOVA direkt auf einem Datensatz zu rechnen. Hier brauchen wir nur ein Modell in der in R üblichen Formelschreibweise `y ~ f`. Du kannst diesen Ansatz als schnelle ANOVA begreifen. Dein Messwert $y$ muss hier normalverteilt sein.

Mit der Funktion `anova_test()` aus `{rstatix}`

:   Das [R Paket `{rstatix}`](https://cran.r-project.org/web/packages/rstatix/index.html) bietet bietet die Funktion `anova_test()` die es erlaubt einfacher auf die Funktionalität der Funktion `aov()` und R Funktionen aus dem Paket `{car}` zuzugreifen. Es ist eben ein klassischer Wrapper um besser rechnen zu können. Aber auch hier musst du verstehen wie die Funktion funktioniert. Ich finde aber die Anwendung relativ einfach und deshalb zeige ich die Funktion hier einmal.

Mit den ANOVA Funktionen aus `{afex}`

:   Wir können die mixed oder repeated ANOVA anwenden, wenn wir Messwiederholungen vorliegen haben. Daher bietet sich hier insbesondere das [R Paket `{afex}`](https://github.com/singmann/afex) an. Du musst bei den Funktionen von `{afex}` immer eine ID mitlaufen lassen, die angibt welche Individuen wiederholt gemessen wurden. Also hat jede Zeile eine Nummer, die beschreibt welche Beobachtung hier vorliegt. Besonders wichtig bei Messungen über die Zeit. Darüber hinaus kann das Paket sehr gut Interaktionen schätzen und Bedarf dort keiner zusätzlichen Optionen. Auch hier hilft nochmal die Vingette von `{afex}` mit [ANOVA and Post-Hoc Contrasts](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html) weiter, wenn es um den Post-hoc Test geht.

Mit den ANOVA Funktionen aus `{MANOVA.RM}`

:   [Das R Paket `{MANOVA.RM}`](https://cran.r-project.org/web/packages/MANOVA.RM/vignettes/Introduction_to_MANOVA.RM.html) von @friedrich2019resampling bietet eine weitere Möglichkeit die reapted und mixed ANOVA zu rechnen, wenn die Annahme an die Normalverteilung sowie der Varianzhomogenität nicht erfüllt ist. Wir haben es hier dann nochmal mit einer neueren Implementierung zu tun. Eine weitere robuste Alternative zu den Standardimplementierungen.

Mit den ANOVA Funktionen aus `{WRS2}`

:   Eine Annahme an die mixed oder repeated ANOVA ist, dass wir es mit normalverteilten Messwerten $y$ sowie Varianzhomogenität in den Faktoren $f$ vorliegen haben. Das R Paket `{WRS2}` mit der hervorragenden Vingette [Robust Statistical Methods Using WRS2](https://cran.r-project.org/web/packages/WRS2/vignettes/WRS2.pdf) erlaubt nun aber diese beiden Annahmen zu umgehen und bietet eine robuste ANOVA an. Robust meint hier, dass wir uns nicht um die Normalverteilung und Varianzhomogenität kümmern müssen.

Wir immer ist es hier ein Tutorium um gleich mit der ANOVA starten zu können. Wenn du tiefer in die Materie einsteigen möchtest und noch andere Dinge rechts und links anschauen willst, dann findest du in den folgenden Quellen nochmal mehr Anregungen. Es geht wie immer mehr, aber wir wollen hier dann ja auch fertig werden und haben beschlossen eine repeated oder mixed ANOVA zu rechnen.

::: callout-tip
## Weitere Tutorien für die repeated & mixed ANOVA

Wir oben schon erwähnt, kann dieses Kapitel nicht alle Themen der repeated und mixed ANOVA abarbeiten. Insbesondere der theoretische Hintergrund ist ja bei mir hier sehr gekürzt. Daher präsentiere ich hier eine Liste von Literatur und Links, die mich für dieses Kapitel hier inspiriert haben. Nicht alles habe ich genutzt, aber vielleicht ist für dich was dabei.

-   Im Tutorium zur [Repeated Measures ANOVA in R](https://www.datanovia.com/en/lessons/repeated-measures-anova-in-r/) und [Mixed ANOVA in R](https://www.datanovia.com/en/lessons/mixed-anova-in-r/) auf der Seite Datanovia wird nochmal mehr auf die möglichen Vortest der Annahmen eingegangen. Auch wird nochmal der Posthoc-Test gezeigt, den ich ja ausgelagert habe.
-   Das Kapitel zu den [Random Effects](https://bookdown.org/steve_midway/DAR/random-effects.html) aus dem Openbook Data Analysis in R gibt nochmal einen Einblick in die Idee der zufälligen Effekte, die wir hier bewusst etwas unter den Tisch fallen lassen.
-   Das Openbook ANOVA and Mixed Models A Short Introduction Using R gibt in dem Kapitel zu [Random and Mixed Effects Models](https://people.math.ethz.ch/~meier/teaching/anova/random-and-mixed-effects-models.html) nochmal eine Übersicht über die verschiedenen Modelle. Insbesondere der Theorieteil ist gut, da ich ja hier in diesem Kapitel aktuell auf eine theoretische Betrachtung verzichtet habe.
-   Wenn dich die Formelschreibweise in R verwirrt, dann hilft dir nochmal der Blogeintrag zu [ANOVA and other models, mixed and fixed](https://conjugateprior.org/2013/01/formulae-in-r-anova/).
:::

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
#| warning: false
pacman::p_load(tidyverse, magrittr, broom, WRS2, scales,
               readxl, see, car, patchwork, rstatix, emmeans,
               interactions, effectsize, afex, report, multcomp,
               janitor, MANOVA.RM, conflicted)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(dplyr::summarize)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::arrange)
conflicts_prefer(dplyr::select)
conflicts_prefer(magrittr::set_names)
conflicts_prefer(magrittr::extract)
conflicts_prefer(effectsize::eta_squared)
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

An der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.

## Daten

Beginnen wir wie immer mit den Daten. Hier ist die Besonderheit, dass wir immer Messweiderholungen an einer Beobachtung vorliegen haben. Ich habe dann die jeweilige Beobachtung in der Spalte `.id` jeweils genau benannt. Daher kommt eben die Beobachtung mit der `id` gleich 1 mehrfach in den Daten vor. Genauer, wir haben eben nicht nur eine Zeile in den Daten für eine Beobachtung sondern mehrere Zeilen für eine Beobachtung vorliegen. Das ist am Anfang immer etwas verwirrend, aber man gewöhnt sich daran.

Eine weitere Besonderheit ist, dass wir häufig die Daten in einem Wide-Format erstellen. Das geißt wir haben pro Zeile eine ID und dann mehrere Spalten wo wir wiederholt messen. Wir nennen dann diese Spalten meistens `t0` bis `t5`, wenn wir sechs Zeitpunkte bemessen. In R brauchen wir dann doch wieder das Long-Format und dementsprechend nutzen wir die Funktion `pivot_longer()` um uns aus den Daten im Wide-Format die entsprechenden Daten im Long-Format zu bauen. Das Openbook [R for Data Science](https://r4ds.hadley.nz/data-tidy.html#sec-pivoting) hat hier noch das passende Kapitel zum nachlesen. Du kannst auch das [Cheatsheet](https://tidyr.tidyverse.org/#cheatsheet) nochmal anschauen, dort wird alles nochmal visuell erklärt.

### Mixed ANOVA

Bei der mixed ANOVA haben wir mindestens ein zweifaktorielles Design vorliegen. Warum ist das so? Zum einen brauchen wir einen Behandlungsfaktor und dazu kommt dann noch der Faktor der Messwiederholung. Wir messen ja wiederholt und dieses wiederholte Messen kommt dann ebenfalls in einen Faktor rein. Somit haben wir einen Behandlungsfaktor und einen Zeitfaktor in den Daten. Manchmal erhöhen wir noch die Komplexität und ergänzen einen zweiten Behandlungsfaktor und haben dann einen dreifaktoriellen Datensatz vorliegen.

#### Zweifaktoriell {.unnumbered .unlisted}

Im Folgenden siehst du einmal einen Datensatz für eine zweifaktorielle mixed ANOVA. In diesem Beispiel schauen wir uns nur Katzenflöhe an. Wir haben in dem Datensatz einmal den Faktor `feeding` als die Fütterungsarten mit einer Kontrolle als Zuckerwasser, Blut und einmal Ketchup sowie als zweiten Faktor die verschiedenen Zeitpunkte der Messung der Sprungweite in \[cm\]. Wir haben an insgesamt sechs Zeitpunkten wiederholt die Sprungweite gemessen. Wir wollen nun wissen, in wie weit sich die Sprungweite über die Zeit für die drei Floharten ändert.

```{r}
mixed_fac2_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                             sheet = "mixed-fac2") |> 
  select(.id, feeding, t0:t5) |> 
  pivot_longer(cols = t0:t5,
               values_to = "jump_length",
               names_to = "time_fct") |> 
  mutate(feeding = as_factor(feeding),
         time_fct = as_factor(time_fct),
         jump_length = round(jump_length, 2),
         .id = as_factor(.id))
```

In der folgenden Tabelle siehst du einmal die rohen Daten eingelesen. Wir haben den Faktor `feeding` sowie die sechs Zeitpunkte der Messung der Sprungweite in \[cm\]. Wir müssen uns dann in R die Daten über die Funktion `pivot_longer()` in ein Long-Format umwandeln.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-mixed-table-fac2
#| tbl-cap: "Rohdaten der Sprungweiten in [cm] gemessen an sechs Zeitpunkten von drei Fütterungsarten im Wide-Format für die bessere Übersicht."

repeated_raw_tbl <- read_excel("data/fleas_complex_data.xlsx", sheet = "mixed-fac2") |> 
  select(.id, feeding, t0:t5) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(repeated_raw_tbl, n = 4),
      rep("...", times = ncol(repeated_raw_tbl)),
      tail(repeated_raw_tbl, n = 4)) |> 
  tt(width = 1, align = "c", theme = "striped")
```

Jetzt habe ich dir in der folgenden Abbildung auch nochmal das Versuchsdesign aufgezeigt. Wie du siehst, haben wir immer einen Floh, der eine Behandlung mit einer Fütterungsart erhält. Dieser Flog springt dann zum Beispiel unter der Fütterung mit Ketchup sechs Mal und wir notieren jedesmal die Sprungweite zu den Messzeitpunkten.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-mixed-fac2
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Versuchsdesign der zweifaktoriellen mixed ANOVA. Der erste Faktor ist die Fütterungsart `feeding`. Jeder Floh erhält eine Fütterung und anschließend wird sechs mal die Sprungweite gemessen. Hier sind nur vier Zeitpunkte dargestellt. *[Zum Vergrößern anklicken]*"

mixed_fac2_p
```

In der folgenden Abbildung siehst du dann nochmal den Zusammenhang zwischen der Sprungweite in \[cm\] der Katzenflöhe unter unterschiedlichen Fütterungsarten. Dabei wurden die Flöhe wiederholt an sechs Zeitpunkten gemessen. Wir du siehst, fällt mit der Zeit die Sprungleistung ab. Die Katzenflöhe springen unabhängig von der Fütterungsart weniger weit mit der Zeit. Am letzten Zeitpunkt scheinen die Flöhe unter Ketchupernährung dann wieder etwas weiter zu springen. Jetzt müssen wir aber einmal statistisch Nachweisen, ob wir hier wirklich einen signifikanten Zusammenhang und Unterschiede zwischen den Fütterungsarten vorliegen haben.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-anova-mixed-fac2
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Darstellung des Zusammenhangs zwischen der Fütterung von Katzenflöhen und der gemessenen Sprungweite in [cm] über sechs Messzeitpunkte. Die Linie stellt den jeweiligen Mittelwert zu dem Zeitpunkt und der Fütterungsart dar. *[Zum Vergrößern anklicken]*"

ggplot(mixed_fac2_tbl, aes(x = time_fct, y = jump_length, 
                           color = feeding, group = feeding)) +
  theme_minimal() +
  geom_point2() +
  stat_summary(fun = "mean", geom = "line", size = 1) +
  scale_color_okabeito() +
  theme(legend.position = "top") +
  labs(x = "Zeitpunkte der Messung", y = "Sprungweite in [cm]",
       color = "Fütterungsart")
```

#### Dreifaktoriell {.unnumbered .unlisted}

Für unser dreifaktorielles Beispiel erweiter wir einmal den Datensatz um ein Workout für die Katzenflöhe. Neben den drei Fütterungsarten Kontrolle mit Zuckerwasser, Blut sowie Ketchup mussten die Flöhe als zweiten Faktor noch ein Workout bestehen. Dabei haben nicht alle Katzenflöhe jeweils trainiert, sondern wir haben eine untrainierte Gruppe sowie eine trainierte Gruppe. Beide Gruppen des Workout wurden dann mit allen drei Fütterungsarten gefüttert. Dann wurden insgesamt zu sechs Zeitpunkten die Sprungweite in \[cm\] bestimmt. Wir haben es daher mit einem dreifaktoriellen Datensatz zu tun, da wir zwei Behandlungsfaktoren sowie den Faktor der Messwiederholungen in unseren Daten vorliegen haben.

```{r}
mixed_fac3_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                             sheet = "mixed-fac3") |> 
  select(.id, feeding, workout, t0:t5) |> 
  pivot_longer(cols = t0:t5,
               values_to = "jump_length",
               names_to = "time_fct") |> 
  mutate(feeding = as_factor(feeding),
         workout = as_factor(workout),
         time_fct = as_factor(time_fct),
         jump_length = round(jump_length, 2),
         .id = as_factor(.id))
```

In der folgenden Tabelle sind die Daten dann nochmal im Wide-Format dargestellt. Wir haben hier dann pro Floh jeweils eine Faktorkombination aus der Fütterungsart `feeding` sowie dem Traingsstatus `workout`. Im Anschluss haben wir dann die Sprungweite von jedem Floh sechsmal gemessen. Wir müssen dann in R die Daten nochmal in das Long-Format über die Funktion `pivot_longer()` umbauen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-mixed-table-fac3
#| tbl-cap: "Rohdaten der Sprungweiten in [cm] gemessen an sechs Zeitpunkten von drei Fütterungsarten sowie dem Status des Workouts im Wide-Format für die bessere Übersicht."

repeated_raw_tbl <- read_excel("data/fleas_complex_data.xlsx", sheet = "mixed-fac3") |> 
  select(.id, feeding, workout, t0:t5) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(repeated_raw_tbl, n = 4),
      rep("...", times = ncol(repeated_raw_tbl)),
      tail(repeated_raw_tbl, n = 4)) |> 
  tt(width = 1, align = "c", theme = "striped")
```

Manchmal ist es schwer die Zusammenhänge dann in dem Datensatz zu sehen, deshalb hier nochmal das Versuchsdesign visualisert. Jeder Katznfloh springt wiederholt, aber das ganz dann nur unter einer Faktorkombination.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-mixed-fac3
#| fig-align: center
#| fig-height: 5.5
#| fig-width: 7
#| fig-cap: "Versuchsdesign der dreifaktoriellen mixed ANOVA. Der erste Faktor ist die Fütterungsart `feeding`. Der zweite Faktor der Status des Workouts für jeden Floh `workout`. Jeder Floh erhält eine Fütterung sowie ein Workout und anschließend wird sechs mal die Sprungweite gemessen. Hier sind nur vier Zeitpunkte dargestellt. *[Zum Vergrößern anklicken]*"

mixed_fac3_p
```

Abschließend können wir uns dann nochmal die Daten in der folgenden Abbildung anschauen. Auf den ersten Blick sehen wir, dass die Leistung in der Sprungweite über die Zeit abfällt. Diesen Trend können wir über alle Fütterungsarten beobachten. Was erst auf den zweiten Blick auffällt ist, dass teilweise ja nach Fütterungsart ein Training positiv oder negativ ausfällt. So führt ein Training bei den Kontrollflöhen zu weiteren Sprüngen. Die Katzenflöhe unter einer Blutdiät springen jedoch unter Training nicht so weit wie ohne ein Training.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-anova-mixed-fac3
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Darstellung des Zusammenhangs zwischen der Fütterung von Katzenflöhen sowie der Trainingszustand und der gemessenen Sprungweite in [cm] über sechs Messzeitpunkte. Die Linie stellt den jeweiligen Mittelwert zu dem Zeitpunkt und der Fütterungsart sowie des Trainings dar. *[Zum Vergrößern anklicken]*"

ggplot(mixed_fac3_tbl, aes(x = time_fct, y = jump_length, shape = workout,
                           color = feeding, linetype = workout,
                           group = interaction(feeding, workout))) +
  theme_minimal() +
  geom_point(position = position_dodge(0.2)) +
  stat_summary(fun = mean, geom = "line",
               position = position_dodge(0.2)) +
  scale_color_okabeito() +
  theme(legend.position = "top") +
  labs(x = "Zeitpunkte der Messung", y = "Sprungweite in [cm]",
       color = "Entwicklungsstand", shape = "Workout", 
       linetype = "Workout")
```

### Repeated ANOVA

Die repeated ANOVA ist in den Agrarwissenschaften selten. In den Sozialwissenschaften oder aber allgemeiner den Humanwissenschaften kommt die repeated ANOVA häufiger vor. Das hat vor allem damit zu tun, dass wir jedes Individuum mit allen Faktorkombinationen behandeln und wiederholt messen. Das wir ein Subjekt wiederholt messen kommt auch häufiger in den Agrarwissenschaften vor, aber selten erhält jedes Tier oder Pflanze alle Behandlungen verabreicht. Deshalb hier einmal die Daten für die repated ANOVA als Veranschaulichung was du als Daten und Experiment vorliegen haben musst.

#### Einfaktoriell {.unnumbered .unlisted}

Im Gegensatz zu mxied ANOVA können wir in der repeated ANOVA auch nur den einfaktoriellen Fall vorliegen haben. Da klingt jetzt erstmal etwas seltsam, aber wir haben in diesem Fall nur die Zeitpunkte als Faktor vorliegen. Wir messen also nur Katzenflöhe ohne eine Behandlung viermal. Wir schauen also, ob sich die Sprungweite von Katzenflöhen über die Zeitpunkte verändert. Wir vergleichen faktisch also nur die Zeitpunkte untereinander.

```{r}
repeated_fac1_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                                sheet = "repeated-fac1") |> 
  select(.id, animal, t1:t4) |> 
  pivot_longer(cols = t1:t4,
               values_to = "jump_length",
               names_to = "time_fct") |> 
  mutate(animal = as_factor(animal),
         time_fct = as_factor(time_fct),
         jump_length = round(jump_length, 2),
         .id = as_factor(.id))
```

Auch hier einmal die Daten im Wide-Format, damit die Daten etwas übersichtlicher sind. Wir haben nur die Katzenflöhe vorligen und schauen uns zwölf einzelne Katzenflöhe an. Jeder Floh springt dann vier Mal und wir messen dann die Sprungweite in \[cm\]. Wir müssen uns dann noch das Long-Format über die Funktion `pivot_longer()` in R bauen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-repeated-table-fac1
#| tbl-cap: "Rohdaten der Sprungweiten in [cm] gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht."

repeated_raw_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                               sheet = "repeated-fac1") |>
  select(.id, animal, t1:t4) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(repeated_raw_tbl, n = 3),
      rep("...", times = ncol(repeated_raw_tbl)),
      tail(repeated_raw_tbl, n = 3)) |> 
  tt(width = 1, align = "c", theme = "striped")
```

So ergibt sich dann auch ein sehr simples Versuchsdesign. Wir lassen jeden Katzenfloh viermal springen und messen jeweils die Sprungweite für jeden Floh.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-repeated-fac1
#| fig-align: center
#| fig-height: 2
#| fig-width: 7
#| fig-cap: "Versuchsdesign der einfaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal und wird dabei gemessen. Keine weiteren Faktoren liegen vor. *[Zum Vergrößern anklicken]*"

repeated_fac1_p
```

Damit ergibt sich am Ende auch eine sehr übersichtliche Abbildung. Wir sehen einmal die einzelnen Katzenflöhe. Jede Sprungweite über die vier Zeitpunkte habe ich für die individuellen Flöhe mit einer gestrichelten Linie verbunden. Den globalen Trend kannst du in der farbigen Linie nachvollziehen. Am Anfang springen die Flöhe nicht soweit, steigern sich dann zum zweiten Messzeitpunkt um dann wieder stetig abzunehmen. Einzelne Flöhe zeigen dabei eine größere Variabilität als der globale Trend.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-anova-repeated-fac1
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten. Die gestrichelte Linie verbindet die einzelnen individuellen Katzenflöhe. Die durchgezogene Linie stellt den Mittelwert zu dem jeweiligen Zeitpunkt dar.  *[Zum Vergrößern anklicken]*"

ggplot(repeated_fac1_tbl, aes(x = time_fct, y = jump_length, 
                             group = 1)) +
  theme_minimal() +
  geom_line(aes(group = .id), linetype = 11, color = "gray70") +
  geom_point2() +
  stat_summary(fun = "mean", geom = "line", color = "#CC79A7", size = 1) +
  labs(x = "Zeitpunkte der Messung", y = "Sprungweite in [cm]")
```

#### Zweifaktoriell {.unnumbered .unlisted}

Eigentlich wird die Besonderheit des repeated Design einer ANOVA erst bei der zweifaktoriellen repeated ANOVA so richtig ersichtlich. Hier haben wir es nämlich zum einen mit einem Behandlungsfaktor zu tun und einer Faktor mit den jeweiligen Messzeitpunkten. Wir haben hier wieder die Katzenflöhe mit unterschiedlichen Fütterungsarten ernährt und dann an vier Zeitpunkten gemessen, wie weit die Flöhe springen. Die Besonderheit ist jetzt, dass *jeder* Katzenfloh alle Behandlungen durchläuft. Das macht einen gewaltigen Unterschied im Design und in der Auswertung.

```{r}
repeated_fac2_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                                sheet = "repeated-fac2") |> 
  select(.id, animal, feeding, t1:t4) |> 
  pivot_longer(cols = t1:t4,
               values_to = "jump_length",
               names_to = "time_fct") |> 
  mutate(animal = as_factor(animal),
         feeding = as_factor(feeding),
         time_fct = as_factor(time_fct),
         jump_length = round(jump_length, 2),
         .id = as_factor(.id))
```

In der folgenden Tabelle der Rohdaten der Sprungweiten in \[cm\] unserer Katzenflöhe siehst du nochmal die Besonderheit der Messwiederholung. Wir messen die Sprungweite von jedem Floh $.id$ viermal für jede Fütterungsart. Wir müssen natürlich zwischen den Fütterungsarten Zeit lassen, damit wir wieder die Fütterungseffekte raus haben, aber ansonsten wird jeder Floh mit allen Ernährungsformen gefüttert. Hier ist dann auch die $.id$ Spalte so wichtig, da wir ja wissen müssen welche Fütterungsart zu welchem Floh gehört. Abschließend nutzen wir die Funktion `pivot_longer()` um uns die Daten passend in R zusammenzubauen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-repeated-table-fac2
#| tbl-cap: "Rohdaten der Sprungweiten in [cm] nach unterschiedlichen Fütterungsarten gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht. Hier erhält jeder Floh jede Behandlung als Fütterung einmal."

repeated_raw_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                               sheet = "repeated-fac2") |> 
  select(.id, animal, feeding, t1:t4) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(repeated_raw_tbl, n = 4),
      rep("...", times = ncol(repeated_raw_tbl)),
      tail(repeated_raw_tbl, n = 4)) |> 
  tt(width = 1, align = "c", theme = "striped")
```

In der folgenden Abbildung siehst du dann das Versuchsdesign für einen Katzenfloh nochmal dargestellt. Der Floh beginnt mit der Ernährungsform `ketchup` und springt dann viermal. Jedes Mal messen wir dann die Sprungweite. Nach einer Pause erhält der gleiche Katzenfloh dann die Ernährungsform `blood` und springt wieder zeitversetzt viermal. Am Ende ernähren wir dann den Floh noch mit Zuckerwasser `ctrl` und lassen ihn abschließend viermal springen. Damit springt ein einzelner Katzenfloh über den Versuch hinweg zwölfmal unter verschiedenen Versuchsbedingungen. Wie du siehst, ist dieses Design vermutlich nicht so häufig in den Agrarwissenschaften anzutreffen.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-repeated-fac2
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Versuchsdesign der zweifaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal unter jeder Fütterungsart und wird dabei gemessen. Damit messen wir einen Floh insgesamt zwölfmal. *[Zum Vergrößern anklicken]*"

repeated_fac2_p
```

Dann schauen wir uns nochmal den Zusammenhang zwischen der Ernährungsart und den einzelnen Zeitpunkten einmal in einer Abbildung an. Die einzelnen Flöhe sind als getrichelte Linien dargestellt. Die durchgezogenen Linien stellen die globalen Mittelwerte an den jeweiligen Zeitpunkten für die Fütterungsart dar. Wir sehen, dass wir Unterschiede in den Sprungweiten über die Zeitpunkte je nach Ernährungsform vorliegen haben. Dabei haben die Kontrolle und der Ketchup ähnliche Verläufe.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-anova-repeated-fac2
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten sowie den Fütterungsarten. Die gestrichelte Linie verbindet die einzelnen individuellen Katzenflöhe. Die durchgezogene Linie stellt den Mittelwert zu dem jeweiligen Zeitpunkt dar. *[Zum Vergrößern anklicken]*"

ggplot(repeated_fac2_tbl, aes(x = time_fct, y = jump_length, 
                             color = feeding, group = feeding)) +
  theme_minimal() +
  geom_line(aes(group = interaction(.id, feeding)), linetype = 11,
            alpha = 0.5) +
  geom_point2() +
  stat_summary(fun = "mean", geom = "line", size = 1) +
  scale_color_okabeito() +
  scale_x_discrete(expand = expansion(add = 0.1)) + 
  theme(legend.position = "top") +
  labs(x = "Zeitpunkte der Messung", y = "Sprungweite in [cm]",
       color = "Fütterungsart")
```

#### Dreifaktoriell {.unnumbered .unlisted}

Jetzt wird es richtig wild. Wir schauen uns jetzt nämlich nicht nur einen Behandlungsfaktor an, sondern haben zwei Behandlungen sowie die Messwiederholungen als Faktor über die Zeit. Wir schauen hier einmal auf die Fütterungsart mit der Kontrolle als Zuckerwasser, der Gabe von Blut sowie der Fütterung mit Ketchup. Dazu kommt dann noch eine Workoutsession oder eben keine Workoutsession. Wir haben damit zwei Behandlungsfaktoren vorliegen. Da wir ja nun jeden Floh wiederholt messen unter jeder Faktorkombination, kommt hier einiges an Sprungweitenmessung auf jeden einzelnen Floh zu. Daher sind repeated ANOVAs selten. Wir müssen ja nicht nur jeden Floh wiederholt für die Fütterungen durchmessen sondern eben auch nochnmal alles wiederholt für die beiden Workoutgruppen.

```{r}
repeated_fac3_tbl <- read_excel("data/fleas_complex_data.xlsx", 
                                sheet = "repeated-fac3") |> 
  select(.id, animal, feeding, workout, t1:t4) |> 
  pivot_longer(cols = t1:t4,
               values_to = "jump_length",
               names_to = "time_fct") |> 
  mutate(animal = as_factor(animal),
         feeding = as_factor(feeding),
         workout = as_factor(workout),
         time_fct = as_factor(time_fct),
         jump_length = round(jump_length, 2),
         .id = as_factor(.id))
```

In der folgenden Tabelle siehst du einmal die Daten im Wide-Format. In den ersten beiden Zeilen siehst du auch schon die Besonderheit. Wir Füttern eben einmal mit Bkut und messen dann viermal die Sprungweite für die beiden Gruppen des Workout. Daher messen wir dann jeden Floh insgesamt vierundzwanzigmal mit den jeweiligen Pausen zwischen den Behandlungskombinationen. Da kommen schon eine Menge Sprünge zusammen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-repeated-table-fac3
#| tbl-cap: "Rohdaten der Sprungweiten in [cm] nach unterschiedlichen Fütterungsarten und Workoutstatus gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht. Hier erhält jeder Floh jede Behandlungskombination aus Fütterung und Workout einmal."

repeated_raw_tbl <- read_excel("data/fleas_complex_data.xlsx", sheet = "repeated-fac3") |> 
  select(.id, animal, feeding, workout, t1:t4) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(repeated_raw_tbl, n = 4),
      rep("...", times = ncol(repeated_raw_tbl)),
      tail(repeated_raw_tbl, n = 4)) |> 
  tt(width = 1, align = "c", theme = "striped")
```

Eigentlich sieht man das Versuchsdesign erst so richtig in der folgenden Abbildung. Hier siehst du einmal wie ein einzelner Floh alle 24 Sprünge nacheinander unter der jeweiligen Faktorkombination durchführt. In einem idealen Setting folgt natürlich jeder Floh eine zufällige Reihenfolge der Faktorkombinationen. Bitte beachte, dass zwischen den einzelnen Behandlungskombinationen nach dem vierten Sprung natürlich auch eine Zeit vergehen muss, damit sich die Behandlung wieder ausgeschlichen hat.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-theo-repeated-fac3
#| fig-align: center
#| fig-height: 5.5
#| fig-width: 7
#| fig-cap: "Versuchsdesign der dreifaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal unter jeder Kombination von Fütterungsart sowie Workoutstatus und wird dabei gemessen. Damit messen wir einen Floh insgesamt vierundzwanzigmal. *[Zum Vergrößern anklicken]*"

repeated_fac3_p
```

Am Ende schauen wir uns auch die Daten einmal in einer Abbildung an. Hier haben wir dann die beiden Workoutgruppen sowie die drei Fütterungsarten in einer Abbildung vereint. Wir sehen, dass die nicht trainierten Flöhe im allgemeinen nicht so weit springen wir die trainierten Flöhe. Ebenso wirkt, dass die Ernährung mit Blut auf jeden Fall die bessere Sprungleistung bewirkt. Teilweise sehen wir, dass sich die Linien der Mittelwerte überschneiden, so dass wir hier eventuell von einer Interaktion ausgehen müssen. Das schauen wir uns dann aber in den entsprechenden statistischen Tests einmal näher an.

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-ggplot-anova-repeated-fac3
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten sowie den Fütterungsarten und Workoutstatus. Die Linienarten stellen den Workoutstatus dar. *[Zum Vergrößern anklicken]*"

ggplot(repeated_fac3_tbl, aes(x = time_fct, y = jump_length, shape = workout,
                             color = feeding, linetype = workout,
                             group = interaction(feeding, workout))) +
  theme_minimal() +
  geom_point(position = position_dodge(0.2)) +
  stat_summary(fun = mean, geom = "line",
               position = position_dodge(0.2)) +
  scale_color_okabeito() +
  theme(legend.position = "top") +
  labs(x = "Zeitpunkte der Messung", y = "Sprungweite in [cm]",
       color = "Fütterungsart", shape = "Workout", linetype = "Workout")
```

## Mixed ANOVA

Beginnen wir mit der Auswertung unserer beispieldaten mit der mixed ANOVA. Wir kriegen hier natürlich nur eine globale Aussage über den Faktor der Behandlung oder der Zeit. Wenn dich die paarweisen Vergleiche interessieren, dann müsst du noch einen Posthoc-Test anschließen. Mehr Informationen zu der Modellierung findest du auch in dem [Kapitel zu gemischten Modellen](#sec-mixed). Dort erfährst du dann auch, wie du dir den Posthoc-Test bauen kannst. Hier bleiben wir dann bei der ANOVA und den entsprechenden Ergebnissen.

### Zweifaktoriell

Als erstes schauen wir uns die Auswertung der zweifaktoriellen mixed ANOVA an. Nochmal zur Erinnerung, wir haben einen Behandlungsfaktor mit den drei Arten der Fütterung, Kontrolle, Blut und Ketchup, vorliegen. Darüber hinaus messen wir die Sprungweite an sechs Zeitpunkten widerholt für jeden Katzenfloh. Wir wollen jetzt wissen, ob die Fütterung einen Einfluss auf die Sprungweiten der Katzenflöhe über die Zeit hat. Dabei sind wir eigentlich nicht so sehr an den Zeitpunkten wie an der Behandlung der Fütterung interessiert. In einem zweifaktoriellen Versuch können wir uns dann auch immer die Interaktion mit anschauen um zu sehen, die Behandlung unabhängig von den Zeitpunkten ist.

::: panel-tabset
## `{base}`

Die Standardimplementierung ist eigentlich recht einfahc durchzuführen. Wir haben wie immer erst unseren Messwert $y$ und dann die Formelschreibweise für unser beiden Faktoren und deren Interaktion. Ich mache mir es hier etwas einfacher und schreibe dann noch die Faktoren mit dem `*` um etwas Platz zu sparen. Die Besonderheit hier ist jetzt, dass wir noch spezifizieren müssen welche Variable in unseren Daten die wiederholt gemessenen Individuen darstellt und über welchen Faktor diese Individuen dann wiederholt gemessen wurden. In unserem Fall stehen die Individuen in der Spalte `.id` und wir haben über die Spalte `time_fct` wiederholt die einzelnen Flöhe gemessen. Dann müssen wir das ganze noch in die Funktion `Error()` schreiben, damit die ANOVA auch erkennt, dass wir hier den Teil mit den Messwiederholungen darstellen.

```{r}
aov(jump_length ~ feeding * time_fct + Error(.id/time_fct), 
    data = mixed_fac2_tbl) |> 
  tidy() |> 
  na.omit() |> 
  select(term, df, statistic, p.value) |> 
  mutate(p.value = pvalue(p.value))
```

Ich filtere hier einiges weg, da wir hier viele Informationen erhalten, die wir meistens nicht brauchen. Wir sehen, dass einen signifikanten Einfluss der Fütterung auf die Sprungweite haben, da der p-Wert kleiner ist als das Signifikanzniveau $\alpha$ gleich 5%. Dies ist auch der Fall für die Zeitpunkte und die Interaktion. Da wir hier eine signifikante Interaktion vorliegen haben, können wir die Fütterungsarten nicht unabhängig über die Zeit interpretieren. Es gibt damit Zeitpunkte an denen die Fütterungen unterschiedliche Effekte zeigen.

## `{rstatix}`

Das R Paket `{rstatix}` liefert mit der Funktion `anova_test()` auch eine Möglichkeit eine mixed ANOVA zu rechnen. Hier ist es dann mit den Optionen etwas anders. Ich mag ja die Formelschreibweise sehr gerne, da weiß ich dann wo was steht. Auf der anderen Seite mag es aber auch einfacher sein, wenn man einfach die Variablen in den Daten einer Option in der Funktion zuordnet. Hier haben wir den Fall, dass wir sagen müssen, was ist unser Messwert? Der Messwert kommt in die Option `dv`. Dann brauchen wir die individuellen IDs in der Option `wid`. Die Faktoren, die wir untereinander vergleichen wollen, kommen dann in die Option `between`. In unserem Fall sind das die Fütterungsarten. Wir wollen wissen ob es zwischen den Fütterungsarten einen Unterschied gibt. Die Zeit als Messwiederholung kommt dann in die Option `within`. Wir messen ja die Zeitpunkte innerhalb (eng. *within*) der Individuen.

```{r}
rstatix_aov <- anova_test(data = mixed_fac2_tbl, 
                          dv = jump_length, wid = .id, 
                          between = feeding, within = time_fct)
get_anova_table(rstatix_aov)
```

Numerisch sind die Werte die gleichen Werte, die wir auch in der `aov()` Funktion erhalten. Im Hintergrund wird auch eine `aov()` gerechnet, nur die Übergabe der Variablen ist hier anders. Neben der Signifikanz kriegen wir in der Spalte `ges` auch noch ein Eta$^2$ Wert wiedergegeben, den wir klassisch interpretieren können. Da wir es in einer mixed ANOVA mit einem etwas anderen Eta$^2$ Wert zu tun haben, können wir hier erstmal sagen, dass je gößer der Wert desto stärker der Effekt. Die p-Werte sind auch hier für alle Vergleiche hoch signifikant.

## `{afex}`

Das R Paket `{afex}` elraubt im besonderen die Modellierung von Messwiederholungen von Beobachtungen. Faktisch ist das Paket um diese Art der Analyse gebaut. Dementsprechend gibt es auch zwei Arten des Funktionsaufrufs. Wir konzentrieren uns hier aus Gründen der konsistents zu `aov()` auf die Funktion `aov_car()`. Am Ende kommen hier die gleichen Werte raus wie schon bei den anderen Tabs. Wir haben hier aber die Möglichkeit etwas mehr zu machen. Alles Weitere dann in der [Vingette zu `{afex}` und dem Posthoc-Test](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html). Wenn du viel mit Messwiederholungen arbeitest, dann ist eine Einarbeitung in `{afex}` sicherlich sinnvoll. Leider bist du bei `{afex}` an die Normalverteilung und die Varianzhomogenität gebunden. MAn kann eben nicht alles haben.

```{r}
#| message: false
#| warning: false
aov_car(jump_length ~ feeding * time_fct + Error(.id/time_fct), 
        data = mixed_fac2_tbl)
```

Auch hier erhalten wir die gleichen numwerischen Werte wie schon in den vorherigen Tabs zu `{base}` und `{rstatix}`. Die Signifikanz ist für alle Faktoren sowie der Interaktion gegeben. Wir erhalten auch hier in der Spalte `ges` dann das Eta$^2$ als Effektschätzer zurück. Am Ende finde ich die Ausgabe etwas sperrig.

Das R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.

```{r}
#| message: false
#| warning: false
#| eval: false
aov_4(jump_length ~ feeding * time_fct + (time_fct|.id), 
      data = mixed_fac2_tbl)
```

## `{MANOVA.RM}`

Mit dem R Paket `{MANOVA.RM}` haben wir auch die Möglichkeit eine mixed ANOVA zu rechnen in dem wir die Funktion `RM()` nutzen. Das ist natürlich etwas verwirrend vom Namen, aber wenn wir die Optionen richtig mit den Variablen belegen, dann rechnen wir auch eine mixed ANOVA. Hier müssen wir dann angeben in welche Spalte die Beobachtungen sind und was der `within` Faktor ist. Bei uns ist das dann einfach. Wir nutzen die Variable `.id` sowie als Faktor der Messwiederholungen `time_fct`. Der Rest ist eigentlich nicht so wichtig. Wenn du die Funktion in deiner Analyse rechnest, dann würde ich die Option `iter` auf 1000 setzen.

Am Ende muss sich aber dann doch fragen, ob es eine noch hässlichere Ausgabe einer Funktion gibt. Ich glaube eher nicht, aber das soll die Leistung des Algorithmus nicht schmälern. Wir kämpfen uns da doch mal durch. Manche Informationen sind dann einfach auch wieder über, da wir je eigentlich nur wissen wollen, ob wir einen signifikanten Einfluss der Behandlung `feeding` vorliegen haben.

```{r}
RM(jump_length ~ feeding * time_fct, data = mixed_fac2_tbl, 
   subject = ".id", within = c("time_fct"), iter = 100, 
   resampling = "Perm", seed = 1234) |> 
  summary()
```

Als erstes erhalten wir eine lange Tabelle mit der deskriptiven Statistik der Mittelwerte für jede Faktorkombination der Fütterungsart sowie dem Zeitpunkt. Dazu dann noch die passenden 95% Konfidenzintervalle. Dann kommen drei Tests nacheinander. Das ist auch immer das Problem, wenn du dann drei Ausgaben hast und nicht weißt, welche du nehmen sollst. Ich würde hier die Ergebnisse der `ANOVA-Type Statistic (ATS)` nehmen und den Rest liegen lassen. Die p-Werte aus dem Permutationstest `p-values resampling` haben zwar auch ihre Berechtigung bei nicht normalverteilten oder varianzheterogenen Daten aber ich würde dann hier auch eher das R Paket `{WRS2}` vorziehen.

## `{WRS2}`

Kommen wir nun zum letzten Paket, was ich hier noch für die zweifaktorielle mixed ANOVA zeigen möchte. Es handelt sich um `{WRS2}`, welches dann auch erlaubt die zweifaktorielle mixed ANOVA zu rechnen, wenn wir die Annahme der Normalverteilung an den Messwert oder keine Varianzhomogenität in den Gruppen vorliegen haben. Es geht dann auch beides. Das ist dann auch der große Vorteil von `{WRS2}`. Das Modell sieht genauso aus wie auch bei den anderen Anwendungen. Wir müssen hier nur einmal in der Option `id` angeben, welche Spalte unsere ID ist.

```{r}
bwtrim(jump_length ~ feeding * time_fct, id = .id, data = mixed_fac2_tbl)
```

Die Ergebnisse sind dann vom p-Wert inhaltlich gleich wie bei den anderen Anwendungen. Das habe ich hier auch erwartet, denn unsere Sprungweiten habe ich so gebaut, dass die Sprungweiten normalverteilt sind. Nicht immer können wir aber in unseren Daten davon ausgehen, dass wir normalverteilte Messwerte vorliegen haben. Da ist diese Alternative hier sehr gut.
:::

Wir haben ja in den obigen Anwendungen der mixed ANOVA immer eine signifikante Interaktion gefunden. Daher wollen wir uns einmal in einem Liniendiagramm der Mittelwerte die Sachlage näher anschauen. Wenn wir eine Interaktion erwarten, dann sollten sich die Linien der Mittelwerte kreuzen. Wir haben ja auch in allen Analysen eine signifkante Interaktion voriegen. Wenn wir jetzt auf die Abbildung schauen, dann sehen wir auch, dass sich die Lienien für die Fütterung mit Blut und der Kontrolle kreuzen. Wir haben hier eine Interaktion vorliegen. Auch sind die Unterschiede zwischend den Fütterungen nicht immer parallel zueinander mit dem gleichen Effekt oder eben Abstand.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-interactionplot-mixed-2fac
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Liniendigramm mit den Mittelwerten aller Faktorkombinationen der beiden Faktoren `feeding` und `time_fct`. Die Linien kreuzen sich leicht, es liegt eine Interaktion vor. Eine allgemeine Aussage über die Sprungweite und der Fütterung lässt sich nicht unabhängig vom Zeitpunkt treffen. Die Interaktion ist aber nicht sehr stark."

mixed_fac2_tbl |> 
  ggplot(aes(x = time_fct, y = jump_length,
             color = feeding, group = feeding)) +
  theme_minimal() +
  stat_summary(fun = "mean", geom = "point") +
  stat_summary(fun = "mean", geom = "line") +
  theme(legend.position = "top") +
  scale_color_okabeito()
```

### Dreifaktoriell

Jetzt betrachten wir noch die dreifaktorielle mixed ANOVA. Dieses Design kommt dann vor, wenn du zwei Behandlungsfaktoren sowie einen Zeitfaktor in deinen Daten vorliegen hast. In unserem Fall ist der erste Faktor die Fütterungsart mit den Gruppen Kontrolle, Blut und Ketchup sowie als zweiten Faktor der Status des Workouts des einzlenen Flohs. Wir schauen hier nur Katzenflöhe an. Dann messen wir die Sprungweite jedes einzelnen Flohs nochmal zu sechs Zeitpunkten. Hier ist es wieder wichtig darauf zu achten, was mit einem einzelnen Floh passiert und gemessen wird. Wir messen hier jede Faktorkombination und Wiederholung mit einem neuen Floh. Schaue dir dazu nochmal die Übersicht des Designs in dem Abschnitt zu den Daten in der @fig-ggplot-theo-mixed-fac3 an. Auch hier ist es dann manchmal von Vorteil zu wissen, wechler Faktor einem eigentlich am meisten interessiert. Wir betrachten hier jetzt alle drei Faktoren und deren Interaktionen als gleichwertig. Wir können die dreifaktorielle mixed ANOVA nicht mehr in dem R Paket `{WRS2}` rechnen. Das Paket biette keine Funktion dafür an.

::: panel-tabset
## `{base}`

Beginnen wir wieder mit der Standardfunktion in `{base}` mit `aov()` und deren Anwendung. Hier kommt dann die verkürzende Formelschreibweise mit dem Stern `*` zum Einsatz. Ich kann mir nicht merken was alle Faktorkombinationen zusammen mit allen Interaktionen sind. Daher nutze ich dann einmal die Schreibweise, die mir diese Überlegung abnimmt. Dann muss ich noch in dem Fehlerterm mitteilen wer `.id` in welchen Faktor `time_fct` wiederholt wird. Damit ist die dreifaktorielle mixed ANOVA der zweifaktoriellen mixed ANOVA sehr ähnlich. Wir erhalten dann folgende Ausagen, die ich nochmal aufgereinigt habe, da ich nicht alle Spalten und Informationen brauche. Auch mag ich den p-Wert gerne etwas übersichtlicher.

```{r}
aov(jump_length ~ feeding * workout * time_fct + Error(.id/time_fct), 
    data = mixed_fac3_tbl) |> 
  tidy() |> 
  na.omit() |> 
  select(term, df, statistic, p.value) |> 
  mutate(p.value = pvalue(p.value))
```

Wir sehen sofort, dass die beiden Faktoren der Fütterungsart sowie des Workout signifikant sind. Auch haben wir eine signifikante Interaktion zwischen den beiden Faktoren vorliegen. Die Gruppen der Fütterung verhalten sich in den beiden Gruppen des Workouts nicht gleich. Auch ist die Zeit signifkant, es passiert also etwas mit der Sprungweite über die Zeit. Im Weiteren haben wir eine signifikante Interaktion zwischen der Fütterungsart und der Zeit, so dass sich hier auch über die Zeit die Gruppen der Fütterung anders verhalten. Die anderen Interaktionen sind nicht signifikant.

## `{rstatix}`

Jetzt kürze ich ein wenig ab, da die Ergebnisse ja gleich sind in `{rstatix}` zu der mixed ANOVA mit `aov()`. Die Funktionen sind ja identisch nur das sich die Eingabe unterscheidet. Hier sieht man dann eventuell besser, dass wir *zwischen* den Fütterungsarten und den Workouts vergleichen wollen und wir als Wiederholung die `.id` der einzelnen Flöhe vorliegen haben. Wir erhalten hier nochmal als Effektschätzer das Eta$^2$ wiedergegeben, was wirklich ein Vorteil ist. Ansonsten würde ich fast die `aov()` Funktion vorziehen. Am Ende filtere ich wieder um dann eine etwas ausgeräumte Ausgabe zu haben.

```{r}
rstatix_aov <- anova_test(data = mixed_fac3_tbl, 
                          dv = jump_length, wid = .id, 
                          between = c(feeding, workout), 
                          within = time_fct)
get_anova_table(rstatix_aov) |> 
  as_tibble() |> 
  select(Effect, F, p, ges) |> 
  mutate(p = pvalue(p))
```

## `{afex}`

Bei dem R Paket `{afex}` ist es ähnlich wie schon bei dem R Paket `{rstatix}`. Hier ist dann die Formelschreibweise ähnlich wie schon bei `aov()`. Das macht die Nutzung angenehmer für mich. Als Besonderheit können wir dann auch `{afex}` nutzen wie ein lineares gemischtes Modell. Intern ruft dann aber auch `{afex}` das Paket `{car}` auf und nutzt dessen Algorithmus. Daher ist hier die Nutzung der Type II ANOVA und Type III ANOVA einfacher umzusetzen. Ich mag das Paket gerne, da es auch speziell für Messwiederholungen gebaut wurde.

```{r}
#| message: false
#| warning: false
aov_car(jump_length ~ feeding * workout * time_fct + Error(.id/time_fct), 
        data = mixed_fac3_tbl) 
```

Das R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.

```{r}
#| message: false
#| warning: false
#| eval: false
aov_4(jump_length ~ feeding * workout * time_fct + (time_fct|.id), 
      data = mixed_fac3_tbl)
```

## `{MANOVA.RM}`

Am Ende stelle ich noch das R Paket `{MANOVA.RM}` vor. Auch hier haben wir dann wieder zu viel Ausgabe. Ich finde hier wird dann deutlich, dass die deskriptive Statistik über ist. Ich will doch nur eine mixed ANOVA rechnen. In der Funktion `RM()` spezifizieren wir ja nur den `within` Faktor, der sich hier ja auch bei einer dreifaktoriellen mixed ANOVA nicht ändert. Wir haben auch hier wieder drei Tests, wobei ich dann auch nur die Ergebnisse der `ANOVA-Type Statistic (ATS)` nehmen und den Rest liegen lassen würde.

```{r}
RM(jump_length ~ feeding * workout * time_fct, data = mixed_fac3_tbl, 
   subject = ".id", within = c("time_fct"), iter = 100, 
   resampling = "Perm", seed = 1234) |> 
  summary()
```
:::

Nachdem wir ja unsere mixed ANOVA mit einem der vorgeschlagenen Algorithmen gerechnet haben, sehen wir dass wir eine signifikante Interaktion vorliegen haben. Zum einen ist der Interaktionsterm `feeding:workout` signifikant sowie der Interaktionsterm `feeding:time_fct` auch. Damit haben wir andere Mittelwerte der Sprungweite für die Fütterungsarten zu den beiden Workouts sowie unterschiedliche Mittelwerte der Sprungweiten über die Zeit und Fütterungsarten. Ja und das sehen wir dann auch in der folgenden Abbildung. Bei der Kontrollbehandlung und der Ketchupfütterung hat das Workout exakt einen anderen Effekt. Bei der Kontrolle springen die nicht trainierten Flöhe weniger weit. Bei der Ernährung mit Ketchup haben das Training einen negativen Effekt. Eine Drehung des Effekts des Workouts nach der Fütterung. Auch kreuzen die Mittelwerte der Sprungweiten über die Zeit nach der Fütterungsart.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-interactionplot-mixed-3fac
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Liniendigramm mit den Mittelwerten aller Faktorkombinationen der beiden Faktoren `feeding` sowie `workout` und `time_fct`. Die Linien sind in der Reichenfolge verdreht, es liegt eine Interaktion vor. Auch kruezen sich die Fütterungsarten über die Zeit. Eine allgmeine Aussage über die Sprungweite und die Fütterung soweie dem Workout lässt sich nicht unabhängig vom Zeitpunkt treffen."

mixed_fac3_tbl |> 
  ggplot(aes(x = time_fct, y = jump_length,
             color = feeding, linetype = workout, 
             group = interaction(feeding, workout))) +
  theme_minimal() +
  stat_summary(fun = "mean", geom = "point") +
  stat_summary(fun = "mean", geom = "line") +
  theme(legend.position = "top") +
  scale_color_okabeito()
```

## Repeated measurement ANOVA

::: callout-caution
## Achtung, bitte beachten!

Willst du wirklich eine *repeated* ANOVA rechnen oder doch eher eine mixed ANOVA? Der Unterschied ist subtil und hängt davon ab, welche Behandlungskombinationen deine einzelnen Beobachtungen erhalten haben. Schaue im Zweifel nochmal oben in der Einleitung um dich zu versichern. Häufig möchtest du nämlich eine mixed ANOVA rechnen.
:::

Schauen wir also einmal was die repeated ANOVA einmal macht. Hier nochmal ganz wichtig zu Anfang. Wir werden jetzte *jede* Beobachtung mit *jeder* Faktorkombination zu *jedem* Zeitpunkt messen. Das heißt in unserem Konkreten Fall, dass wir bei jeden Katzenfloh die Sprungweite zu jedem Zeitpunkt messen. Das macht ja auch erstmal Sinn. Das wäre dann die einfaktorielle repated ANOVA. Wir haben sonst auch keinen weiteren Faktor im Experiment. Wenn wir jetzt noch die Fütterungsart als Faktor hinzunehmen, dann füttern wir jeden Floh mit allen drei Arten der Fütterung. Jeder Floh erhält Zuckerwasser, springt dann mehrfach und wir messen die Sprungweite. Das machen wir dann mit dem selben Floh nochmal für die Ernährungsart Blut und Ketchup. Wenn dann noch ein zweiter Behandlungsfaktor hinzukommt wie das Workout, dann müssen wir unter jeder Workoutbedinung einmal alle drei Fütterungsarten die Sprungweiten für einen Floh durchmessen. Das heißt wir messen dann einen einzelnen Floh ganz schön oft. Im Bereich der Agrarwissenschaften mag diese Art der wiederholten Behandlung eher selten vorkommen. Daher hier auch ausdrücklich die Warnung, sich nochmal klar zu machen, wie du die einzelnen Beobachtungen nun bemisst. Ich habe auch erst ein wenig gebraucht um die repeated ANOVA von Design her zu verstehen.

### Einfaktoriell

Beginnen wir mit der einfaktoriellen repeated ANOVA. Hier haben wir die Fragestellung vorliegen, ob die Zeit einen Einfluss auf die Sprungweiten der Katzenflöhe hat. Wir haben sonst keinen weiteren Behandlungsfaktor. Wir messen einfach nur die Sprungweite der Katzenflöhe wiederholt und schauen, ob sich die Sprungweiten über die Zeit ändern. Das Experiment ist eher ungewöhnlich, da wir hier ja nur wiederholt messen und sonst nichts tun. Faktisch ist es ein *proof-of-principle*, ob wir überhaupt einen Effekt der Zeit auf die Sprungweite haben.

::: panel-tabset
## `{base}`

Jetzt ist im Prinzip die Schreiweise das Besondere. Wir haben hier jetzt nur die Zeit als einen Einflussfaktor. Den packen wir jetzt einmal vorne in unser Modell und dann einmal hinten in den Fehlerterm. Dann müssen wir auch hier sagen, dass wir die Beobachtungen wiederholt im Faktor Zeit gemessen haben. Dann können wir auch schon die ANOVA rechnen.

```{r}
aov(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl)|> 
  tidy() |> 
  na.omit() |> 
  select(term, df, statistic, p.value) |> 
  mutate(p.value = pvalue(p.value))
```

Wir sehen, dass der p-Wert kleiner ist als das Signifikanzniveau $\alpha$ gleich 5% und damit haben wir einen signifkanten Einfluss der Zeit auf die Sprungweite der Katzenflöhe. Mehr testen wir hier auch nicht. Wir haben ja auch nur die Zeit als Faktor in unserem Modell.

Wenn du dann noch einen Effektschätzer brauchst, dann kannst du das R Paket `{effectsize}` mit der Funktion `eta_squared()` nutzen. Wir wollen dann noch das [generalisierte Eta$^2$](https://easystats.github.io/effectsize/articles/anovaES.html#generalized-eta2) nutzen, da wir die Zeitpunkte nur beobachten und nicht als experimentellen Faktor festgelegt haben. Dazu dann auch mehr in der Arbeit von @olejnik2003generalized mit dem Titel [Generalized eta and omega squared statistics: measures of effect size for some common research designs](https://coshima.davidrjfikis.com/EPRS8540/uploadf07/olejnik_PsychMeth2003.pdf).

```{r}
aov(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl) |> 
  eta_squared(generalized = "time_fct")
```

## `{rstatix}`

Wir können auch das R Paket `{rstatix}` nutzen. Hier rufen wir am Ende dann doch auch nur die `aov()` Funktion auf, schreiben aber die Variablen in unseren Daten etwas anders in die Funkion `anova_test()`. Du musst eben wissen, dass hier die abhängige Variable `dv` die Sprungweite ist, du dann die Beobachtungen in `wid` schreibst und die Zeit in die Option `within`. Am Ende ist es dann auch hier eine Geschmackssache, welche Funktion dir besser gefällt und passt.

```{r}
rstatix_aov <- anova_test(data = repeated_fac1_tbl, 
                          dv = jump_length, wid = .id, within = time_fct)
get_anova_table(rstatix_aov)
```

Es kommt das Gleiche numerisch raus, wie schon bei `aov()`. Wir erhalten hier aber zusätzlich noch einen Effektschätzer in der Spalte `ges`, was dem Eta$^2$ entspricht. Demensprechend ein Vorteil der Funktion.

## `{afex}`

Das R Paket `{afex}` kommt bei einer so simplen einfaktoriellen repeated ANOVA dann auf die gleichen Zahlen wie schon die beiden vorherigen Algorithmen. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben. Ich bevorzuge dann ja die Schreibweise hier von `{afex}`, da ich diese hier etwas klarer finde als bei `{rstatix}`.

```{r}
#| message: false
#| warning: false
aov_car(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl)
```

Das R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.

```{r}
#| message: false
#| warning: false
#| eval: false
aov_4(jump_length ~ time_fct + (time_fct|.id), data = repeated_fac1_tbl)
```

## `{MANOVA.RM}`

Am Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem einfaktoriellen Fall die gleichen Werte wie in den anderen R Paketen erhalten. Hir haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht.

```{r}
RM(jump_length ~ time_fct, data = repeated_fac1_tbl, 
   subject = ".id", within = "time_fct", iter = 100, 
   resampling = "Perm", seed = 1234) |> 
  summary()
```
:::

### Zweifaktoriell

Die zweifaktorielle repeated ANOVA wird jetzt schon interessanter. Wir haben jetzt nämlich neben der Zeit als Faktor noch eine Behandlung vorliegen. In unserem Beispiel erhält *jeder* Floh drei Arten der Fütterung wiederholt gefüttert. Zum einen erhält jeder Floh ein Zuckerwasser, dann Blut und zum Schluss Ketchup als Nahrung. Die Reihenfolge sollte sich dann von Floh Floh noch unterscheiden und die Zeiten zwischen den Behandlungen dann so lang gewählt werden, dass die Ernährung förmlich ausgewaschen ist. Die Idee ist, dass die vorherige Ernährungsform keinen Einfluss auf die neue Ernährung hat. Dann müssen wir das Ganze ja auch noch wiederholt über vier Zeitpunkte die Sprungweite messen. Daher misst du hier ganz schön viel. Häufig haben wir dieses Design nicht in den Agrarwissenschaften vorliegen. Wir können aber im Bereich der Nutztierwissenschaften schon das ein oder andere Mal so einen Fall vorliegen haben, wo wir Tiere wiederholt mit einer Behandlung verarzten.

::: panel-tabset
## `{base}`

Die Frage ist jetzt immer, wie schreibe ich jetzt das Modell richtig? Der komplizierte Teil ist eigentlich der Fehlerterm `Error()` aber auch der Teil davor. Ich nutze hier wieder die Kurzschreibweise mit dem Stern `*` um alle Faktorkombinationen plus Interaktion im Modell zu haben. Das wird eben dann ab zwei Faktoren etwas groß. So ist es dann weniger anfällig für Fehler. Dann musst du noch darauf achten, dass du in dem Fehlerterm die Klammern richtig setzt, sonst funktioniert es dort auch nicht. Erst kommt der Spaltenname für die einzelnen Flöhe `.id` und dahinter nach dem Slash `/` dann die Faktorkombinationen der Behandlungen und der Zeit. Dann räume ich die Ausgabe nochmal vollkommen auf, damit ich auch was sehe.

```{r}
aov(jump_length ~ feeding * time_fct + Error(.id/(feeding * time_fct)), 
    data = repeated_fac2_tbl) |> 
  tidy() |> 
  na.omit() |> 
  select(term, df, statistic, p.value) |> 
  mutate(p.value = pvalue(p.value))
```

Wie wir sehen sind beide Faktoren der Zeit und der Fütterungsart signifikant. Der p-Wert ist kleiner als das Signifikanzniveau $\alpha$ gleich 5%. Auch haben wir eine signifikante Interaktion zwischen den Fütterungsarten und der Zeit. Daher zeigen die Fütterungsarten unterschiedliche Sprungweiten zu den verschiedenen Zeitpunkten.

Dann können wir uns auch den Effektschätzer Eta\^$^2$ berechnen lassen. Hier müssen wir dann das ANOVA Modell einmal in die Funktion `eta_squared()` stecken und darauf achten, dass wir angeben, dass wir die Zeitpunkte nur beobachtet haben und nicht experimentell festgelegt. Deshalb kommt `time_fct` noch in die Option `generalized` mit rein. Die Effektschätzer unterscheiden sich hier immer ein wenig, dass kommt dann immer auf den verwendeten Algorithmus an.

```{r}
aov(jump_length ~ feeding * time_fct + Error(.id/(feeding * time_fct)), 
    data = repeated_fac2_tbl) |> 
  eta_squared(generalized = c("time_fct"))
```

## `{rstatix}`

Das R Paket `{rstatix}` hat eine andere Schreibweise des Modells. Im Prinzip schreiben wir hier wieder nicht das Modell auf, sondern weisen die Spaltennamen dann den jeweiligen Optionen zu. Hier werden dann auch alle Interaktionen gerechnet, du kannst die Interaktionen aller Faktorkombinationen nicht abstellen. Wir setzten dann unseren Endpunkt `jump_length` in die Option `dv` und die einzelnen Beobachtungen in die Option `wid`. Dann müssen wir noch die beiden Faktoren der Zeit und der Behandlung in die Option `within` einfügen. Dann haben wir auch schon alles zusammen. Was hier etwas doof ist, ist das wir hier die Formelschreibweise in R verlassen, die wir dann aber überall sonst nutzen. Dafür erhalten wir dann aber das Eta$^2$ gleich als `ges` wieder aus der Funktion zurück.

```{r}
rstatix_aov <- anova_test(data = repeated_fac2_tbl, 
                          dv = jump_length, wid = .id, 
                          within = c(feeding, time_fct))
get_anova_table(rstatix_aov)
```

Wir erhalten die gleichen Ergebnisse wie schon bei der Funktion `aov()` wiedergegeben. Das überrascht auch nicht, den die Berechnung ist ja die gleiche Berechnung wie auch in `aov()` nur eben dann mit einem anderen Funktionsaufruf.

## `{afex}`

Das R Paket `{afex}` nutzt die Formelschreibweise und kann auch genau so bedient werden wie schon die Funktion `aov()`. Dafür können wir aber mit der Option `type` auch anderen Typen der ANOVA nutzen und nicht nur die Type I ANOVA in `aov()`. Das ist eigentlich die große Stärke von dem R Paket `{afex}`, dass wir hier flexibel bei der Auswahl der Typen sind. Bei der einfaktoriellen ANOVA war es noch egal, aber hier macht es mit zwei Faktoren dann schon einen Unterschied welche Art der ANOVA du rechnen möchtest. Ich nutze hier den Standard und damit die Type III ANOVA. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben.

```{r}
#| message: false
#| warning: false
aov_car(jump_length ~ feeding * time_fct + Error(.id/feeding * time_fct), 
        data = repeated_fac2_tbl)
```

Die Ergebnisse sind ähnlich wie schon bei den beiden anderen Algorithmen, aber hier macht es dann einen Unterschied welche ANOVA grechnet wird. Wir rechnen hier dann ja eine Type 3 ANOVA. Die p-Werte sind aber alle so gering, dass es dann am Ende keinen so großen Unterschied mehr macht.

Das R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.

```{r}
#| message: false
#| warning: false
#| eval: false
aov_4(jump_length ~ feeding * time_fct + (feeding * time_fct|.id), 
      data = repeated_fac2_tbl)
```

## `{MANOVA.RM}`

Am Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem zweifaktoriellen Fall die ähnlichen Werte wie in den anderen R Paketen erhalten. Hier fängt es dann etwas an zu variieren. Hier haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht. Ich habe dann einmal hier die Anzeige der Funktion ausgeschaltet, da hier der Output dann sehr lang wird. Du kannst dir beispielhaft die Ausgabe einmal bei der einfaktoriellen repeated ANOVA weiter oben einmal anschaue oder eben den Code selber einmal durchführen.

```{r}
#| message: false
#| warning: false
#| eval: false
RM(jump_length ~ feeding * time_fct, data = repeated_fac2_tbl, 
   subject = ".id", within = c("feeding", "time_fct"), iter = 100, 
   resampling = "Perm", seed = 1234) |> 
  summary()
```
:::

### Dreifaktoriell

Als letztes betrachten wir einen sehr exotischen Fall im Bereich der Agrarwissenschaften. Auch in anderen Forschungsbereichen ist die dreifaktorielle repeated ANOVA eher selten bis nicht vorhanden. Warum ist das so? Zum einen haben wir ja wieder unseren Faktor der Zeit. Wir messen hier viermal die Sprungweite eines Katzenflohs. Da wir aber dann noch zusätzlich zu dem Faktor der Zeit zwei weitere Behandlungen haben, kommen wir auf eine große Anzahl an Faktorkombinationen, die *jeder* Floh wiederholt durchlaufen muss. In unserem Fall haben wir ja die drei Fütterungsarten mit Zuckerwasser als Kontrolle, dem Blut sowie Ketchup als Ernährung. Dazu kommt dann noch ein Workout, dass jeder Floh gemacht hat oder nicht. Daher muss für jeden Floh jede Kombination der Fütterungsart und des Workouts wiederholt die Sprungweite gemessen werden. Das führt zu einem enormen Aufwand. Zum einen musst du ja immer Pausen zwischen den Behandlungen machen, damit sich die Effekte wieder auswaschen und es mit einem frischen Floh losgehen kann. Das ist eine zeitliche Belastung. Zum anderen ist es natürlich auch so, dass über die Zeit eventuell ein Floh nicht mehr kann oder gar verstirbt. Dann ist die ganze Messreihe für den Floh obsolet. Du siehst, diese Form des experimentellen Designs ist eher selten in Abschlussarbeiten und kommt eher in klinischen Studien oder längerfristigen agrarwissenschaftlichen Experimenten vor.

::: panel-tabset
## `{base}`

Die Frage ist jetzt immer, wie schreibe ich jetzt das Modell richtig? Der komplizierte Teil ist eigentlich der Fehlerterm `Error()` aber auch der Teil davor. Ich nutze hier wieder die Kurzschreibweise mit dem Stern `*` um alle Faktorkombinationen plus Interaktion im Modell zu haben. Das wird eben dann ab schon zwei Faktoren etwas groß und mit drei Faktoren sehr unübersichtlich. So ist es dann weniger anfällig für Fehler. Dann musst du noch darauf achten, dass du in dem Fehlerterm die Klammern richtig setzt, sonst funktioniert es dort auch nicht. Erst kommt der Spaltenname für die einzelnen Flöhe `.id` und dahinter nach dem Slash `/` dann die Faktorkombinationen der Behandlungen und der Zeit. Dann räume ich die Ausgabe nochmal vollkommen auf, damit ich auch was sehe.

```{r}
aov(jump_length ~ feeding * workout * time_fct + 
      Error(.id/(feeding * workout * time_fct)), 
    data = repeated_fac3_tbl) |> 
  tidy() |> 
  na.omit() |> 
  select(term, df, statistic, p.value) |> 
  mutate(p.value = pvalue(p.value))
```

Wir erhalten jetzt eine Menge an Ausgabe wieder. Insbesondere die vielen Interaktionen führen natürlich zu mehr Ausgabe. Aber auch hier sind erstmal die Haupteffekte der Art der Fütterung und des Workout am interessantesten. Wir sehen hier, dass beide Faktoren signifikant sind, der p-Wert liegt unter dem Signifikanzniveau von $\alpha$ gleich 5%. Wir haben dann auch eine signifikante Zeitkomponente. Daher werden sich die Sprungweiten auch über die Zeit ändern. Am Ende ist dann nur die Interaktion zwischen der Fütterungsart und der Zeit signifikant. Anscheinend verhalten sich die Fütterungsarten nicht gleich über alle Zeitpunkte hinweg.

Dann können wir noch die Effektschätzer Eta$^2$ für alle Faktoren und deren Interaktionen berechnen. Ich habe dann auch hier aufgeräumt und die Eta$^2$-Werte einmal gerundet, damit du besser sehen kannst, welche der Werte überhaupt größer sind. Auch hier sehen wir dann, dass die Hauptfaktoren den größten Effekt haben, gefolgt von den Zeitpunkten und der Interaktion zwischen den Fütterungsarten und der Zeit.

```{r}
aov(jump_length ~ feeding * workout * time_fct + 
      Error(.id/(feeding * workout * time_fct)), 
    data = repeated_fac3_tbl) |> 
  eta_squared(generalized = c("time_fct")) |> 
  select(Parameter, Eta2_generalized) |> 
  mutate(Eta2_generalized = round(Eta2_generalized, 2))
```

## `{rstatix}`

Das R Paket `{rstatix}` hat eine andere Schreibweise des Modells. Im Prinzip schreiben wir hier wieder nicht das Modell auf, sondern weisen die Spaltennamen dann den jeweiligen Optionen zu. Hier werden dann auch alle Interaktionen gerechnet, du kannst die Interaktionen aller Faktorkombinationen nicht abstellen. Wir setzten dann unseren Endpunkt `jump_length` in die Option `dv` und die einzelnen Beobachtungen in die Option `wid`. Dann müssen wir noch die beiden Faktoren der Zeit und der beiden Behandlungen in die Option `within` einfügen. Dann haben wir auch schon alles zusammen. Was hier etwas doof ist, ist das wir hier die Formelschreibweise in R verlassen, die wir dann aber überall sonst nutzen. Dafür erhalten wir dann aber das Eta$^2$ gleich als `ges` wieder aus der Funktion zurück.

```{r}
rstatix_aov <- anova_test(data = repeated_fac3_tbl, 
                          dv = jump_length, wid = .id, 
                          within = c(feeding, workout, time_fct))
get_anova_table(rstatix_aov)
```

Wir erhalten die gleichen Ergebnisse wie schon bei der Funktion `aov()` wiedergegeben. Das überrascht auch nicht, den die Berechnung ist ja die gleiche Berechnung wie auch in `aov()` nur eben dann mit einem anderen Funktionsaufruf.

## `{afex}`

Das R Paket `{afex}` nutzt die Formelschreibweise und kann auch genau so bedient werden wie schon die Funktion `aov()`. Dafür können wir aber mit der Option `type` auch anderen Typen der ANOVA nutzen und nicht nur die Type I ANOVA in `aov()`. Das ist eigentlich die große Stärke von dem R Paket `{afex}`, dass wir hier flexibel bei der Auswahl der Typen sind. Bei der einfaktoriellen ANOVA war es noch egal, aber hier macht es mit zwei Faktoren dann schon einen Unterschied welche Art der ANOVA du rechnen möchtest. Ich nutze hier den Standard und damit die Type III ANOVA. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben.

```{r}
#| message: false
#| warning: false
aov_car(jump_length ~ feeding * workout * time_fct + 
          Error(.id/feeding * workout * time_fct), 
        data = repeated_fac3_tbl)
```

Die Ergebnisse sind ähnlich wie schon bei den beiden anderen Algorithmen, aber hier macht es dann einen Unterschied welche ANOVA grechnet wird. Wir rechnen hier dann ja eine Type 3 ANOVA. Die p-Werte sind aber alle so gering, dass es dann am Ende keinen so großen Unterschied mehr macht.

Das R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.

```{r}
#| message: false
#| warning: false
#| eval: false
aov_4(jump_length ~ feeding * workout * time_fct + 
        (feeding * workout * time_fct|.id), 
      data = repeated_fac3_tbl)
```

## `{MANOVA.RM}`

Am Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem dreifaktoriellen Fall die ähnlichen Werte wie in den anderen R Paketen erhalten. Je mehr Faktoren wir haben desto stärker werden dann auch die Unterschiede, da natürlich auch mehr Parameter geschätzt werden müssen. Hier haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht. Ich habe dann einmal hier die Anzeige der Funktion ausgeschaltet, da hier der Output dann sehr lang wird. Du kannst dir beispielhaft die Ausgabe einmal bei der einfaktoriellen repeated ANOVA weiter oben einmal anschauen oder eben den Code selber einmal durchführen.

```{r}
#| message: false
#| warning: false
#| eval: false
RM(jump_length ~ feeding * workout * time_fct, data = repeated_fac3_tbl, 
   subject = ".id", within = c("feeding", "workout", "time_fct"), iter = 100, 
   resampling = "Perm", seed = 1234) |> 
  summary()
```
:::

Damit haben wir es dann auch geschafft. Was ist noch kommt sind die Anwendungsbeispiele in der mixed ANOVA. Ich habe noch keine Daten für eine repeated ANOVA bei mir liegen, daher warte ich hier mal ab, was noch kommt.

:::: callout-tip
## Anwendungsbeispiel: Gurkenwachstum (2-faktoriell mixed ANOVA)

```{r}
#| message: false
#| warning: false

gurke_tbl <- read_excel("data/wachstum_gurke.xlsx") |> 
  clean_names() |> 
  select(group = versuchsgruppe, t1:t14) |>
  mutate(group = as_factor(group)) 
```

```{r}
#| message: false
#| echo: false
#| tbl-cap: "Datensatz zu dem Längen- und Dickenwachstum von Gurken."
#| label: tbl-anwendung-gurke

gurke_raw_tbl <- read_excel("data/wachstum_gurke.xlsx") |> 
  clean_names() |> 
  select(group = versuchsgruppe, t1:t4) |>
  mutate_if(is.numeric, round, 2)

rbind(head(gurke_raw_tbl, n = 3),
      rep("...", times = ncol(gurke_raw_tbl)),
      tail(gurke_raw_tbl, n = 3)) |> 
  tt(width = 1, align = "c", theme = "striped")

```

```{r}
gurke_time_len_tbl <- gurke_tbl |> 
  filter(str_detect(group, "L$")) |> 
  rownames_to_column(".id") |> 
  mutate(group = factor(group, labels = c("Proloog", "Quarto", "Katrina"))) |> 
  pivot_longer(cols = t1:t14,
               values_to = "length",
               names_to = "time") |> 
  mutate(time_fct = as_factor(time),
         time_num = as.numeric(time_fct)) |> 
  filter(length != 0)
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-anwendung-gurke-01
#| fig-align: center
#| fig-height: 5
#| fig-width: 8
#| fig-cap: "Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar."

ggplot(gurke_time_len_tbl, 
       aes(time_fct, length, color = group, 
           group = group)) +
  theme_minimal() +
  geom_point() +
  stat_summary(fun = "mean", geom = "line") +
  stat_summary(fun = "median", geom = "line", linetype = 2) +
  scale_color_okabeito() +
  theme(legend.position = "top")+
  labs(x = "Zeitpunkte der Messung", y = "Gurkenlänge [cm]",
       color = "Sorte")
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-anwendung-gurke-02
#| fig-align: center
#| fig-height: 5
#| fig-width: 8
#| fig-cap: "Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar."

ggplot(gurke_time_len_tbl, 
       aes(time_fct, log(length), color = group, 
           group = .id)) +
  theme_minimal() +
  geom_point2() +
  geom_line(linetype = 11) +
  scale_color_okabeito() +
  theme(legend.position = "top")+
  labs(x = "Zeitpunkte der Messung", y = "Gurkenlänge [cm] (log-scale)",
       color = "Sorte")
```

::: panel-tabset
## `aov_car()`

```{r}
#| message: false
#| warning: false
aov_car(length ~ group * time_fct + Error(.id/time_fct), 
        data = gurke_time_len_tbl)
```

## `aov_4`

```{r}
#| message: false
#| warning: false
aov_4(length ~ group * time_fct + (time_fct|.id), 
      data = gurke_time_len_tbl)
```
:::

```{r}
#| message: false
#| warning: false

aov_car(length ~ group * time_fct + Error(.id/time_fct), 
        data = gurke_time_len_tbl) |> 
  emmeans(~ group | time_fct, adjust = "none") |> 
  cld(Letters = letters)
```
::::

:::: callout-tip
## Anwendungsbeispiel: Grünkohlhöhe (3-faktoriell mixed ANOVA)

```{r}
#| message: false
#| warning: false

kale_tbl <- read_excel("data/kale_time_height.xlsx") |> 
  clean_names() |> 
  select(light, variety, t1:t7) |>
  mutate(light = as_factor(light),
         variety = as_factor(variety)) 
```

```{r}
#| message: false
#| echo: false
#| tbl-cap: "Datensatz zu dem Längen- und Dickenwachstum von Gurken."
#| label: tbl-anwendung-kale

kale_raw_tbl <- read_excel("data/kale_time_height.xlsx") |> 
  clean_names() |> 
  select(light, variety, t1:t2) |>
  mutate_if(is.numeric, round, 2)

rbind(head(kale_raw_tbl, n = 3),
      rep("...", times = ncol(kale_raw_tbl)),
      tail(kale_raw_tbl, n = 3)) |> 
  tt(width = 1, align = "c", theme = "striped")

```

```{r}
kale_time_height_tbl <- kale_tbl |> 
  rownames_to_column(".id") |> 
  pivot_longer(cols = t1:t7,
               values_to = "height",
               names_to = "time") |> 
  mutate(time_fct = as_factor(time),
         time_num = as.numeric(time_fct)) 
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-anwendung-kale-02
#| fig-align: center
#| fig-height: 5
#| fig-width: 8
#| fig-cap: "Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar."

ggplot(kale_time_height_tbl, 
       aes(time_fct, height, color = light, linetype = variety,
           group = .id)) +
  theme_minimal() +
  geom_line() +
  scale_color_okabeito() +
  theme(legend.position = "top")+
  labs(x = "Zeitpunkte der Messung", y = "Gurkenlänge [cm] (log-scale)",
       color = "Licht", linetype = "Sorte")
```

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-anwendung-kale-01
#| fig-align: center
#| fig-height: 5
#| fig-width: 8
#| fig-cap: "Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar."

ggplot(kale_time_height_tbl, 
       aes(time_fct, height, color = light, linetype = variety,
           shape = variety,
           group = interaction(light, variety))) +
  theme_minimal() +
  geom_point() +
  stat_summary(fun = "mean", geom = "line") +
  scale_color_okabeito() +
  theme(legend.position = "top")+
  labs(x = "Zeitpunkte der Messung", y = "Gurkenlänge [cm]",
       color = "Licht", shape = "Sorte", linetype = "Sorte") 
  
```

::: panel-tabset
## `aov_car()`

```{r}
#| message: false
#| warning: false
aov_car(height ~ light * variety * time_fct + Error(.id/time_fct), 
        data = kale_time_height_tbl)
```

## `aov_4`

```{r}
#| message: false
#| warning: false
aov_4(height ~ light * variety * time_fct + (time_fct|.id), 
      data = kale_time_height_tbl)
```
:::

```{r}
#| echo: true
#| message: false
#| warning: false
#| label: fig-anwendung-kale-03
#| fig-align: center
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar."

eta_2_vec <- map_dbl(0:5, \(i) {
  aov_car(height ~ light * variety * time_fct + Error(.id/time_fct), 
        data = filter(kale_time_height_tbl, time_num > i)) |> 
    eta_squared(generalized = "time_fct") |> 
    pull(Eta2_generalized) |> 
    extract(5)
})

tibble(time = as_factor(c("alle", ">t1", ">t2", ">t3", ">t4", ">t5")),
       eta2 = eta_2_vec) |> 
  ggplot(aes(time, eta2, group = 1)) +
  theme_minimal() +
  geom_line() +
  scale_y_continuous(limits = c(0, 0.05)) +
  labs(x = "Betrachtete Zeitpunkt", y = expression("Eta"^2))

```

```{r}
#| message: false
#| warning: false

aov_car(height ~ light * variety * time_fct + Error(.id/time_fct), 
        data = kale_time_height_tbl) |> 
  emmeans(~ light * variety | time_fct, adjust = "none") |> 
  cld(Letters = letters)
```
::::

## Referenzen {.unnumbered}
