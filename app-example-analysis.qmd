```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, openxlsx)
```

# Beispielhafte Auswertungen {#sec-beispiel-auswertung}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: callout-tip
## Beispielhafte Auswertungen per Video

Du findest auf YouTube in der Playlist [Spielweise in R (Level 3)](https://www.youtube.com/playlist?list=PLe51bCp9JvEFZeYClBKad6yurjUzc8jXp) als Video Reihe. Ich werde zwar alles nochmal hier als Text aufschreiben, aber manchmal ist das Sehen und Hören dann einfacher.
:::

Worum geht es in diesem Kapitel? Ich rechne hier fröhlich Dinge und präsnetiere dann die Ergebnisse. Das heißt, du findest hier beispielhafte Auswertungen, die eventuell auch deine Problemstellung betreffen.

-   In @sec-app-example-iso schauen wir uns einmal die Erstellung eines Isoplethendiagramms für Münster & Osnabrück aus den frei verfügbaren Daten des Deutschen Wetterdienstes an.
-   In @sec-app-example-number-groups rechnen wir einmal ein simples Beispiel für Zähldaten in zwei Gruppen. Wir haben hier nicht wiederholt gezählt, sondern nur jeweils einmal an einer Stelle.
-   In @sec-app-example-anova-inter rechnen wir nochmal eine zweifaktorielle ANOVA mit Interaktionsterm durch. Wir kriegen dann unser *compact letter display* wie auch die Konfidenzintervalle wieder.

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, readxl, 
               broom, multcomp, emmeans, 
               conflicted, effectsize, report,
               see, metR, parameters)
## resolve some conflicts with same function naming
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Isoplethendiagramm für Münster & Osnabrück {#sec-app-example-iso}

Im Folgenden zeige ich ein Beispiel für die Nutzung der [entgeltfreien Informationen auf der DWD-Website](https://www.dwd-shop.de/index.php/default/kostenfreie-informationen.html). Wir finden dort auf der Seite die [Klimadaten für Deutschland](https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html#buehneTop) und natürlich auch die Daten für Münster/Osnabrück. Ich habe mir flux die Tageswerte runtergeladen und noch ein wenig den Header der txt-Datei angepasst. Du findest die Datei [`day_values_osnabrueck.txt`](https://github.com/jkruppa/jkruppa.github.io/tree/master/data) wie immer auf meiner GitHub Seite. Du musst dir für andere Orte die Daten nur entsprechend zusammenbauen. Am Ende brauchen wir noch die [Informationen zu den Tages- und Monatswerten](https://www.dwd.de/DE/leistungen/klimadatendeutschland/beschreibung_tagesmonatswerte.html) damit wir auch verstehen, was wir uns da von der DWD runtergeladen haben. Ich nutze gleich nur einen Ausschnitt aus den Daten.

::: column-margin
Wenn wir [Geocomputation with R](https://geocompr.robinlovelace.net/index.html) machen wollen, dann haben wir natürlich noch viele andere Möglichkeiten. Das verlinkte Buch hilft da weiter.
:::

Dann lesen wir die Daten einmal ein und müssen dann eine Winkelzüge machen, damit wir aus dem Datum `JJJJMMDD` dann jeweils den Monat und den Tag extrahiert kriegen. Dann müssen wir die Monatszahl und die Tageszahl noch in eine Zahl umwandeln. Sonst geht es schlecht mit dem Zeichnen des Konturplots. Wir nehmen dann die Temperaturen `TG`, `TN`, `TM` und `TX` um diese Temperaturen in vier Konturplots zu zeigen.

```{r}
#| message: false
#| echo: true
#| warning: false

weather_tbl <- read_table("data/day_values_osnabrueck.txt") %>% 
  mutate(JJJJMMDD = as.Date(as.character(JJJJMMDD), "%Y%m%d"),
         day = as.numeric(format(JJJJMMDD, "%d")), 
         month = as.numeric(format(JJJJMMDD, "%m")), 
         year = as.numeric(format(JJJJMMDD, "%Y"))) %>% 
  select(month, day, TG, TN, TM, TX) %>% 
  na.omit() %>% 
  gather(temp, grad, TG:TX) %>% 
  mutate(temp = factor(temp, 
                       labels = c("Minimum der Temperatur in 5 cm (TG)",
                                  "Minimum der Temperatur in 2 m (TN)",
                                  "Mittel der Temperatur in 2 m (TM)",
                                  "Maximum der Temperatur in 2 m (TX)")))

```

Nachdem wir ordentlich an den Daten geschraubt haben können wir jetzt in @fig-weather die vier Konturplots sehen. Wir mussten noch das Spektrum der Farben einmal drehen, damit es auch mit den Temperaturfarben passt und wir haben noch ein paar Hilfslinien miteingezeichnet.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-weather
#| fig-align: center
#| fig-height: 9
#| fig-width: 9
#| fig-cap: "Konturplot der verschiedenen Temperaturen."
#| column: page

ggplot(weather_tbl, aes(month, day, z = grad)) +
  theme_minimal() +
  geom_contour_filled(bins = 13) +
  geom_contour(binwidth = 2, color = "black") +
  facet_wrap(~ temp, ncol = 2) + 
  scale_fill_brewer(palette = "Spectral", direction = -1) +
  scale_x_continuous(breaks = 1:12) +
  geom_vline(xintercept = 1:12, alpha = 0.9, linetype = 2) +
  geom_hline(yintercept = c(5, 10, 15, 20, 25, 30), 
             alpha = 0.9, linetype = 2)

```

## Analyse von Anzahlen in zwei Gruppen {#sec-app-example-number-groups}

In dieser sehr simplen Analyse haben wir zwei Gruppen vorliegen. Die Gruppe 1 ist hat zwei Level oder Behandlungen abgekürzt mit I und II. Die Gruppe 2 hat insgesamt vier Level oder eben Behandlungen, die wir mit A, B, C und D bezeichnen. Wir haben jetzt für die jeweiligen Kombinationen auf dem Feld etwas *gezählt*. Wir haben also für jede dieser Kombinationen nur eine Zahl. Es ergbit sich somit die folgende Matrix an Zahlen.

```{r}
rel_mat <- matrix(c(45, 14, 4, 0,
                    25, 32, 5, 1), nrow = 2, byrow = TRUE,
                  dimnames = list(c("I", "II"), c("A", "B", "C", "D")))
rel_mat
```

Nun können wir den $\mathcal{X}^2$-Test nutzen, um zu testen, ob die Zahlen in der Matrix bzw. auf unseren Feld gelcihverteilt sind. Die Nullhypothese lautet, dass es keinen Zusammenhang zwischen der Gruppe 1 und der Gruppe 2 auf dem Feld gibt. Die Zahlen sind also rein zufällig in dieser Anordnung.

```{r}
#| warning: false
chisq.test(rel_mat)
```

Wir erhalten einen sehr kleinen $p$-Wert mit $0.003$. Wir können daher die Nullhypothese ablehnen, da der $p$-Wert kleiner ist als das Signifikanzniveau $\alpha$ mit 5%. Wir haben ein signifikantes Ergebnis. Wir können von einen Zusamenhang zwischen den beiden Gruppen ausgehen.

Mit Cramers V können wir auch noch die Effektstärke für einen $\mathcal{X}^2$-Test berechnen.

```{r}
cramers_v(rel_mat) 
```

Der Effekt ist mit $0.33$ nicht besonders stark. Du kannst Cramers V wie die Korrelation interpretieren. Ein V von 0 bedeutet keinen Zusammenhang und ein V von 1 einen maximalen Zusammenhang. Wir wollen uns die Daten dann nochmal in einer Abbidlung anschauen. Dafür müssen wir die Matrix erstmal in einen Datensatz umwandeln und die Gruppen zu Faktoren machen.

```{r}
plot_tbl <- rel_mat %>% 
  as_tibble(rownames = "group1") %>% 
  gather(A:D, key = "group2", value = "value") %>% 
  mutate(group1 = as_factor(group1),
         group2 = as_factor(group2))
```

In @fig-app-count-1 sehen wir die Matrix der Zähldaten für die beiden Gruppen nochmal visualisiert. Beim betrachten fällt auf, dass die beiden Level C und D kaum Zähldaten enthalten. Hier wäre zu überlegen die beiden Level aus der Analyse herauszunehmen und einen klassischen $\mathcal{X}^2$-Test auf einer 2x2 Kreuztabelle zu rechnen.

```{r}
#| message: false
#| warning: false
#| echo: true
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: Barplot der Zähldaten aus der Matrix. 
#| label: fig-app-count-1

ggplot(plot_tbl, aes(x = group2, y = value, fill = group1)) +
  theme_bw() +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(x = "Gruppe 2", y = "Anzahl", fill = "Gruppe 1") +
  scale_fill_okabeito() 
```

## Auswertung zweifaktorielle ANOVA mit Interaktion {#sec-app-example-anova-inter}

```{r}
light_tbl <- read_excel("data/light_intensity_data.xlsx") %>% 
  mutate(rack = factor(rack, labels = c("left", "middle", "right")),
         layer = factor(layer, labels = c("1st", "2nd", "3rd")),
         light_intensity = factor(light_intensity, labels = c("low", "mid", "high")),
         growth = as.numeric(growth))
```

```{r}
ggplot(light_tbl, aes(light_intensity, growth, fill = rack)) +
  theme_bw() +
  geom_boxplot() +
  scale_fill_okabeito()
```

```{r}
ggplot(light_tbl, aes(light_intensity, growth, fill = layer)) +
  theme_bw() +
  geom_boxplot()  +
  scale_fill_okabeito()
```

```{r}
ggplot(light_tbl, aes(light_intensity, growth, fill = rack)) +
  theme_bw() +
  geom_boxplot() +
  facet_wrap(~ layer)  +
  scale_fill_okabeito()
```

```{r}
#| warning: false
#| message: false

fit_1 <- lm(growth ~ light_intensity + layer + light_intensity:layer, 
            data = light_tbl)
fit_1 %>% model_parameters()
```

```{r}

comp_1_obj <- fit_1 %>% 
  emmeans(specs = ~ light_intensity | layer) %>% 
  contrast(method = "pairwise", adjust = "bonferroni") 
  
```

```{r}
comp_1_obj %>% 
  summary %>% 
  as_tibble %>% 
  select(contrast, layer, p.value) %>% 
  mutate(p.value = format.pval(p.value, eps = 0.001, digits = 2))
```

```{r}
ci_obj <- comp_1_obj %>% 
  confint() %>% 
  as_tibble() %>% 
  select(contrast, layer, estimate, conf.low = lower.CL, conf.high = upper.CL) 

ci_obj
```

```{r}
ggplot(ci_obj, aes(contrast, y=estimate, ymin=conf.low, ymax=conf.high,
                   color = layer, group = layer)) +
  geom_hline(yintercept=0, linetype="11", colour="grey60") +
  geom_errorbar(width=0.1, position = position_dodge(0.5)) + 
  geom_point(position = position_dodge(0.5)) +
  scale_color_okabeito() +
  coord_flip() +
  theme_classic()
```

```{r}

fit_1 %>% 
  emmeans(specs = ~ light_intensity | layer)  %>%
  cld(Letters = letters, adjust = "bonferroni") 
  
```

## Auswertung von Gewichten

```{r}
#| echo: false
data_tbl <- expand_grid(trt = 1:3, 
                        block = 1:3,
                        rep = 1:4) %>% 
  mutate(rsp = 10 + 2 * trt + block + rnorm(n(), 0, 2),
         trt = factor(trt, labels = c("low", "mid", "high")),
         block = factor(block, labels = c("I", "II", "III")))
```

```{r}
#| echo: false
data_tbl %>% 
  mutate(rsp = round(rsp, 2)) %>% 
  kable(align = "c", "pipe")
```

### Explorative Datenanalyse (EDA)

```{r}
ggplot(data_tbl, aes(trt, rsp, color = block)) +
  geom_boxplot()
```

```{r}
#| message: false

stat_tbl <- data_tbl %>% 
  group_by(trt, block) %>% 
  summarise(mean = mean(rsp),
            sd = sd(rsp),
            se = sd/sqrt(n()))

ggplot(stat_tbl, aes(x = trt, y = mean, fill = block)) + 
    geom_bar(position = position_dodge(), stat = "identity") +
    geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),
                  width = 0.2,
                  position = position_dodge(.9))
```

### Lineares Modell

```{r}
fit_1 <- lm(rsp ~ trt + block, data = data_tbl)

```

### ANOVA

```{r}
fit_1 %>% anova
```

### Gruppenvergleich mit dem `multcomp` Paket

https://broom.tidymodels.org/reference/tidy.glht.html

```{r}

fit_1 %>% 
  glht(linfct = mcp(trt = "Tukey")) %>% 
  tidy %>% 
  select(contrast, estimate, adj.p.value) %>% 
  mutate(across(where(is.numeric), round, 4))



```

### Gruppenvergleich mit der `emmeans` Paket

https://broom.tidymodels.org/reference/tidy.emmGrid.html

```{r}
fit_1 %>% 
  emmeans("trt") %>% 
  contrast(method = "pairwise") %>% 
  tidy %>% 
  select(contrast, estimate, adj.p.value) %>% 
  mutate(across(where(is.numeric), round, 4))

```

## Auswertung von Boniturnoten

```{r}
#| echo: false 

data_tbl <- tibble(block = 1:5,
                   A = c(2,3,4,3,2),
                   B = c(7,9,8,9,7),
                   C = c(6,5,4,7,4),
                   D = c(2,4,1,2,3),
                   E = c(4,5,3,7,6)) %>%
  gather(key = "variety", value = "rating", A:E) %>% 
  mutate(variety = as_factor(variety),
         block = factor(block, labels = c("I", "II", "III", "IV", "V"))) %>% 
 select(variety, block, rating)


data_tbl <- tibble(block = rep(1:3, each = 5),
                   A = c(2,3,3,4,1,3,2,2,4,4,2,2,3,1,2),
                   B = c(8,9,8,9,7,7,7,8,8,7,8,9,7,9,8),
                   C = c(6,5,5,6,4,4,5,3,6,4,7,6,4,6,4),
                   D = c(2,4,1,2,2,2,4,4,1,3,3,4,2,1,3),
                   E = c(4,4,2,7,5,4,3,4,7,7,5,5,4,6,6)) %>%
  gather(key = "variety", value = "rating", A:E) %>% 
  mutate(variety = as_factor(variety),
         block = factor(block, labels = c("I", "II", "III"))) %>% 
  select(variety, block, rating) %>% 
  arrange(variety, block)  

#data_tbl <- tibble(A = sample(1:9, 18, replace = TRUE, 
#                              prob = c(0, 0, 0, 0, 0.1, 0.2, 0.4, 0.2, 0.1)),
 #                  B = sample(1:9, 18, replace = TRUE, 
  #                            prob = c(0, 0, 0.1, 0.2, 0.4, 0.2, 0.1, 0, 0)),
   #                C = sample(1:9, 18, replace = TRUE, 
    #                          prob = c(0, 0, 0, 0.1, 0.2, 0.4, 0.2, 0.1, 0)),
     #              D = sample(1:9, 18, replace = TRUE, 
      #                        prob = c(0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.3))) %>% 
  #gather(key = "trt", value = "rating") %>% 
  #mutate(trt = as_factor(trt), 
   #      block = rep(gl(3, 6), 4),
    #     block = factor(block, labels = c("I", "II", "III"))) %>% 
#  select(trt, block, rating)

```

```{r}
#| echo: false
data_tbl %>% 
  kable(align = "c", "pipe")
```

### Explorative Datenanalyse (EDA)

```{r}
#| message: false

ggplot(data_tbl, aes(variety, rating, color = block)) +
  geom_boxplot() +
  geom_dotplot(aes(fill = block), binaxis = "y", stackdir='center', 
               position=position_dodge(0.8))  

```

```{r}
#| message: false

ggplot(data_tbl, aes(variety, rating, fill = block)) +
  geom_dotplot(binaxis = "y", stackdir='center', 
               position=position_dodge(0.8)) +
  stat_summary(fun = median, fun.min = median, fun.max = median,
               geom = "crossbar", width = 0.5, 
               position=position_dodge(0.8)) 

```

### Friedman Test

```{r}

#friedman.test(rating ~ variety | block, data = data_tbl)

data_tbl <- tibble(Block = 1:4,
                   Sorte_1 = c(2,3,4,3),
                   Sorte_2 = c(7,9,8,9),
                   Sorte_3 = c(6,5,4,7),
                   Sorte_4 = c(2,4,1,2),
                   Sorte_5 = c(4,5,3,7)) %>%
  gather(key, value, Sorte_1:Sorte_5)

friedman.test(value ~ key | Block, data = data_tbl)


```

## Auswertung von Infektionsstatus
