```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc,
               grid, agricolae, patchwork, desplot, modelr)
```

# Versuchsplanung in R {#sec-experimental-design-r}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: column-margin
Ein Weiteres umfangreiches Tutorium liefert [DSFAIR von P. Schmidt](https://schmidtpaul.github.io/DSFAIR/DesigningExperiments.html). Hier finden sich auch weiterführende Literatur und weitere Beispiele.
:::

In diesem Kapitel wollen wir uns die Versuchsplanung in R einmal genauer anschauen. Das heißt, dass wir hier den Fokus auf die Funktionen und Pakete legen. In den dann folgenden Kapiteln schauen wir uns die Anwendung auf die gängigen experimentellen Designs in den Agrarwissenschaften an. Wie immer schauen wir erst auf die Anwendung und gehen dann auf die Theorie. Das ist in diesem Kapitel im Besonderen der Fall. Mir geht es hier mehr um die technische Umsetzung als um den eigentlichen Hintergrund.

Wenn wir über die Versuchsplanung und R sprechen, dann kommen wir an folgender Sammlung nicht vorbei.

-   [Design of Experiments (DoE) & Analysis of Experimental Data](https://cran.r-project.org/web/views/ExperimentalDesign.html)

Nirgendwo sonst findest du so einen Überblick über mögliche Pakete und Anwendungen in R. Wir schauen uns hier dann nur eine Auswahl an Möglichkeiten an. Ich selber habe mir noch nicht alles angeschaut, dass ist einfach zu viel. Je nach Fragestellung bietet sich ja auch ein anderes Paket an. Wir belassen es wie immer bei den Grundlagen. Die Grundlagen sind ja meistens dann ausreichend und manchmal auch schon kompliziert genug.

Jetzt müssen wir doch noch auf den Begriff *nested* (deu. *verschachtelt*) kommen. Wenn wir über *nested* sprechen, dann meinen wir, dass Faktoren ineinander verschachtelt sind. Mit Faktoren meine ich experimentelle Bedingungen. Das klingt jetzt etwas wirr, aber wir machen das mal an einem Beispiel fest. Wir haben den Faktor `table` und *auf* dem Tisch stehen die Behandlungen des Faktors `trt` mit den jeweiligen Pflanzen. Also ist die Behandlung in den Tischen *genested*. Die Tische mögen in verschiedenen Gewächshäusern mit dem Faktor `location` stehen, also sind die Tische in den Gewächshäusern genested. Wir haben folgendes Schema vorliegen.

::: column-page
$$
\mbox{Wiederholungen} \xrightarrow[]{nested} \overbrace{\mbox{Behandlungen}}^{f_1} \xrightarrow[]{nested} \underbrace{\mbox{Tische}}_{f_2} \xrightarrow[]{nested} \overbrace{\mbox{Gewächshauser}}^{f_3} 
$$
:::

Damit haben wir dann aber auch *meistens* folgende Abhängigkeit von den jeweiligen Beobachtungen untereinander nach der wir dann unser Experiment planen müssen.

::: column-page
$$
\overbrace{\mbox{Gewächshauser}}^{f_3} \xrightarrow[]{beinhaltet\; alle} \underbrace{\mbox{Tische}}_{f_2} \xrightarrow[]{beinhaltet\; alle} \overbrace{\mbox{Behandlungen}}^{f_1} \xrightarrow[]{beinhaltet\; alle} \mbox{Wiederholungen}
$$
:::

Okay, das ist jetzt abstrakt. Machen wir das mal konkret mit einem Beispiel mit drei Behandlungen gegen Blattläuse auf jeweils vier Tischen in drei Gewächshäusern. Pro Behandlung nehmen wir fünf Pflanzen. Damit ergibt sich folgendes Schema mit den jeweiligen Anzahlen darübergeschrieben.

::: column-page
$$
\overbrace{\mbox{Gewächshauser}}^{n_g = 3} \xrightarrow[]{beinhaltet\; alle} \underbrace{\mbox{Tische}}_{n_t = 4} \xrightarrow[]{beinhaltet\; alle} \overbrace{\mbox{Behandlungen}}^{n_b = 3} \xrightarrow[]{beinhaltet\; alle} \underbrace{\mbox{Wiederholungen}}_{n_w = 5}
$$
:::

Jetzt können wir auch ausrechnen, wie viele Pflanzentöpfe wir brauchen. Wir multiplizieren alle $n$-Angaben miteinander und erhalten $n_{gesamt} = n_g \cdot n_t \cdot n_b \cdot n_w = 3 \cdot 4 \cdot 3 \cdot 5 = 180$ Pflanzen. Jetzt ist immer die Frage, sind das zu viele oder zu wenig? Das wollen wir uns dann am Ende in dem Kapitel zur Fallzahlplanung anschauen. Hier geht es erstmal um die technische Umsetzung.

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
set.seed(20230812)
pacman::p_load(tidyverse, magrittr, writexl, agricolae,
               desplot, dae,
               conflicted)
conflicts_prefer(magrittr::set_names)
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Selbermachen mit `expand_grid()`

Wenn wir uns das experimentelle Design selber zusammen programmieren können wir auf das `tidyverse` Paket zurückgreifen und haben dann ein schöneres Leben. Wir müssen zwar etwas mehr beachten, aber dafür sind wir auch sehr viel mehr flexibel. Deshalb stelle ich für die einfacheren Designs in den folgenden Kapiteln auch immer den Code zum Selbermachen vor. Hier gibt es jetzt einmal die Grundidee am *Complete randomized design (CRD)*. Wir gehen immer von einem balancierten Design aus, dass heißt in jeder Behandlungsgruppe sind gleich viele Beobachtungen.

Nehmen wir folgendes simples Modell. Wir wollen untersuchen, ob das Trockengewicht *drymatter* von einer Behandlung *trt* abhängt. Wir werden uns dann gleich noch entscheiden, wie viele Behandlungsgruppen wir wollen und wie viele Wiederholungen wir pro Behandlungsgruppe nehmen.

$$
drymatter \sim \overbrace{trt}^{f_1} 
$$

Zentral für unsere Überlegungen ist die Funktion `expand_grid()`, die es uns einfach erlaubt alle Faktorkombinationen aus zwei oder mehr Vektoren zu erstellen. Wir haben im Folgenden im Vektor `a` die Zahlen 1 bis 3 und in dem Vektor `b` die Zahlen 1 und 2. Jetzt wollen wir alle Kombinationen von `a` und `b` haben und nutzen dafür `expand_grid()`.

```{r}
expand_grid(a = 1:3, b = 1:2)
```

Jetzt einmal konkreter auf unser Beispiel angewandt. Wir wollen vier Behandlungsgruppen und in jeder Behandlungsgruppe fünf Wiederholungen `rep`. Dann benennen wir noch die Behandlungen mit `ctrl`, `A`, `B` und `C`. Unsere Wiederholungen kriegen die Zahlen von 1 bis 5. Dann ergänzen wir noch eine Pflanzenidentifizierungsnummer `pid` über die wir dann später randomisieren können. Wenn du willst, kannst du dir dann über `select()` noch die Spalten sauber sortieren.

```{r}
crd_long_tbl <- expand_grid(trt = 1:4, rep = 1:5) %>% 
  mutate(trt = factor(trt, labels = c("ctrl", "A", "B", "C")),
         rep = factor(rep, labels = 1:5),
         pid = 1:n()) %>% 
  select(pid, everything())
crd_long_tbl
```

Dann kannst du dir die Datei mit der Funktion `write_xlsx()` aus dem R Paket `writexl` raus schreiben und dann entsprechend mit deinen Messwerten für das Trockengewicht ergänzen.

```{r}
#| eval: false
#| message: false
#| warning: false
crd_long_tbl %>% 
  write_xlsx("template_sheet.xlsx")
```

Wenn du für deine zwanzig Pflanzen noch ein Randomisierungmuster brauchst, dann empfehle ich dir die Folgende schnelle Art und Weise. Du nimmst die Pflanzen ID's von 1 bis 20 und mischt die Zahlen einmal mit der Funktion `sample()` durch. Dann erstellst du dir als dein Grid für deine Pflanzen mit einer $4 \times 5$-Matrix und pflanzt nach diesem Grid die Pflanzen ein.

```{r}
crd_long_tbl$pid %>% 
  sample() %>% 
  matrix(nrow = 4, ncol = 5,
         dimnames = list(str_c("Reihe", 1:4, sep = "-"),
                         str_c("Spalte", 1:5, sep = "-")))
```

Es gibt natürlich noch andere Möglichkeiten, aber das ist jetzt die schnellste Variante ein gutes Randomisierungsmuster hinzukriegen.

## Das R Paket `agricolae`

Für die Erstellung von komplexeren experimentellen Designs führt kein Weg an dem R Paket `agricolae` vorbei. Bei den einfacheren Designs ist es dann so eine Sache, ob du dir mit `agricolae` einen Gefallen tust oder eher die Sache sehr stark verkomplizierst. Ich würde dir bei den einfacheren Designs empfehlen einfach `exoand_grid()` wie oben beschrieben zu nutzen. Das ist einfacher und funktioniert auch gut, wenn nicht gar besser. Darüber hinaus ist die Hilfe der Funktionen teilweise etwas sehr mager und die Weiterentwicklung eher fraglich. Für das Paket `agricolae` gibt es zwe i ziemlich identische Tutorien einmal das [Tutorium agricolae als PDF](https://cran.r-project.org/web/packages/agricolae/vignettes/tutorial.pdf) und einmal mit Beispielen von der Webseite [Experimental Designs with agricolae](https://myaseen208.com/agricolae/articles/ExperimentalDesign.html). Beide Tutorien sind identisch, dass eine ist ein PDF und das andere eine Webseite.

So dann schauen wir uns mal die gängigen Parameter bei der Erstellung des Designs mit den Funktionen von `agricolae` an:

-   `series`: legt fest wie viele Zeichen plus 1 die Nummerierung der Zeile haben soll. Wenn wir `series = 2` setzen, dann zählen wir mit 101, 102, 203 usw. die Zeilen hoch. Im Falle eines vollständig randomisierten Designs ist die Nummerierung fortlaufend.
-   `seed`: der Seed für die Zufallsgenerierung und sein Wert ist eine beliebige Zahl.
-   `kinds`: die Methode der Zufallsgenerierung, standardmäßig "Super-Duper" und interessiert uns hier nicht besonders.
-   `randomization`: Soll das Design randomisiert werden?

Und Folgendes kommt dann bei `agricolae` als Ausgabe raus. Zwar nicht immer, aber das ist der grobe Überblick.

-   `parameters`: die Eingabe zur Generierung des Designs. Wir erhalten also nochmal unsere Werte wieder, die wir eingegeben haben. Meistens nicht von Interesse.
-   `book`: Das Feldbuch indem das wichtige drin steht, nämlich unsere generiertes Faktordesign.
-   `statistics`: die Informationsstatistiken das Design, die wir noch zusätzlich kriegen. Diese nutzen wir nur für komplexere Designs.
-   `sketch`: Verteilung der Behandlungen im Feld. Wird uns nicht immer wiedergeben und ist als Hilfe für die direkte Anwendung gedacht.

Wenn wir Parzellen anlegen, dann erhalten wir auch noch folgende Informationen wieder. Dfür muss dann aber auch das experimentelle Design entsprechende Parzellen haben.

-   `zigzag`: ist eine Funktion, die es erlaubt die Verteilung der Beobachtungen entlang der Parzellen zu kontrollieren. Meistens ist es etwas zu viel des Guten, aber gut das du hier noch Änderungen vornehmen kannst.
-   `fieldbook`: Ausgabe des Zickzacks aus der obigen Funktion und das entsprechende Feldbuch mit dem Design.

Es gibt eine weitreichende Anzahl an `design.*`-Funktionen für sehr viele Designs. Wir schauen uns also jetzt einmal als Beispiel die Funktion `design.crd()` an um ein *complete randomized design* zu erstellen. Der Vorteil der Funktion ist hier, dass wir verschiedene Anzahlen von Individuen in die Generierung des Designs nehmen können. Also zum Beispiel drei Pflanzen in der Kontrolle und dann jeweils fünf Pflanzen in der Behandlung. Weil es aber dann meistens nicht auf die zwei Kontrollpflanzen weniger ankommt, machen wir immer ein balanciertes Design. Wenn es aber unbalanciert sein soll, dann ist es natürlich hier einfacher umzusetzen als mit `expand_grid()`.

In den Designfunktionen haben wir meistens einmal die Option für die Behandlung `trt` sowie für die Wiederholungen `r`. Leider ist es so, dass je nach Design die Option `r` mal die Wiederholungen oder aber die Blöcke beschreibt. Schau dir da bitte die Beispiele an. Im Weiteren haben wir dann noch die `serie` Option, die einfach die Nummerierung auf Hunderter setzt.

```{r}
crd_obj <- design.crd(trt = c("ctrl", "A", "B", "C"), 
                      r = c(3, 5, 5, 5), serie = 2)
```

Nun ist es so, dass die Funktion den Spaltennamen der Behandlung auf `c("ctrl", "A", "B", "C")` setzt anstatt auf einen Namen. Dafür müssten wir dann einen Vektor `trt` übergeben, aber das wird mir dann irgendwann zu wirr. Deshalb nenne ich dann alle Spalten nochmal mit der Funktion `set_names()` entsprechend um und erschaffe mir einen `tibble`.

```{r}
crd_book <- crd_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "r", "trt"))
crd_book
```

Wir haben kein `sketch` aus der Funktion. Daher müssen wir uns selber überlegen, wie wir dann die Pflanzen anordnen würden. Darüber hinaus ist die Ordnung wild, ich sehe da eher weniger Struktur in der Ausgabe, als das mir es hilft. Aber dazu dann mehr in den folgenden Kapiteln. Hier ist es erstmal die stumpfe Durchführung am Beispiel des *complete randomized design*.

Das Paket `agricolae` hat keine interne Möglichkeit sich die Designs zu visualisieren.

::: {.callout-important collapse="true"}
## Fehlende Einbindung von `agricolae` in andere R Pakete

In der @fig-exp-r-02 sehen wir die Problematik mit der fehlenden Einbindung von `agricolae` in das Paket `desplot`. Die Abbildung ist einfach suboptimal. Da wir in dem Feldbuch von `agricolae` keine Zeilen und Spalten der Position wiederbekommen, können wir das Design nicht sauber darstellen. Leider liefert uns die Funktion `design.crd()` auch keine Verteilung der Behandlungen im Feld, so dass wir hier alles selber bauen müssten. Dann geht es mit `expand_grid()` schneller.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-r-01
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Beispiel für die fehlende Einbindung von `agricolae` durch `desplot`. Da `agricolae` für durch die Funktion `design.crd()` keine Positionen in Zeile und Spalte liefert kann nur ein suboptimaler Plot erstellt werden."

ggdesplot(data = crd_book, flip = TRUE,
          form = trt ~ r + plots,              
          text = trt, cex = 1, shorten = "no", 
          main = "Field layout", show.key = F)    
```
:::

## Das R Paket `desplot`

[Plotting field maps with the desplot package](https://cran.r-project.org/web/packages/desplot/vignettes/desplot_examples.html)

Jetzt müssen wir noch unser Grid ergänzen auf dem wir unsere Pflanzen stellen wollen. In unserem Fall wollen wir unsere Pflanzen auf vier Zeilen `row` und fünf Spalten `col` stellen. Das bietet sich bei zwanzig Pflanzen dann ja auch an.

```{r}
crd_grid <- expand_grid(row = 1:4, col = 1:5)
crd_grid  
```

Jetzt sortieren wir unsere Daten nach den Individuen und durchmischen damit auch gleichzeitig die Zuordnung von den Behandlungen. Dann ergänzen wir unser Grid für die Pflanzenpositionen durch die Funktion `bind_cols()`.

```{r}
crd_long_tbl <- crd_long_tbl %>% 
  mutate(id = sample(1:n()))
```

```{r}
crd_plot_tbl <- crd_long_tbl %>% 
  arrange(id) %>% 
  bind_cols(crd_grid)
crd_plot_tbl  
```

In der @fig-exp-r-01 sehen wir einmal unser Design dargestellt. Wir sehen, dass wir die vier Behandlungen mit den fünf Wiederholungen zufällig über den ganzen Tisch verteilt haben.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-r-02
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "foo"

ggdesplot(data = crd_plot_tbl, 
          form = trt ~ col + row,
          text = trt, cex = 1, show.key = FALSE, 
          shorten = "no", 
          main = "Complete randomized design (CRD)")
```

## Das R Paket `dae`

Ein weiteres R Paket, was es ermöglicht *komplexere* Experimente zu planen ist das R Paket `dae`. Über die Hilfeseite [dae: Functions Useful in the Design and ANOVA of Experiments](https://cran.r-project.org/web/packages/dae/vignettes/DesignNotes.pdf) kannst du dir das Tutorium anschauen, was ich dir auch empfehlen würde. Wir machen wie immer hier nur einen kleinen Teil, den Rest musst du dann selber nach schauen. Wenn es aber um komplexere experimentelle Designs geht, dann ist das Paket `dae` auf jeden Fall geeignet.

Das R Paket `dae` hat für die Faktorerstellung in Gruppen eine eigne Funktion `fac.gen()`. Mit der Funktion können wir besonders gut Faktoren generieren. Bei einfachen Beispielen wie dem *randomized complete block design* (RCBD) bräuchten wir die Funktion eigentlich nicht, aber hier einmal zur Demonstration. Bei komplexeren Beispielen ist die Funktion nicht wegzudenken.

```{r}
rcbd_sys <- cbind(fac.gen(generate = list(rows = 5, columns = 4)),
                  fac.gen(generate = list(treatments = LETTERS[1:4]), times = 5))
```

Wir können auch mit der Funktion `expand_grid()` von weiter oben relativ einfach das Pflanzengrid nachbauen. Da brauchen wir eigentlich nicht die Funktion `fac.gen()`. Wie immer, bei einfachen Beispielen reicht auch viel was in R finden, bei komplexeren Designs würde ich immer zu `fac.gen()` wechseln.

```{r}
rcbd_sys <- expand_grid(rows = 1:5,
                        columns = 1:4) %>% 
  mutate(treatments = factor(columns, labels = LETTERS[1:4]),
         rows = as_factor(rows),
         columns = as_factor(columns))
```

```{r}
rcbd_lay <- designRandomize(allocated = rcbd_sys["treatments"],
                            recipient = rcbd_sys[c("rows", "columns")],
                            nested.recipients = list(columns = "rows"),
                            seed = 1134)
rcbd_lay 
```

-   `allocated`: Ist meistens der Faktor unserer Behandlung und damit der zugeordnete Faktor. Das heißt, wir wollen diesen Faktor auf das Grid aus Zeilen und Spalten verteilen bzw. zuordnen. In unserem Fall die vier Behandlungen.
-   `recipient`: Ist der Faktor, dem die Behandlungsgruppen zugeordnet werden. Damit auch das Grid, was den Behandlungsfaktor empfängt. Wir haben hier also Zeilen `rows` und Spalten `columns` in denen unsere Behandlung zufällig verteilt werden soll.
-   `nested.recipients`: Hier wird angegeben, in welcher Abhängigkeitsstruktur das Grid vorliegt. Unsere Blöcke sind in diesem Fall über die Zeilen orientiert.

```{r}
designGGPlot(rcbd_lay, labels = "treatments", 
             row.factors = "rows", column.factors = "columns",
             cellalpha = 0.75,
             blockdefinition = cbind(1, 4))
```

## Das R Paket `agridat`

Eine wunderbare Sammlung von Datensätzen aus dem Bereich der Agarwissenschaften liefert das R Paket `agridat`. Über die Hilfeseite [agridat: Agricultural Datasets](https://cran.r-project.org/web/packages/agridat/index.html) findest du dann einmal einen gesamten Überblick und auch die Informationen über einige ausgewählte Datensätze aus Dutzenden von Datensätzen. Alle Datensätze der wichtigen Bücher zu dem experimentellen Designs sind dort eigentlich enthalten und einmal kuratiert.
