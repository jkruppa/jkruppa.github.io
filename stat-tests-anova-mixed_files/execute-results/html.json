{
  "hash": "8178f0e1ce40305b5bcbccebf146548d",
  "result": {
    "engine": "knitr",
    "markdown": "::: {.cell}\n\n:::\n\n\n\n\n\n# Die repeated / mixed ANOVA {#sec-anova-mixed}\n\n*Letzte Änderung am 30. April 2025 um 07:12:57*\n\n> *\"I never once failed at making a light bulb. I just found out 99 ways not to make one.\" --- Thomas A. Edison*\n\n![](images/caution.png){fig-align=\"center\" width=\"100%\"}\n\n::: {.callout-caution appearance=\"simple\"}\n## Stand des Kapitels: Konstruktion (seit 02.2025)\n\nDieses Kapitel wird in den nächsten Wochen geschrieben. Ich plane zum Ende des SoSe 2025 eine neue Version des Kapitels erstellt zu haben. Während das Kapitel entsteht, funktioniert so manaches dann nicht so wie es soll.\n:::\n\nIn diesem Kapitel soll es dann um Messwiederholungen gehen. Wir haben also irgendwas wiederholt gemessen. Damit haben wir auch eine Zeitvariable mit in den Daten. Hier müssen wir dann etwas aufpassen, ob wir wirklich eine repeated oder mixed ANOVA rechnen wollen oder nicht doch irgendwie eine Zeitreihe vorliegen haben. Die Frage, die du dir stellen musst ist hierbei eigentlich recht einfach. Wenn du ein Interesse an einem wie auch immer gearteten Gruppenvergleich hast und du diese Gruppen über die Zeit gemessen hast, dann bist du hier in diesem Kapitel richtig. Wenn es um eine ANOVA geht, dann geht es auch immer um einen Gruppenvergleich. Ansonsten könntest du eine Prognose wollen und das wäre dann eher eine klassische Zeitreihe.\n\n::: {layout=\"[15,85]\" layout-valign=\"top\"}\n![](images/angel_01_small.png){fig-align=\"center\" width=\"100%\"}\n\n> Hier eine kurze Warnung. Häufig wird die repeated und die mixed ANOVA in einen Topf geworfen. Die beiden Verfahren unterscheiden sich aber konzeptionell. Darüber hinaus hast du meistens in den Agrarwissenschaften eine mixed ANOVA vorliegen, wenn du mit Messwiederholungen gearbeitet hast und keine repeated ANOVA.\n:::\n\n## Allgemeiner Hintergrund\n\nDie gemischte ANOVA (eng. *mixed ANOVA*) und die ANOVA für Messwiederholungen (eng. *repeated ANOVA*) sind eng miteinander verwandt. Vermutlich ist dies auch der Grund, warum es bei beiden Verfahren so viele Verwirrungen gibt. Ebenso finden sich auch verschiedene Namen zu den beiden ANOVA Algorithmen, aber wir bleiben einmal hier bei den beiden Namen. Die beiden Verfahren basieren auf Messwiederholungen. Daher messen wir wiederholt an einer Beobachtung einen Messwert. Der Unterschied liegt in dem Versuchsdesign und welche Beobachtung welche Behandlung erhält. Wir haben haben meistens in den Agrarwissenschaften eine *mixed ANOVA* vorliegen.\n\nWas haben die *mixed ANOVA* und die *repeated ANOVA* gemeinsam?\n\n:   In beiden Fällen haben wir Messwiederholungen in unseren Daten. Das heißt, wir messen wiederholt an dem gleichen Subjekt einen Messwert. Wir messen also weiderholt die Größe einer Pflanze oder die Milchleistung einer Kuh.\n\nOder um den Sachstand nochmal mit einem Zitat zu untermauern, habe ich aus dem Handbuch der SPSS Statistik einmal folgende Einordnung gefunden. Hier ist nochmal wichtig, was eigentlich mit den einzelnen Beobachtungen (eng. *subject*) passiert.\n\n> *\"However, the fundamental difference is that in a mixed ANOVA, the subjects that undergo each condition (e.g., a control and treatment) are different, whereas in a two-way repeated measures ANOVA, the subjects undergo both conditions (e.g., they undergo the control and the treatment).\"* --- [Two-way repeated measures ANOVA using SPSS Statistics](https://statistics.laerd.com/spss-tutorials/two-way-repeated-measures-anova-using-spss-statistics.php#:~:text=A%20mixed%20ANOVA%20is%20very,factors%20on%20the%20dependent%20variable.)\n\nDas klingt jetzt etwas kompliziert und deshalb habe ich dir den Zusammenhang einmal in der folgenden @fig-ggplot-theo-intro visualisiert. Nehmen wir einmal an, du hast einen Behandlungsfaktor $f_A$ mit drei Leveln. Jedes Level steht für eine Art der Behandlung. Wenn wir uns jetzt eine mixed ANOVA anschauen, dann haben wir drei Individuen vorliegen, die wiederholt in der gleichen Art der Behandlung gemessen werden. Das Individium mit der $ID_1$ erhält nur die Behandlung $A.3$ wiederholt verabreicht oder steht unter dieser Behandlung. Dann messen wir wiederholt den Messwert.\n\nEtwas anders sieht es dann bei der repeated ANOVA aus. Hier haben wir ein Individum was alle Behandlungen über alle Zeitpunkte erhält. Damit erhät das Individium $ID_1$ erst die Behandlung $A.3$ viermal und danach dann die beiden anderen Behandlungen auch jeweils viermal wiederholt gemessen. Das ist ein großer konzeptioneller Unterschied in dem Versuchsdesign zwischen der mixed und der repeated ANOVA. In beiden ANOVA Typen wird wiederholt gemessen. In der repeated ANOVA erhält jedes Individum aber auch alle Behandlungen über die Zeit.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Konzeptionelle Darstellung der mixed und repeated ANOVA in einem Flussdiagramm mit unterschiedlichen Individuen für einen Behandlungsfaktor mit drei Leveln als Arten der Behandlung. **(A)** In der mixed ANOVA werden pro Art der Behandlung ein Individum wiederholt gemessen. **(B)** In der repeated ANOVA wird ein Individum wiederholt für jede Art der Behandlung gemessen. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-intro-1.png){#fig-ggplot-theo-intro fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nBevor wir jetzt weiter in das Modell und die einzelnen Besonderheiten der mixed ANOVA und repeated ANOVA einsteigen nochmal der Hinweis, dass wir hier natürlich auch wieder *nur* global einen Fakor testen. Das heißt, du weißt natürlich wieder nicht, welcher paarweise Vergleich innerhalb eines Faktors einen signifikanten Unterschied ausmacht, wenn du eine signifikante ANOVA vorliegen hast. Dann musst du wieder weiter machen mit einem Post-hoc Test. Auch hier hilft nochmal die Vingette von `{afex}` mit [ANOVA and Post-Hoc Contrasts](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html). Oder wie es @gueorguieva2004move mit der wissenschaftlichen Veröffentlichung [Move Over ANOVA](https://jamanetwork.com/journals/psych/articlepdf/481967/ynv20002.pdf?casa_token=5gc0qQuqNFUAAAAA:SJWnX8rH6__-lxXqiF0FDGQISXgXE0JQlRgtY7EE76IFnuECNjsOvKzUIwu9hmZFrKdLJbIahfQ) und der Nutzung von linearen gemischten Modellen wie folgt beschreibt.\n\n> *\"Mixed-effects models use all available data, can properly account for correlation between repeated measurements on the same subject, have greater flexibility to model time effects, and can handle missing data more appropriately. Their flexibility makes them the preferred choice for the analysis of repeated measures data\"* --- @gueorguieva2004move\n\nWarum machen wir das nicht immer? Also wir nutzen immer ein lineares gemischtes Modell? Das hat meistens mit der geringen Anzahl an Beobachtungen in den Gruppen und allgemein mit zu wenigen Gruppen zu tun. Häufig reicht eben das Design und die Wiederholungen nicht aus für ein sauberes gemischtes Modell. Deshab ist dann eine Lösung sich die Sachlage einmal in einer mixed oder repeated ANOVA anzuschauen. Es gilt wie immer, komplexe Fragestellungen kann man meistens nicht in einem einfachen Satz beantworten. Hier kommt es dann auch wieder auf die konkrete Fragestellung an.\n\n#### Welche Pakete gibt es eigentlich? {.unnumbered .unlisted}\n\nWenn um die Anwendung der mixed oder repeated ANOVA in R geht, dann haben wir eine Menge Pakete zur Auswahl. Wie immer macht die Fragestellung und das gewählte Modell den Großteil der Entscheidungsindung aus. Ich zeige dir später in der Anwendung dann auch alle Pakete einmal, gebe dir dann aber auch immer eine Empfehlung mit. Normalerweise brauchen wir einen normalverteilten Messwert $y$ und Varianzhomogenität in den Faktoren. In den letzten Jahren wurden aber noch weitere Implementierungen der ANOVA entwickelt, so dass hier auch Alternativen vorliegen.\n\nGehen wir jetzt mal die Pakete durch. Wir immer gibt es einiges an Möglichkeiten und ich zeige dir hier eben die Auswahl. Es gibt hier das ein oder andere noch zu beachten, aber da gehe ich dann bei den jeweiligen Methoden drauf ein. Es macht eben dann doch einen Unterschied ob ich eine einfaktorielle oder komplexere ANOVA rechnen will. Nicht alles geht in allen R Pakten oder gar Excel.\n\nDer Standard mit der Funktion `aov()` aus `{base}`\n\n:   Die Standardfunktion `aov()` erlaubt es eine mixed oder repeated ANOVA direkt auf einem Datensatz zu rechnen. Hier brauchen wir nur ein Modell in der in R üblichen Formelschreibweise `y ~ f`. Du kannst diesen Ansatz als schnelle ANOVA begreifen. Dein Messwert $y$ muss hier normalverteilt sein.\n\nMit der Funktion `anova_test()` aus `{rstatix}`\n\n:   Das [R Paket `{rstatix}`](https://cran.r-project.org/web/packages/rstatix/index.html) bietet bietet die Funktion `anova_test()` die es erlaubt einfacher auf die Funktionalität der Funktion `aov()` und R Funktionen aus dem Paket `{car}` zuzugreifen. Es ist eben ein klassischer Wrapper um besser rechnen zu können. Aber auch hier musst du verstehen wie die Funktion funktioniert. Ich finde aber die Anwendung relativ einfach und deshalb zeige ich die Funktion hier einmal.\n\nMit den ANOVA Funktionen aus `{afex}`\n\n:   Wir können die mixed oder repeated ANOVA anwenden, wenn wir Messwiederholungen vorliegen haben. Daher bietet sich hier insbesondere das [R Paket `{afex}`](https://github.com/singmann/afex) an. Du musst bei den Funktionen von `{afex}` immer eine ID mitlaufen lassen, die angibt welche Individuen wiederholt gemessen wurden. Also hat jede Zeile eine Nummer, die beschreibt welche Beobachtung hier vorliegt. Besonders wichtig bei Messungen über die Zeit. Darüber hinaus kann das Paket sehr gut Interaktionen schätzen und Bedarf dort keiner zusätzlichen Optionen. Auch hier hilft nochmal die Vingette von `{afex}` mit [ANOVA and Post-Hoc Contrasts](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html) weiter, wenn es um den Post-hoc Test geht.\n\nMit den ANOVA Funktionen aus `{MANOVA.RM}`\n\n:   [Das R Paket `{MANOVA.RM}`](https://cran.r-project.org/web/packages/MANOVA.RM/vignettes/Introduction_to_MANOVA.RM.html) von @friedrich2019resampling bietet eine weitere Möglichkeit die reapted und mixed ANOVA zu rechnen, wenn die Annahme an die Normalverteilung sowie der Varianzhomogenität nicht erfüllt ist. Wir haben es hier dann nochmal mit einer neueren Implementierung zu tun. Eine weitere robuste Alternative zu den Standardimplementierungen.\n\nMit den ANOVA Funktionen aus `{WRS2}`\n\n:   Eine Annahme an die mixed oder repeated ANOVA ist, dass wir es mit normalverteilten Messwerten $y$ sowie Varianzhomogenität in den Faktoren $f$ vorliegen haben. Das R Paket `{WRS2}` mit der hervorragenden Vingette [Robust Statistical Methods Using WRS2](https://cran.r-project.org/web/packages/WRS2/vignettes/WRS2.pdf) erlaubt nun aber diese beiden Annahmen zu umgehen und bietet eine robuste ANOVA an. Robust meint hier, dass wir uns nicht um die Normalverteilung und Varianzhomogenität kümmern müssen.\n\nWir immer ist es hier ein Tutorium um gleich mit der ANOVA starten zu können. Wenn du tiefer in die Materie einsteigen möchtest und noch andere Dinge rechts und links anschauen willst, dann findest du in den folgenden Quellen nochmal mehr Anregungen. Es geht wie immer mehr, aber wir wollen hier dann ja auch fertig werden und haben beschlossen eine repeated oder mixed ANOVA zu rechnen.\n\n::: callout-tip\n## Weitere Tutorien für die repeated & mixed ANOVA\n\nWir oben schon erwähnt, kann dieses Kapitel nicht alle Themen der repeated und mixed ANOVA abarbeiten. Insbesondere der theoretische Hintergrund ist ja bei mir hier sehr gekürzt. Daher präsentiere ich hier eine Liste von Literatur und Links, die mich für dieses Kapitel hier inspiriert haben. Nicht alles habe ich genutzt, aber vielleicht ist für dich was dabei.\n\n-   Im Tutorium zur [Repeated Measures ANOVA in R](https://www.datanovia.com/en/lessons/repeated-measures-anova-in-r/) und [Mixed ANOVA in R](https://www.datanovia.com/en/lessons/mixed-anova-in-r/) auf der Seite Datanovia wird nochmal mehr auf die möglichen Vortest der Annahmen eingegangen. Auch wird nochmal der Posthoc-Test gezeigt, den ich ja ausgelagert habe.\n-   Das Kapitel zu den [Random Effects](https://bookdown.org/steve_midway/DAR/random-effects.html) aus dem Openbook Data Analysis in R gibt nochmal einen Einblick in die Idee der zufälligen Effekte, die wir hier bewusst etwas unter den Tisch fallen lassen.\n-   Das Openbook ANOVA and Mixed Models A Short Introduction Using R gibt in dem Kapitel zu [Random and Mixed Effects Models](https://people.math.ethz.ch/~meier/teaching/anova/random-and-mixed-effects-models.html) nochmal eine Übersicht über die verschiedenen Modelle. Insbesondere der Theorieteil ist gut, da ich ja hier in diesem Kapitel aktuell auf eine theoretische Betrachtung verzichtet habe.\n-   Wenn dich die Formelschreibweise in R verwirrt, dann hilft dir nochmal der Blogeintrag zu [ANOVA and other models, mixed and fixed](https://conjugateprior.org/2013/01/formulae-in-r-anova/).\n:::\n\n## Genutzte R Pakete\n\nWir wollen folgende R Pakete in diesem Kapitel nutzen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, magrittr, broom, WRS2, scales,\n               readxl, see, car, patchwork, rstatix, emmeans,\n               interactions, effectsize, afex, report, multcomp,\n               janitor, MANOVA.RM, ggrepel, conflicted)\nconflicts_prefer(dplyr::mutate)\nconflicts_prefer(dplyr::summarize)\nconflicts_prefer(dplyr::filter)\nconflicts_prefer(dplyr::arrange)\nconflicts_prefer(dplyr::select)\nconflicts_prefer(magrittr::set_names)\nconflicts_prefer(magrittr::extract)\nconflicts_prefer(effectsize::eta_squared)\ncbbPalette <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \n                \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")\n```\n:::\n\n\n\n\n\nAn der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.\n\n## Daten\n\nBeginnen wir wie immer mit den Daten. Hier ist die Besonderheit, dass wir immer Messweiderholungen an einer Beobachtung vorliegen haben. Ich habe dann die jeweilige Beobachtung in der Spalte `.id` jeweils genau benannt. Daher kommt eben die Beobachtung mit der `id` gleich 1 mehrfach in den Daten vor. Genauer, wir haben eben nicht nur eine Zeile in den Daten für eine Beobachtung sondern mehrere Zeilen für eine Beobachtung vorliegen. Das ist am Anfang immer etwas verwirrend, aber man gewöhnt sich daran.\n\nEine weitere Besonderheit ist, dass wir häufig die Daten in einem Wide-Format erstellen. Das geißt wir haben pro Zeile eine ID und dann mehrere Spalten wo wir wiederholt messen. Wir nennen dann diese Spalten meistens `t0` bis `t5`, wenn wir sechs Zeitpunkte bemessen. In R brauchen wir dann doch wieder das Long-Format und dementsprechend nutzen wir die Funktion `pivot_longer()` um uns aus den Daten im Wide-Format die entsprechenden Daten im Long-Format zu bauen. Das Openbook [R for Data Science](https://r4ds.hadley.nz/data-tidy.html#sec-pivoting) hat hier noch das passende Kapitel zum nachlesen. Du kannst auch das [Cheatsheet](https://tidyr.tidyverse.org/#cheatsheet) nochmal anschauen, dort wird alles nochmal visuell erklärt.\n\n### Mixed ANOVA\n\nBei der mixed ANOVA haben wir mindestens ein zweifaktorielles Design vorliegen. Warum ist das so? Zum einen brauchen wir einen Behandlungsfaktor und dazu kommt dann noch der Faktor der Messwiederholung. Wir messen ja wiederholt und dieses wiederholte Messen kommt dann ebenfalls in einen Faktor rein. Somit haben wir einen Behandlungsfaktor und einen Zeitfaktor in den Daten. Manchmal erhöhen wir noch die Komplexität und ergänzen einen zweiten Behandlungsfaktor und haben dann einen dreifaktoriellen Datensatz vorliegen.\n\n#### Zweifaktoriell {.unnumbered .unlisted}\n\nIm Folgenden siehst du einmal einen Datensatz für eine zweifaktorielle mixed ANOVA. In diesem Beispiel schauen wir uns nur Katzenflöhe an. Wir haben in dem Datensatz einmal den Faktor `feeding` als die Fütterungsarten mit einer Kontrolle als Zuckerwasser, Blut und einmal Ketchup sowie als zweiten Faktor die verschiedenen Zeitpunkte der Messung der Sprungweite in \\[cm\\]. Wir haben an insgesamt sechs Zeitpunkten wiederholt die Sprungweite gemessen. Wir wollen nun wissen, in wie weit sich die Sprungweite über die Zeit für die drei Floharten ändert.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_fac2_tbl <- read_excel(\"data/fleas_complex_data.xlsx\", \n                             sheet = \"mixed-fac2\") |> \n  select(.id, feeding, t0:t5) |> \n  pivot_longer(cols = t0:t5,\n               values_to = \"jump_length\",\n               names_to = \"time_fct\") |> \n  mutate(feeding = as_factor(feeding),\n         time_fct = as_factor(time_fct),\n         jump_length = round(jump_length, 2),\n         .id = as_factor(.id))\n```\n:::\n\n\n\n\n\nIn der folgenden Tabelle siehst du einmal die rohen Daten eingelesen. Wir haben den Faktor `feeding` sowie die sechs Zeitpunkte der Messung der Sprungweite in \\[cm\\]. Wir müssen uns dann in R die Daten über die Funktion `pivot_longer()` in ein Long-Format umwandeln.\n\n\n\n\n\n::: {#tbl-mixed-table-fac2 .cell tbl-cap='Rohdaten der Sprungweiten in [cm] gemessen an sechs Zeitpunkten von drei Fütterungsarten im Wide-Format für die bessere Übersicht.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_dziyyaulolcr2qe0ohqh</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_dziyyaulolcr2qe0ohqh\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">.id</th>\n                <th scope=\"col\">feeding</th>\n                <th scope=\"col\">t0</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n                <th scope=\"col\">t5</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1  </td>\n                  <td>ctrl   </td>\n                  <td>31.56</td>\n                  <td>27.61</td>\n                  <td>26.12</td>\n                  <td>17.66</td>\n                  <td>18.33</td>\n                  <td>7.43 </td>\n                </tr>\n                <tr>\n                  <td>2  </td>\n                  <td>ctrl   </td>\n                  <td>32.87</td>\n                  <td>26.12</td>\n                  <td>28.23</td>\n                  <td>19.25</td>\n                  <td>12.01</td>\n                  <td>8.75 </td>\n                </tr>\n                <tr>\n                  <td>3  </td>\n                  <td>ctrl   </td>\n                  <td>33.43</td>\n                  <td>31.23</td>\n                  <td>26.59</td>\n                  <td>24.19</td>\n                  <td>13.95</td>\n                  <td>0.27 </td>\n                </tr>\n                <tr>\n                  <td>4  </td>\n                  <td>ctrl   </td>\n                  <td>24.88</td>\n                  <td>30.47</td>\n                  <td>26.82</td>\n                  <td>23.77</td>\n                  <td>20.71</td>\n                  <td>1.34 </td>\n                </tr>\n                <tr>\n                  <td>...</td>\n                  <td>...    </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>21 </td>\n                  <td>ketchup</td>\n                  <td>48.68</td>\n                  <td>47.28</td>\n                  <td>33.81</td>\n                  <td>21.89</td>\n                  <td>27.6 </td>\n                  <td>33.84</td>\n                </tr>\n                <tr>\n                  <td>22 </td>\n                  <td>ketchup</td>\n                  <td>51.56</td>\n                  <td>49.85</td>\n                  <td>37.17</td>\n                  <td>30.66</td>\n                  <td>27.67</td>\n                  <td>35.03</td>\n                </tr>\n                <tr>\n                  <td>23 </td>\n                  <td>ketchup</td>\n                  <td>53.51</td>\n                  <td>47.6 </td>\n                  <td>33.31</td>\n                  <td>30.46</td>\n                  <td>25.32</td>\n                  <td>28.31</td>\n                </tr>\n                <tr>\n                  <td>24 </td>\n                  <td>ketchup</td>\n                  <td>49.38</td>\n                  <td>42.85</td>\n                  <td>31.99</td>\n                  <td>34.09</td>\n                  <td>27.1 </td>\n                  <td>34.81</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_yu1lz2iyeu447iujitip(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_dziyyaulolcr2qe0ohqh\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_dziyyaulolcr2qe0ohqh');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_yu1lz2iyeu447iujitip(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_dziyyaulolcr2qe0ohqh\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nJetzt habe ich dir in der folgenden Abbildung auch nochmal das Versuchsdesign aufgezeigt. Wie du siehst, haben wir immer einen Floh, der eine Behandlung mit einer Fütterungsart erhält. Dieser Flog springt dann zum Beispiel unter der Fütterung mit Ketchup sechs Mal und wir notieren jedesmal die Sprungweite zu den Messzeitpunkten.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Versuchsdesign der zweifaktoriellen mixed ANOVA. Der erste Faktor ist die Fütterungsart `feeding`. Jeder Floh erhält eine Fütterung und anschließend wird sechs mal die Sprungweite gemessen. Hier sind nur vier Zeitpunkte dargestellt. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-mixed-fac2-1.png){#fig-ggplot-theo-mixed-fac2 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nIn der folgenden Abbildung siehst du dann nochmal den Zusammenhang zwischen der Sprungweite in \\[cm\\] der Katzenflöhe unter unterschiedlichen Fütterungsarten. Dabei wurden die Flöhe wiederholt an sechs Zeitpunkten gemessen. Wir du siehst, fällt mit der Zeit die Sprungleistung ab. Die Katzenflöhe springen unabhängig von der Fütterungsart weniger weit mit der Zeit. Am letzten Zeitpunkt scheinen die Flöhe unter Ketchupernährung dann wieder etwas weiter zu springen. Jetzt müssen wir aber einmal statistisch Nachweisen, ob wir hier wirklich einen signifikanten Zusammenhang und Unterschiede zwischen den Fütterungsarten vorliegen haben.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung des Zusammenhangs zwischen der Fütterung von Katzenflöhen und der gemessenen Sprungweite in [cm] über sechs Messzeitpunkte. Die Linie stellt den jeweiligen Mittelwert zu dem Zeitpunkt und der Fütterungsart dar. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-anova-mixed-fac2-1.png){#fig-ggplot-anova-mixed-fac2 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n#### Dreifaktoriell {.unnumbered .unlisted}\n\nFür unser dreifaktorielles Beispiel erweiter wir einmal den Datensatz um ein Workout für die Katzenflöhe. Neben den drei Fütterungsarten Kontrolle mit Zuckerwasser, Blut sowie Ketchup mussten die Flöhe als zweiten Faktor noch ein Workout bestehen. Dabei haben nicht alle Katzenflöhe jeweils trainiert, sondern wir haben eine untrainierte Gruppe sowie eine trainierte Gruppe. Beide Gruppen des Workout wurden dann mit allen drei Fütterungsarten gefüttert. Dann wurden insgesamt zu sechs Zeitpunkten die Sprungweite in \\[cm\\] bestimmt. Wir haben es daher mit einem dreifaktoriellen Datensatz zu tun, da wir zwei Behandlungsfaktoren sowie den Faktor der Messwiederholungen in unseren Daten vorliegen haben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_fac3_tbl <- read_excel(\"data/fleas_complex_data.xlsx\", \n                             sheet = \"mixed-fac3\") |> \n  select(.id, feeding, workout, t0:t5) |> \n  pivot_longer(cols = t0:t5,\n               values_to = \"jump_length\",\n               names_to = \"time_fct\") |> \n  mutate(feeding = as_factor(feeding),\n         workout = as_factor(workout),\n         time_fct = as_factor(time_fct),\n         jump_length = round(jump_length, 2),\n         .id = as_factor(.id))\n```\n:::\n\n\n\n\n\nIn der folgenden Tabelle sind die Daten dann nochmal im Wide-Format dargestellt. Wir haben hier dann pro Floh jeweils eine Faktorkombination aus der Fütterungsart `feeding` sowie dem Traingsstatus `workout`. Im Anschluss haben wir dann die Sprungweite von jedem Floh sechsmal gemessen. Wir müssen dann in R die Daten nochmal in das Long-Format über die Funktion `pivot_longer()` umbauen.\n\n\n\n\n\n::: {#tbl-mixed-table-fac3 .cell tbl-cap='Rohdaten der Sprungweiten in [cm] gemessen an sechs Zeitpunkten von drei Fütterungsarten sowie dem Status des Workouts im Wide-Format für die bessere Übersicht.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_got1x4cbpl5v9leiwp2g</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_got1x4cbpl5v9leiwp2g\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">.id</th>\n                <th scope=\"col\">feeding</th>\n                <th scope=\"col\">workout</th>\n                <th scope=\"col\">t0</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n                <th scope=\"col\">t5</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1  </td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>44.5 </td>\n                  <td>32.4 </td>\n                  <td>33.02</td>\n                  <td>18.14</td>\n                  <td>20.88</td>\n                  <td>10.78</td>\n                </tr>\n                <tr>\n                  <td>2  </td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>36.33</td>\n                  <td>37.05</td>\n                  <td>31.79</td>\n                  <td>25.72</td>\n                  <td>28.01</td>\n                  <td>8.79 </td>\n                </tr>\n                <tr>\n                  <td>3  </td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>31.76</td>\n                  <td>31.75</td>\n                  <td>29.82</td>\n                  <td>26.39</td>\n                  <td>27.4 </td>\n                  <td>15.52</td>\n                </tr>\n                <tr>\n                  <td>4  </td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>38.28</td>\n                  <td>37.08</td>\n                  <td>30.53</td>\n                  <td>27.8 </td>\n                  <td>28.37</td>\n                  <td>5.21 </td>\n                </tr>\n                <tr>\n                  <td>...</td>\n                  <td>...    </td>\n                  <td>...</td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>21 </td>\n                  <td>ketchup</td>\n                  <td>no </td>\n                  <td>59.12</td>\n                  <td>51.66</td>\n                  <td>35.64</td>\n                  <td>39.56</td>\n                  <td>27.77</td>\n                  <td>32.88</td>\n                </tr>\n                <tr>\n                  <td>22 </td>\n                  <td>ketchup</td>\n                  <td>no </td>\n                  <td>53.51</td>\n                  <td>58.28</td>\n                  <td>36.65</td>\n                  <td>34.62</td>\n                  <td>28.09</td>\n                  <td>38.01</td>\n                </tr>\n                <tr>\n                  <td>23 </td>\n                  <td>ketchup</td>\n                  <td>no </td>\n                  <td>62.22</td>\n                  <td>48.53</td>\n                  <td>46.73</td>\n                  <td>34.81</td>\n                  <td>34.2 </td>\n                  <td>29.03</td>\n                </tr>\n                <tr>\n                  <td>24 </td>\n                  <td>ketchup</td>\n                  <td>no </td>\n                  <td>53.4 </td>\n                  <td>52   </td>\n                  <td>37.78</td>\n                  <td>47.77</td>\n                  <td>35.5 </td>\n                  <td>27.63</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_6galgqqv1szb4krvtgii(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_got1x4cbpl5v9leiwp2g\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_got1x4cbpl5v9leiwp2g');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_6galgqqv1szb4krvtgii(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_got1x4cbpl5v9leiwp2g\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nManchmal ist es schwer die Zusammenhänge dann in dem Datensatz zu sehen, deshalb hier nochmal das Versuchsdesign visualisert. Jeder Katznfloh springt wiederholt, aber das ganz dann nur unter einer Faktorkombination.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Versuchsdesign der dreifaktoriellen mixed ANOVA. Der erste Faktor ist die Fütterungsart `feeding`. Der zweite Faktor der Status des Workouts für jeden Floh `workout`. Jeder Floh erhält eine Fütterung sowie ein Workout und anschließend wird sechs mal die Sprungweite gemessen. Hier sind nur vier Zeitpunkte dargestellt. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-mixed-fac3-1.png){#fig-ggplot-theo-mixed-fac3 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nAbschließend können wir uns dann nochmal die Daten in der folgenden Abbildung anschauen. Auf den ersten Blick sehen wir, dass die Leistung in der Sprungweite über die Zeit abfällt. Diesen Trend können wir über alle Fütterungsarten beobachten. Was erst auf den zweiten Blick auffällt ist, dass teilweise ja nach Fütterungsart ein Training positiv oder negativ ausfällt. So führt ein Training bei den Kontrollflöhen zu weiteren Sprüngen. Die Katzenflöhe unter einer Blutdiät springen jedoch unter Training nicht so weit wie ohne ein Training.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung des Zusammenhangs zwischen der Fütterung von Katzenflöhen sowie der Trainingszustand und der gemessenen Sprungweite in [cm] über sechs Messzeitpunkte. Die Linie stellt den jeweiligen Mittelwert zu dem Zeitpunkt und der Fütterungsart sowie des Trainings dar. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-anova-mixed-fac3-1.png){#fig-ggplot-anova-mixed-fac3 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n### Repeated ANOVA\n\nDie repeated ANOVA ist in den Agrarwissenschaften selten. In den Sozialwissenschaften oder aber allgemeiner den Humanwissenschaften kommt die repeated ANOVA häufiger vor. Das hat vor allem damit zu tun, dass wir jedes Individuum mit allen Faktorkombinationen behandeln und wiederholt messen. Das wir ein Subjekt wiederholt messen kommt auch häufiger in den Agrarwissenschaften vor, aber selten erhält jedes Tier oder Pflanze alle Behandlungen verabreicht. Deshalb hier einmal die Daten für die repated ANOVA als Veranschaulichung was du als Daten und Experiment vorliegen haben musst.\n\n#### Einfaktoriell {.unnumbered .unlisted}\n\nIm Gegensatz zu mxied ANOVA können wir in der repeated ANOVA auch nur den einfaktoriellen Fall vorliegen haben. Da klingt jetzt erstmal etwas seltsam, aber wir haben in diesem Fall nur die Zeitpunkte als Faktor vorliegen. Wir messen also nur Katzenflöhe ohne eine Behandlung viermal. Wir schauen also, ob sich die Sprungweite von Katzenflöhen über die Zeitpunkte verändert. Wir vergleichen faktisch also nur die Zeitpunkte untereinander.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeated_fac1_tbl <- read_excel(\"data/fleas_complex_data.xlsx\", \n                                sheet = \"repeated-fac1\") |> \n  select(.id, animal, t1:t4) |> \n  pivot_longer(cols = t1:t4,\n               values_to = \"jump_length\",\n               names_to = \"time_fct\") |> \n  mutate(animal = as_factor(animal),\n         time_fct = as_factor(time_fct),\n         jump_length = round(jump_length, 2),\n         .id = as_factor(.id))\n```\n:::\n\n\n\n\n\nAuch hier einmal die Daten im Wide-Format, damit die Daten etwas übersichtlicher sind. Wir haben nur die Katzenflöhe vorligen und schauen uns zwölf einzelne Katzenflöhe an. Jeder Floh springt dann vier Mal und wir messen dann die Sprungweite in \\[cm\\]. Wir müssen uns dann noch das Long-Format über die Funktion `pivot_longer()` in R bauen.\n\n\n\n\n\n::: {#tbl-repeated-table-fac1 .cell tbl-cap='Rohdaten der Sprungweiten in [cm] gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_qpcdrf6i1r67y1i4apfz</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_qpcdrf6i1r67y1i4apfz\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">.id</th>\n                <th scope=\"col\">animal</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>23.72</td>\n                  <td>37.57</td>\n                  <td>36.67</td>\n                  <td>25.89</td>\n                </tr>\n                <tr>\n                  <td>2  </td>\n                  <td>cat</td>\n                  <td>17.84</td>\n                  <td>29.36</td>\n                  <td>22.63</td>\n                  <td>15.44</td>\n                </tr>\n                <tr>\n                  <td>3  </td>\n                  <td>cat</td>\n                  <td>24.11</td>\n                  <td>30.43</td>\n                  <td>30   </td>\n                  <td>28.14</td>\n                </tr>\n                <tr>\n                  <td>...</td>\n                  <td>...</td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>10 </td>\n                  <td>cat</td>\n                  <td>28.52</td>\n                  <td>32.39</td>\n                  <td>33.35</td>\n                  <td>23.91</td>\n                </tr>\n                <tr>\n                  <td>11 </td>\n                  <td>cat</td>\n                  <td>25.46</td>\n                  <td>29.02</td>\n                  <td>22.68</td>\n                  <td>19.88</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>20.92</td>\n                  <td>34.39</td>\n                  <td>26.81</td>\n                  <td>24.76</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_25att40v093pmc711luq(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_qpcdrf6i1r67y1i4apfz\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_qpcdrf6i1r67y1i4apfz');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_25att40v093pmc711luq(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_qpcdrf6i1r67y1i4apfz\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nSo ergibt sich dann auch ein sehr simples Versuchsdesign. Wir lassen jeden Katzenfloh viermal springen und messen jeweils die Sprungweite für jeden Floh.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Versuchsdesign der einfaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal und wird dabei gemessen. Keine weiteren Faktoren liegen vor. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-repeated-fac1-1.png){#fig-ggplot-theo-repeated-fac1 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nDamit ergibt sich am Ende auch eine sehr übersichtliche Abbildung. Wir sehen einmal die einzelnen Katzenflöhe. Jede Sprungweite über die vier Zeitpunkte habe ich für die individuellen Flöhe mit einer gestrichelten Linie verbunden. Den globalen Trend kannst du in der farbigen Linie nachvollziehen. Am Anfang springen die Flöhe nicht soweit, steigern sich dann zum zweiten Messzeitpunkt um dann wieder stetig abzunehmen. Einzelne Flöhe zeigen dabei eine größere Variabilität als der globale Trend.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten. Die gestrichelte Linie verbindet die einzelnen individuellen Katzenflöhe. Die durchgezogene Linie stellt den Mittelwert zu dem jeweiligen Zeitpunkt dar.  *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-anova-repeated-fac1-1.png){#fig-ggplot-anova-repeated-fac1 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n#### Zweifaktoriell {.unnumbered .unlisted}\n\nEigentlich wird die Besonderheit des repeated Design einer ANOVA erst bei der zweifaktoriellen repeated ANOVA so richtig ersichtlich. Hier haben wir es nämlich zum einen mit einem Behandlungsfaktor zu tun und einer Faktor mit den jeweiligen Messzeitpunkten. Wir haben hier wieder die Katzenflöhe mit unterschiedlichen Fütterungsarten ernährt und dann an vier Zeitpunkten gemessen, wie weit die Flöhe springen. Die Besonderheit ist jetzt, dass *jeder* Katzenfloh alle Behandlungen durchläuft. Das macht einen gewaltigen Unterschied im Design und in der Auswertung.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeated_fac2_tbl <- read_excel(\"data/fleas_complex_data.xlsx\", \n                                sheet = \"repeated-fac2\") |> \n  select(.id, animal, feeding, t1:t4) |> \n  pivot_longer(cols = t1:t4,\n               values_to = \"jump_length\",\n               names_to = \"time_fct\") |> \n  mutate(animal = as_factor(animal),\n         feeding = as_factor(feeding),\n         time_fct = as_factor(time_fct),\n         jump_length = round(jump_length, 2),\n         .id = as_factor(.id))\n```\n:::\n\n\n\n\n\nIn der folgenden Tabelle der Rohdaten der Sprungweiten in \\[cm\\] unserer Katzenflöhe siehst du nochmal die Besonderheit der Messwiederholung. Wir messen die Sprungweite von jedem Floh $.id$ viermal für jede Fütterungsart. Wir müssen natürlich zwischen den Fütterungsarten Zeit lassen, damit wir wieder die Fütterungseffekte raus haben, aber ansonsten wird jeder Floh mit allen Ernährungsformen gefüttert. Hier ist dann auch die $.id$ Spalte so wichtig, da wir ja wissen müssen welche Fütterungsart zu welchem Floh gehört. Abschließend nutzen wir die Funktion `pivot_longer()` um uns die Daten passend in R zusammenzubauen.\n\n\n\n\n\n::: {#tbl-repeated-table-fac2 .cell tbl-cap='Rohdaten der Sprungweiten in [cm] nach unterschiedlichen Fütterungsarten gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht. Hier erhält jeder Floh jede Behandlung als Fütterung einmal.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_p23zeyiyzc4ozr31vagm</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_p23zeyiyzc4ozr31vagm\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">.id</th>\n                <th scope=\"col\">animal</th>\n                <th scope=\"col\">feeding</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>34.85</td>\n                  <td>50.21</td>\n                  <td>50.4 </td>\n                  <td>40.92</td>\n                </tr>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>blood  </td>\n                  <td>50.37</td>\n                  <td>57.87</td>\n                  <td>66.84</td>\n                  <td>45.45</td>\n                </tr>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>ketchup</td>\n                  <td>51.01</td>\n                  <td>44.54</td>\n                  <td>42.65</td>\n                  <td>38.74</td>\n                </tr>\n                <tr>\n                  <td>2  </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>34.24</td>\n                  <td>43.85</td>\n                  <td>37.34</td>\n                  <td>30.92</td>\n                </tr>\n                <tr>\n                  <td>...</td>\n                  <td>...</td>\n                  <td>...    </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>11 </td>\n                  <td>cat</td>\n                  <td>ketchup</td>\n                  <td>42.29</td>\n                  <td>49.83</td>\n                  <td>46.08</td>\n                  <td>39.97</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>42.88</td>\n                  <td>46.23</td>\n                  <td>45.93</td>\n                  <td>29.81</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>blood  </td>\n                  <td>49.9 </td>\n                  <td>56.72</td>\n                  <td>66.54</td>\n                  <td>47.85</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ketchup</td>\n                  <td>46.47</td>\n                  <td>52.61</td>\n                  <td>44.92</td>\n                  <td>33.58</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_49g9h0u7uudivijjerdt(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_p23zeyiyzc4ozr31vagm\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_p23zeyiyzc4ozr31vagm');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_49g9h0u7uudivijjerdt(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_p23zeyiyzc4ozr31vagm\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nIn der folgenden Abbildung siehst du dann das Versuchsdesign für einen Katzenfloh nochmal dargestellt. Der Floh beginnt mit der Ernährungsform `ketchup` und springt dann viermal. Jedes Mal messen wir dann die Sprungweite. Nach einer Pause erhält der gleiche Katzenfloh dann die Ernährungsform `blood` und springt wieder zeitversetzt viermal. Am Ende ernähren wir dann den Floh noch mit Zuckerwasser `ctrl` und lassen ihn abschließend viermal springen. Damit springt ein einzelner Katzenfloh über den Versuch hinweg zwölfmal unter verschiedenen Versuchsbedingungen. Wie du siehst, ist dieses Design vermutlich nicht so häufig in den Agrarwissenschaften anzutreffen.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Versuchsdesign der zweifaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal unter jeder Fütterungsart und wird dabei gemessen. Damit messen wir einen Floh insgesamt zwölfmal. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-repeated-fac2-1.png){#fig-ggplot-theo-repeated-fac2 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nDann schauen wir uns nochmal den Zusammenhang zwischen der Ernährungsart und den einzelnen Zeitpunkten einmal in einer Abbildung an. Die einzelnen Flöhe sind als getrichelte Linien dargestellt. Die durchgezogenen Linien stellen die globalen Mittelwerte an den jeweiligen Zeitpunkten für die Fütterungsart dar. Wir sehen, dass wir Unterschiede in den Sprungweiten über die Zeitpunkte je nach Ernährungsform vorliegen haben. Dabei haben die Kontrolle und der Ketchup ähnliche Verläufe.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten sowie den Fütterungsarten. Die gestrichelte Linie verbindet die einzelnen individuellen Katzenflöhe. Die durchgezogene Linie stellt den Mittelwert zu dem jeweiligen Zeitpunkt dar. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-anova-repeated-fac2-1.png){#fig-ggplot-anova-repeated-fac2 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n#### Dreifaktoriell {.unnumbered .unlisted}\n\nJetzt wird es richtig wild. Wir schauen uns jetzt nämlich nicht nur einen Behandlungsfaktor an, sondern haben zwei Behandlungen sowie die Messwiederholungen als Faktor über die Zeit. Wir schauen hier einmal auf die Fütterungsart mit der Kontrolle als Zuckerwasser, der Gabe von Blut sowie der Fütterung mit Ketchup. Dazu kommt dann noch eine Workoutsession oder eben keine Workoutsession. Wir haben damit zwei Behandlungsfaktoren vorliegen. Da wir ja nun jeden Floh wiederholt messen unter jeder Faktorkombination, kommt hier einiges an Sprungweitenmessung auf jeden einzelnen Floh zu. Daher sind repeated ANOVAs selten. Wir müssen ja nicht nur jeden Floh wiederholt für die Fütterungen durchmessen sondern eben auch nochnmal alles wiederholt für die beiden Workoutgruppen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeated_fac3_tbl <- read_excel(\"data/fleas_complex_data.xlsx\", \n                                sheet = \"repeated-fac3\") |> \n  select(.id, animal, feeding, workout, t1:t4) |> \n  pivot_longer(cols = t1:t4,\n               values_to = \"jump_length\",\n               names_to = \"time_fct\") |> \n  mutate(animal = as_factor(animal),\n         feeding = as_factor(feeding),\n         workout = as_factor(workout),\n         time_fct = as_factor(time_fct),\n         jump_length = round(jump_length, 2),\n         .id = as_factor(.id))\n```\n:::\n\n\n\n\n\nIn der folgenden Tabelle siehst du einmal die Daten im Wide-Format. In den ersten beiden Zeilen siehst du auch schon die Besonderheit. Wir Füttern eben einmal mit Bkut und messen dann viermal die Sprungweite für die beiden Gruppen des Workout. Daher messen wir dann jeden Floh insgesamt vierundzwanzigmal mit den jeweiligen Pausen zwischen den Behandlungskombinationen. Da kommen schon eine Menge Sprünge zusammen.\n\n\n\n\n\n::: {#tbl-repeated-table-fac3 .cell tbl-cap='Rohdaten der Sprungweiten in [cm] nach unterschiedlichen Fütterungsarten und Workoutstatus gemessen an vier Zeitpunkten im Wide-Format für die bessere Übersicht. Hier erhält jeder Floh jede Behandlungskombination aus Fütterung und Workout einmal.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_y6hms71jq1u0bukd0int</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_y6hms71jq1u0bukd0int\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">.id</th>\n                <th scope=\"col\">animal</th>\n                <th scope=\"col\">feeding</th>\n                <th scope=\"col\">workout</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>blood  </td>\n                  <td>yes</td>\n                  <td>57.62</td>\n                  <td>67.87</td>\n                  <td>68.82</td>\n                  <td>61.19</td>\n                </tr>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>blood  </td>\n                  <td>no </td>\n                  <td>42.32</td>\n                  <td>49.28</td>\n                  <td>58.87</td>\n                  <td>50.75</td>\n                </tr>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>49.53</td>\n                  <td>54.91</td>\n                  <td>46.01</td>\n                  <td>34.32</td>\n                </tr>\n                <tr>\n                  <td>1  </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>no </td>\n                  <td>31.02</td>\n                  <td>42.39</td>\n                  <td>26.64</td>\n                  <td>11.59</td>\n                </tr>\n                <tr>\n                  <td>...</td>\n                  <td>...</td>\n                  <td>...    </td>\n                  <td>...</td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>yes</td>\n                  <td>48.82</td>\n                  <td>52.84</td>\n                  <td>41.37</td>\n                  <td>36.02</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ctrl   </td>\n                  <td>no </td>\n                  <td>32.85</td>\n                  <td>32.18</td>\n                  <td>29.1 </td>\n                  <td>16.41</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ketchup</td>\n                  <td>yes</td>\n                  <td>59.16</td>\n                  <td>55.02</td>\n                  <td>39.41</td>\n                  <td>41.03</td>\n                </tr>\n                <tr>\n                  <td>12 </td>\n                  <td>cat</td>\n                  <td>ketchup</td>\n                  <td>no </td>\n                  <td>35.11</td>\n                  <td>36.99</td>\n                  <td>27.43</td>\n                  <td>30.36</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_685nqii8vtmmo1w7gp3m(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_y6hms71jq1u0bukd0int\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_y6hms71jq1u0bukd0int');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_685nqii8vtmmo1w7gp3m(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_y6hms71jq1u0bukd0int\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nEigentlich sieht man das Versuchsdesign erst so richtig in der folgenden Abbildung. Hier siehst du einmal wie ein einzelner Floh alle 24 Sprünge nacheinander unter der jeweiligen Faktorkombination durchführt. In einem idealen Setting folgt natürlich jeder Floh eine zufällige Reihenfolge der Faktorkombinationen. Bitte beachte, dass zwischen den einzelnen Behandlungskombinationen nach dem vierten Sprung natürlich auch eine Zeit vergehen muss, damit sich die Behandlung wieder ausgeschlichen hat.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Versuchsdesign der dreifaktoriellen repeated ANOVA. Jeder Katzenfloh springt viermal unter jeder Kombination von Fütterungsart sowie Workoutstatus und wird dabei gemessen. Damit messen wir einen Floh insgesamt vierundzwanzigmal. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-theo-repeated-fac3-1.png){#fig-ggplot-theo-repeated-fac3 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nAm Ende schauen wir uns auch die Daten einmal in einer Abbildung an. Hier haben wir dann die beiden Workoutgruppen sowie die drei Fütterungsarten in einer Abbildung vereint. Wir sehen, dass die nicht trainierten Flöhe im allgemeinen nicht so weit springen wir die trainierten Flöhe. Ebenso wirkt, dass die Ernährung mit Blut auf jeden Fall die bessere Sprungleistung bewirkt. Teilweise sehen wir, dass sich die Linien der Mittelwerte überschneiden, so dass wir hier eventuell von einer Interaktion ausgehen müssen. Das schauen wir uns dann aber in den entsprechenden statistischen Tests einmal näher an.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung des Zusammenhangs zwischen der gemessenen Sprungweite in [cm] und den vier Messzeitpunkten sowie den Fütterungsarten und Workoutstatus. Die Linienarten stellen den Workoutstatus dar. *[Zum Vergrößern anklicken]*](stat-tests-anova-mixed_files/figure-html/fig-ggplot-anova-repeated-fac3-1.png){#fig-ggplot-anova-repeated-fac3 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n## Mixed ANOVA\n\nBeginnen wir mit der Auswertung unserer beispieldaten mit der mixed ANOVA. Wir kriegen hier natürlich nur eine globale Aussage über den Faktor der Behandlung oder der Zeit. Wenn dich die paarweisen Vergleiche interessieren, dann müsst du noch einen Posthoc-Test anschließen. Mehr Informationen zu der Modellierung findest du auch in dem [Kapitel zu gemischten Modellen](#sec-mixed). Dort erfährst du dann auch, wie du dir den Posthoc-Test bauen kannst. Hier bleiben wir dann bei der ANOVA und den entsprechenden Ergebnissen.\n\n### Zweifaktoriell\n\nAls erstes schauen wir uns die Auswertung der zweifaktoriellen mixed ANOVA an. Nochmal zur Erinnerung, wir haben einen Behandlungsfaktor mit den drei Arten der Fütterung, Kontrolle, Blut und Ketchup, vorliegen. Darüber hinaus messen wir die Sprungweite an sechs Zeitpunkten widerholt für jeden Katzenfloh. Wir wollen jetzt wissen, ob die Fütterung einen Einfluss auf die Sprungweiten der Katzenflöhe über die Zeit hat. Dabei sind wir eigentlich nicht so sehr an den Zeitpunkten wie an der Behandlung der Fütterung interessiert. In einem zweifaktoriellen Versuch können wir uns dann auch immer die Interaktion mit anschauen um zu sehen, die Behandlung unabhängig von den Zeitpunkten ist.\n\n::: panel-tabset\n## `{base}`\n\nDie Standardimplementierung ist eigentlich recht einfahc durchzuführen. Wir haben wie immer erst unseren Messwert $y$ und dann die Formelschreibweise für unser beiden Faktoren und deren Interaktion. Ich mache mir es hier etwas einfacher und schreibe dann noch die Faktoren mit dem `*` um etwas Platz zu sparen. Die Besonderheit hier ist jetzt, dass wir noch spezifizieren müssen welche Variable in unseren Daten die wiederholt gemessenen Individuen darstellt und über welchen Faktor diese Individuen dann wiederholt gemessen wurden. In unserem Fall stehen die Individuen in der Spalte `.id` und wir haben über die Spalte `time_fct` wiederholt die einzelnen Flöhe gemessen. Dann müssen wir das ganze noch in die Funktion `Error()` schreiben, damit die ANOVA auch erkennt, dass wir hier den Teil mit den Messwiederholungen darstellen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * time_fct + Error(.id/time_fct), \n    data = mixed_fac2_tbl) |> \n  tidy() |> \n  na.omit() |> \n  select(term, df, statistic, p.value) |> \n  mutate(p.value = pvalue(p.value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  term                df statistic p.value\n  <chr>            <dbl>     <dbl> <chr>  \n1 feeding              2    214.   <0.001 \n2 time_fct             5    116.   <0.001 \n3 feeding:time_fct    10      8.49 <0.001 \n```\n\n\n:::\n:::\n\n\n\n\n\nIch filtere hier einiges weg, da wir hier viele Informationen erhalten, die wir meistens nicht brauchen. Wir sehen, dass einen signifikanten Einfluss der Fütterung auf die Sprungweite haben, da der p-Wert kleiner ist als das Signifikanzniveau $\\alpha$ gleich 5%. Dies ist auch der Fall für die Zeitpunkte und die Interaktion. Da wir hier eine signifikante Interaktion vorliegen haben, können wir die Fütterungsarten nicht unabhängig über die Zeit interpretieren. Es gibt damit Zeitpunkte an denen die Fütterungen unterschiedliche Effekte zeigen.\n\n## `{rstatix}`\n\nDas R Paket `{rstatix}` liefert mit der Funktion `anova_test()` auch eine Möglichkeit eine mixed ANOVA zu rechnen. Hier ist es dann mit den Optionen etwas anders. Ich mag ja die Formelschreibweise sehr gerne, da weiß ich dann wo was steht. Auf der anderen Seite mag es aber auch einfacher sein, wenn man einfach die Variablen in den Daten einer Option in der Funktion zuordnet. Hier haben wir den Fall, dass wir sagen müssen, was ist unser Messwert? Der Messwert kommt in die Option `dv`. Dann brauchen wir die individuellen IDs in der Option `wid`. Die Faktoren, die wir untereinander vergleichen wollen, kommen dann in die Option `between`. In unserem Fall sind das die Fütterungsarten. Wir wollen wissen ob es zwischen den Fütterungsarten einen Unterschied gibt. Die Zeit als Messwiederholung kommt dann in die Option `within`. Wir messen ja die Zeitpunkte innerhalb (eng. *within*) der Individuen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstatix_aov <- anova_test(data = mixed_fac2_tbl, \n                          dv = jump_length, wid = .id, \n                          between = feeding, within = time_fct)\nget_anova_table(rstatix_aov)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nANOVA Table (type II tests)\n\n            Effect DFn DFd       F        p p<.05   ges\n1          feeding   2  21 214.133 1.08e-14     * 0.750\n2         time_fct   5 105 115.543 4.79e-41     * 0.824\n3 feeding:time_fct  10 105   8.488 5.19e-10     * 0.408\n```\n\n\n:::\n:::\n\n\n\n\n\nNumerisch sind die Werte die gleichen Werte, die wir auch in der `aov()` Funktion erhalten. Im Hintergrund wird auch eine `aov()` gerechnet, nur die Übergabe der Variablen ist hier anders. Neben der Signifikanz kriegen wir in der Spalte `ges` auch noch ein Eta$^2$ Wert wiedergegeben, den wir klassisch interpretieren können. Da wir es in einer mixed ANOVA mit einem etwas anderen Eta$^2$ Wert zu tun haben, können wir hier erstmal sagen, dass je gößer der Wert desto stärker der Effekt. Die p-Werte sind auch hier für alle Vergleiche hoch signifikant.\n\n## `{afex}`\n\nDas R Paket `{afex}` elraubt im besonderen die Modellierung von Messwiederholungen von Beobachtungen. Faktisch ist das Paket um diese Art der Analyse gebaut. Dementsprechend gibt es auch zwei Arten des Funktionsaufrufs. Wir konzentrieren uns hier aus Gründen der konsistents zu `aov()` auf die Funktion `aov_car()`. Am Ende kommen hier die gleichen Werte raus wie schon bei den anderen Tabs. Wir haben hier aber die Möglichkeit etwas mehr zu machen. Alles Weitere dann in der [Vingette zu `{afex}` und dem Posthoc-Test](https://cran.r-project.org/web/packages/afex/vignettes/afex_anova_example.html). Wenn du viel mit Messwiederholungen arbeitest, dann ist eine Einarbeitung in `{afex}` sicherlich sinnvoll. Leider bist du bei `{afex}` an die Normalverteilung und die Varianzhomogenität gebunden. MAn kann eben nicht alles haben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(jump_length ~ feeding * time_fct + Error(.id/time_fct), \n        data = mixed_fac2_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: jump_length\n            Effect          df   MSE          F  ges p.value\n1          feeding       2, 21 13.29 214.13 *** .750   <.001\n2         time_fct 4.11, 86.33 18.70 115.54 *** .824   <.001\n3 feeding:time_fct 8.22, 86.33 18.70   8.49 *** .408   <.001\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nAuch hier erhalten wir die gleichen numwerischen Werte wie schon in den vorherigen Tabs zu `{base}` und `{rstatix}`. Die Signifikanz ist für alle Faktoren sowie der Interaktion gegeben. Wir erhalten auch hier in der Spalte `ges` dann das Eta$^2$ als Effektschätzer zurück. Am Ende finde ich die Ausgabe etwas sperrig.\n\nDas R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(jump_length ~ feeding * time_fct + (time_fct|.id), \n      data = mixed_fac2_tbl)\n```\n:::\n\n\n\n\n\n## `{MANOVA.RM}`\n\nMit dem R Paket `{MANOVA.RM}` haben wir auch die Möglichkeit eine mixed ANOVA zu rechnen in dem wir die Funktion `RM()` nutzen. Das ist natürlich etwas verwirrend vom Namen, aber wenn wir die Optionen richtig mit den Variablen belegen, dann rechnen wir auch eine mixed ANOVA. Hier müssen wir dann angeben in welche Spalte die Beobachtungen sind und was der `within` Faktor ist. Bei uns ist das dann einfach. Wir nutzen die Variable `.id` sowie als Faktor der Messwiederholungen `time_fct`. Der Rest ist eigentlich nicht so wichtig. Wenn du die Funktion in deiner Analyse rechnest, dann würde ich die Option `iter` auf 1000 setzen.\n\nAm Ende muss sich aber dann doch fragen, ob es eine noch hässlichere Ausgabe einer Funktion gibt. Ich glaube eher nicht, aber das soll die Leistung des Algorithmus nicht schmälern. Wir kämpfen uns da doch mal durch. Manche Informationen sind dann einfach auch wieder über, da wir je eigentlich nur wissen wollen, ob wir einen signifikanten Einfluss der Behandlung `feeding` vorliegen haben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRM(jump_length ~ feeding * time_fct, data = mixed_fac2_tbl, \n   subject = \".id\", within = c(\"time_fct\"), iter = 100, \n   resampling = \"Perm\", seed = 1234) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall: \njump_length ~ feeding * time_fct\nA repeated measures analysis with 1 within-subject factor(s) ( time_fct ) and 1 between-subject factor(s). \n\nDescriptive:\n   feeding time_fct n  Means Lower 95 % CI Upper 95 % CI\n1     ctrl       t0 8 32.510        27.041        37.979\n4     ctrl       t1 8 28.544        22.315        34.773\n7     ctrl       t2 8 24.625        19.272        29.978\n10    ctrl       t3 8 21.853        17.032        26.673\n13    ctrl       t4 8 18.774        12.618        24.929\n16    ctrl       t5 8  5.239         0.156        10.321\n2    blood       t0 8 40.072        34.510        45.635\n5    blood       t1 8 28.651        24.154        33.148\n8    blood       t2 8 25.236        17.146        33.327\n11   blood       t3 8 18.062        11.397        24.728\n14   blood       t4 8 20.250        14.413        26.087\n17   blood       t5 8 17.351        11.442        23.260\n3  ketchup       t0 8 50.941        46.864        55.018\n6  ketchup       t1 8 45.538        41.039        50.036\n9  ketchup       t2 8 34.306        30.118        38.494\n12 ketchup       t3 8 29.146        23.946        34.346\n15 ketchup       t4 8 27.706        24.583        30.830\n18 ketchup       t5 8 31.434        25.615        37.252\n\nWald-Type Statistic (WTS):\n                 Test statistic df   p-value \nfeeding          \"396.501\"      \"2\"  \"<0.001\"\ntime_fct         \"1009.823\"     \"5\"  \"<0.001\"\nfeeding:time_fct \"83.636\"       \"10\" \"<0.001\"\n\nANOVA-Type Statistic (ATS):\n                 Test statistic df1     df2      p-value \nfeeding          \"214.133\"      \"1.982\" \"72.609\" \"<0.001\"\ntime_fct         \"115.543\"      \"4.111\" \"Inf\"    \"<0.001\"\nfeeding:time_fct \"8.488\"        \"6.975\" \"Inf\"    \"<0.001\"\n\np-values resampling:\n                 Perm (WTS)\nfeeding          \"<0.001\"  \ntime_fct         \"<0.001\"  \nfeeding:time_fct \"0.02\"    \n```\n\n\n:::\n:::\n\n\n\n\n\nAls erstes erhalten wir eine lange Tabelle mit der deskriptiven Statistik der Mittelwerte für jede Faktorkombination der Fütterungsart sowie dem Zeitpunkt. Dazu dann noch die passenden 95% Konfidenzintervalle. Dann kommen drei Tests nacheinander. Das ist auch immer das Problem, wenn du dann drei Ausgaben hast und nicht weißt, welche du nehmen sollst. Ich würde hier die Ergebnisse der `ANOVA-Type Statistic (ATS)` nehmen und den Rest liegen lassen. Die p-Werte aus dem Permutationstest `p-values resampling` haben zwar auch ihre Berechtigung bei nicht normalverteilten oder varianzheterogenen Daten aber ich würde dann hier auch eher das R Paket `{WRS2}` vorziehen.\n\n## `{WRS2}`\n\nKommen wir nun zum letzten Paket, was ich hier noch für die zweifaktorielle mixed ANOVA zeigen möchte. Es handelt sich um `{WRS2}`, welches dann auch erlaubt die zweifaktorielle mixed ANOVA zu rechnen, wenn wir die Annahme der Normalverteilung an den Messwert oder keine Varianzhomogenität in den Gruppen vorliegen haben. Es geht dann auch beides. Das ist dann auch der große Vorteil von `{WRS2}`. Das Modell sieht genauso aus wie auch bei den anderen Anwendungen. Wir müssen hier nur einmal in der Option `id` angeben, welche Spalte unsere ID ist.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbwtrim(jump_length ~ feeding * time_fct, id = .id, data = mixed_fac2_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nbwtrim(formula = jump_length ~ feeding * time_fct, id = .id, \n    data = mixed_fac2_tbl)\n\n                    value df1    df2 p.value\nfeeding          186.6213   2 9.6997  0.0000\ntime_fct         142.2153   5 9.7570  0.0000\nfeeding:time_fct   4.6665  10 9.4221  0.0133\n```\n\n\n:::\n:::\n\n\n\n\n\nDie Ergebnisse sind dann vom p-Wert inhaltlich gleich wie bei den anderen Anwendungen. Das habe ich hier auch erwartet, denn unsere Sprungweiten habe ich so gebaut, dass die Sprungweiten normalverteilt sind. Nicht immer können wir aber in unseren Daten davon ausgehen, dass wir normalverteilte Messwerte vorliegen haben. Da ist diese Alternative hier sehr gut.\n:::\n\nWir haben ja in den obigen Anwendungen der mixed ANOVA immer eine signifikante Interaktion gefunden. Daher wollen wir uns einmal in einem Liniendiagramm der Mittelwerte die Sachlage näher anschauen. Wenn wir eine Interaktion erwarten, dann sollten sich die Linien der Mittelwerte kreuzen. Wir haben ja auch in allen Analysen eine signifkante Interaktion voriegen. Wenn wir jetzt auf die Abbildung schauen, dann sehen wir auch, dass sich die Lienien für die Fütterung mit Blut und der Kontrolle kreuzen. Wir haben hier eine Interaktion vorliegen. Auch sind die Unterschiede zwischend den Fütterungen nicht immer parallel zueinander mit dem gleichen Effekt oder eben Abstand.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmixed_fac2_tbl |> \n  ggplot(aes(x = time_fct, y = jump_length,\n             color = feeding, group = feeding)) +\n  theme_minimal() +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  stat_summary(fun = \"mean\", geom = \"line\") +\n  theme(legend.position = \"top\") +\n  scale_color_okabeito()\n```\n\n::: {.cell-output-display}\n![Liniendigramm mit den Mittelwerten aller Faktorkombinationen der beiden Faktoren `feeding` und `time_fct`. Die Linien kreuzen sich leicht, es liegt eine Interaktion vor. Eine allgemeine Aussage über die Sprungweite und der Fütterung lässt sich nicht unabhängig vom Zeitpunkt treffen. Die Interaktion ist aber nicht sehr stark.](stat-tests-anova-mixed_files/figure-html/fig-interactionplot-mixed-2fac-1.png){#fig-interactionplot-mixed-2fac fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n### Dreifaktoriell\n\nJetzt betrachten wir noch die dreifaktorielle mixed ANOVA. Dieses Design kommt dann vor, wenn du zwei Behandlungsfaktoren sowie einen Zeitfaktor in deinen Daten vorliegen hast. In unserem Fall ist der erste Faktor die Fütterungsart mit den Gruppen Kontrolle, Blut und Ketchup sowie als zweiten Faktor der Status des Workouts des einzlenen Flohs. Wir schauen hier nur Katzenflöhe an. Dann messen wir die Sprungweite jedes einzelnen Flohs nochmal zu sechs Zeitpunkten. Hier ist es wieder wichtig darauf zu achten, was mit einem einzelnen Floh passiert und gemessen wird. Wir messen hier jede Faktorkombination und Wiederholung mit einem neuen Floh. Schaue dir dazu nochmal die Übersicht des Designs in dem Abschnitt zu den Daten in der @fig-ggplot-theo-mixed-fac3 an. Auch hier ist es dann manchmal von Vorteil zu wissen, wechler Faktor einem eigentlich am meisten interessiert. Wir betrachten hier jetzt alle drei Faktoren und deren Interaktionen als gleichwertig. Wir können die dreifaktorielle mixed ANOVA nicht mehr in dem R Paket `{WRS2}` rechnen. Das Paket biette keine Funktion dafür an.\n\n::: panel-tabset\n## `{base}`\n\nBeginnen wir wieder mit der Standardfunktion in `{base}` mit `aov()` und deren Anwendung. Hier kommt dann die verkürzende Formelschreibweise mit dem Stern `*` zum Einsatz. Ich kann mir nicht merken was alle Faktorkombinationen zusammen mit allen Interaktionen sind. Daher nutze ich dann einmal die Schreibweise, die mir diese Überlegung abnimmt. Dann muss ich noch in dem Fehlerterm mitteilen wer `.id` in welchen Faktor `time_fct` wiederholt wird. Damit ist die dreifaktorielle mixed ANOVA der zweifaktoriellen mixed ANOVA sehr ähnlich. Wir erhalten dann folgende Ausagen, die ich nochmal aufgereinigt habe, da ich nicht alle Spalten und Informationen brauche. Auch mag ich den p-Wert gerne etwas übersichtlicher.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * workout * time_fct + Error(.id/time_fct), \n    data = mixed_fac3_tbl) |> \n  tidy() |> \n  na.omit() |> \n  select(term, df, statistic, p.value) |> \n  mutate(p.value = pvalue(p.value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  term                        df statistic p.value\n  <chr>                    <dbl>     <dbl> <chr>  \n1 feeding                      2   318.    <0.001 \n2 workout                      1    14.0   0.002  \n3 feeding:workout              2    79.0   <0.001 \n4 time_fct                     5   113.    <0.001 \n5 feeding:time_fct            10     4.03  <0.001 \n6 workout:time_fct             5     0.943 0.457  \n7 feeding:workout:time_fct    10     1.45  0.171  \n```\n\n\n:::\n:::\n\n\n\n\n\nWir sehen sofort, dass die beiden Faktoren der Fütterungsart sowie des Workout signifikant sind. Auch haben wir eine signifikante Interaktion zwischen den beiden Faktoren vorliegen. Die Gruppen der Fütterung verhalten sich in den beiden Gruppen des Workouts nicht gleich. Auch ist die Zeit signifkant, es passiert also etwas mit der Sprungweite über die Zeit. Im Weiteren haben wir eine signifikante Interaktion zwischen der Fütterungsart und der Zeit, so dass sich hier auch über die Zeit die Gruppen der Fütterung anders verhalten. Die anderen Interaktionen sind nicht signifikant.\n\n## `{rstatix}`\n\nJetzt kürze ich ein wenig ab, da die Ergebnisse ja gleich sind in `{rstatix}` zu der mixed ANOVA mit `aov()`. Die Funktionen sind ja identisch nur das sich die Eingabe unterscheidet. Hier sieht man dann eventuell besser, dass wir *zwischen* den Fütterungsarten und den Workouts vergleichen wollen und wir als Wiederholung die `.id` der einzelnen Flöhe vorliegen haben. Wir erhalten hier nochmal als Effektschätzer das Eta$^2$ wiedergegeben, was wirklich ein Vorteil ist. Ansonsten würde ich fast die `aov()` Funktion vorziehen. Am Ende filtere ich wieder um dann eine etwas ausgeräumte Ausgabe zu haben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstatix_aov <- anova_test(data = mixed_fac3_tbl, \n                          dv = jump_length, wid = .id, \n                          between = c(feeding, workout), \n                          within = time_fct)\nget_anova_table(rstatix_aov) |> \n  as_tibble() |> \n  select(Effect, F, p, ges) |> \n  mutate(p = pvalue(p))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  Effect                         F p        ges\n  <chr>                      <dbl> <chr>  <dbl>\n1 feeding                  318.    <0.001 0.786\n2 workout                   14.0   0.002  0.075\n3 time_fct                 113.    <0.001 0.849\n4 feeding:workout           79.0   <0.001 0.477\n5 feeding:time_fct           4.03  <0.001 0.286\n6 workout:time_fct           0.943 0.457  0.045\n7 feeding:workout:time_fct   1.45  0.171  0.126\n```\n\n\n:::\n:::\n\n\n\n\n\n## `{afex}`\n\nBei dem R Paket `{afex}` ist es ähnlich wie schon bei dem R Paket `{rstatix}`. Hier ist dann die Formelschreibweise ähnlich wie schon bei `aov()`. Das macht die Nutzung angenehmer für mich. Als Besonderheit können wir dann auch `{afex}` nutzen wie ein lineares gemischtes Modell. Intern ruft dann aber auch `{afex}` das Paket `{car}` auf und nutzt dessen Algorithmus. Daher ist hier die Nutzung der Type II ANOVA und Type III ANOVA einfacher umzusetzen. Ich mag das Paket gerne, da es auch speziell für Messwiederholungen gebaut wurde.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(jump_length ~ feeding * workout * time_fct + Error(.id/time_fct), \n        data = mixed_fac3_tbl) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: jump_length\n                    Effect          df   MSE          F  ges p.value\n1                  feeding       2, 18 10.55 318.13 *** .786   <.001\n2                  workout       1, 18 10.55   13.98 ** .075    .002\n3          feeding:workout       2, 18 10.55  79.04 *** .477   <.001\n4                 time_fct 3.88, 69.75 23.44 112.78 *** .849   <.001\n5         feeding:time_fct 7.75, 69.75 23.44   4.03 *** .286   <.001\n6         workout:time_fct 3.88, 69.75 23.44       0.94 .045    .442\n7 feeding:workout:time_fct 7.75, 69.75 23.44       1.45 .126    .193\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nDas R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(jump_length ~ feeding * workout * time_fct + (time_fct|.id), \n      data = mixed_fac3_tbl)\n```\n:::\n\n\n\n\n\n## `{MANOVA.RM}`\n\nAm Ende stelle ich noch das R Paket `{MANOVA.RM}` vor. Auch hier haben wir dann wieder zu viel Ausgabe. Ich finde hier wird dann deutlich, dass die deskriptive Statistik über ist. Ich will doch nur eine mixed ANOVA rechnen. In der Funktion `RM()` spezifizieren wir ja nur den `within` Faktor, der sich hier ja auch bei einer dreifaktoriellen mixed ANOVA nicht ändert. Wir haben auch hier wieder drei Tests, wobei ich dann auch nur die Ergebnisse der `ANOVA-Type Statistic (ATS)` nehmen und den Rest liegen lassen würde.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRM(jump_length ~ feeding * workout * time_fct, data = mixed_fac3_tbl, \n   subject = \".id\", within = c(\"time_fct\"), iter = 100, \n   resampling = \"Perm\", seed = 1234) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall: \njump_length ~ feeding * workout * time_fct\nA repeated measures analysis with 1 within-subject factor(s) ( time_fct ) and 2 between-subject factor(s). \n\nDescriptive:\n   feeding workout time_fct n  Means Lower 95 % CI Upper 95 % CI\n1     ctrl     yes       t0 4 37.718        19.752        55.683\n7     ctrl     yes       t1 4 34.570        24.732        44.408\n13    ctrl     yes       t2 4 31.290        26.489        36.091\n19    ctrl     yes       t3 4 24.512         9.769        39.256\n25    ctrl     yes       t4 4 26.165        14.107        38.223\n31    ctrl     yes       t5 4 10.075        -4.546        24.696\n4     ctrl      no       t0 4 33.405        21.056        45.754\n10    ctrl      no       t1 4 29.212        14.480        43.945\n16    ctrl      no       t2 4 21.595         8.099        35.091\n22    ctrl      no       t3 4 19.015         1.083        36.947\n28    ctrl      no       t4 4 16.195         8.369        24.021\n34    ctrl      no       t5 4  7.775        -0.910        16.460\n2    blood     yes       t0 4 46.035        35.756        56.314\n8    blood     yes       t1 4 31.495        21.001        41.989\n14   blood     yes       t2 4 25.635         7.979        43.291\n20   blood     yes       t3 4 25.080        20.580        29.580\n26   blood     yes       t4 4 21.587         2.378        40.797\n32   blood     yes       t5 4 18.445        10.144        26.746\n5    blood      no       t0 4 52.303        40.389        64.216\n11   blood      no       t1 4 46.498        39.556        53.439\n17   blood      no       t2 4 36.158        15.701        56.614\n23   blood      no       t3 4 32.672        19.062        46.283\n29   blood      no       t4 4 34.295        14.581        54.009\n35   blood      no       t5 4 29.208        17.262        41.153\n3  ketchup     yes       t0 4 56.428        41.856        70.999\n9  ketchup     yes       t1 4 47.342        25.965        68.720\n15 ketchup     yes       t2 4 36.908        26.465        47.350\n21 ketchup     yes       t3 4 32.180        19.098        45.262\n27 ketchup     yes       t4 4 32.422        26.616        38.229\n33 ketchup     yes       t5 4 35.362        24.276        46.449\n6  ketchup      no       t0 4 57.062        42.258        71.867\n12 ketchup      no       t1 4 52.618        38.726        66.509\n18 ketchup      no       t2 4 39.200        21.873        56.527\n24 ketchup      no       t3 4 39.190        18.245        60.135\n30 ketchup      no       t4 4 31.390        17.678        45.102\n36 ketchup      no       t5 4 31.887        16.088        47.687\n\nWald-Type Statistic (WTS):\n                         Test statistic df   p-value \nfeeding                  \"1042.469\"     \"2\"  \"<0.001\"\nworkout                  \"13.98\"        \"1\"  \"<0.001\"\nfeeding:workout          \"133.546\"      \"2\"  \"<0.001\"\ntime_fct                 \"879.365\"      \"5\"  \"<0.001\"\nfeeding:time_fct         \"47.128\"       \"10\" \"<0.001\"\nworkout:time_fct         \"5.119\"        \"5\"  \"0.402\" \nfeeding:workout:time_fct \"25.413\"       \"10\" \"0.005\" \n\nANOVA-Type Statistic (ATS):\n                         Test statistic df1     df2      p-value \nfeeding                  \"318.133\"      \"1.725\" \"36.605\" \"<0.001\"\nworkout                  \"13.98\"        \"1\"     \"36.605\" \"0.001\" \nfeeding:workout          \"79.042\"       \"1.725\" \"36.605\" \"<0.001\"\ntime_fct                 \"112.777\"      \"3.875\" \"Inf\"    \"<0.001\"\nfeeding:time_fct         \"4.028\"        \"6.058\" \"Inf\"    \"<0.001\"\nworkout:time_fct         \"0.943\"        \"3.875\" \"Inf\"    \"0.435\" \nfeeding:workout:time_fct \"1.451\"        \"6.058\" \"Inf\"    \"0.19\"  \n\np-values resampling:\n                         Perm (WTS)\nfeeding                  \"<0.001\"  \nworkout                  \"<0.001\"  \nfeeding:workout          \"<0.001\"  \ntime_fct                 \"<0.001\"  \nfeeding:time_fct         \"0.16\"    \nworkout:time_fct         \"0.64\"    \nfeeding:workout:time_fct \"0.39\"    \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\nNachdem wir ja unsere mixed ANOVA mit einem der vorgeschlagenen Algorithmen gerechnet haben, sehen wir dass wir eine signifikante Interaktion vorliegen haben. Zum einen ist der Interaktionsterm `feeding:workout` signifikant sowie der Interaktionsterm `feeding:time_fct` auch. Damit haben wir andere Mittelwerte der Sprungweite für die Fütterungsarten zu den beiden Workouts sowie unterschiedliche Mittelwerte der Sprungweiten über die Zeit und Fütterungsarten. Ja und das sehen wir dann auch in der folgenden Abbildung. Bei der Kontrollbehandlung und der Ketchupfütterung hat das Workout exakt einen anderen Effekt. Bei der Kontrolle springen die nicht trainierten Flöhe weniger weit. Bei der Ernährung mit Ketchup haben das Training einen negativen Effekt. Eine Drehung des Effekts des Workouts nach der Fütterung. Auch kreuzen die Mittelwerte der Sprungweiten über die Zeit nach der Fütterungsart.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmixed_fac3_tbl |> \n  ggplot(aes(x = time_fct, y = jump_length,\n             color = feeding, linetype = workout, \n             group = interaction(feeding, workout))) +\n  theme_minimal() +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  stat_summary(fun = \"mean\", geom = \"line\") +\n  theme(legend.position = \"top\") +\n  scale_color_okabeito()\n```\n\n::: {.cell-output-display}\n![Liniendigramm mit den Mittelwerten aller Faktorkombinationen der beiden Faktoren `feeding` sowie `workout` und `time_fct`. Die Linien sind in der Reichenfolge verdreht, es liegt eine Interaktion vor. Auch kruezen sich die Fütterungsarten über die Zeit. Eine allgmeine Aussage über die Sprungweite und die Fütterung soweie dem Workout lässt sich nicht unabhängig vom Zeitpunkt treffen.](stat-tests-anova-mixed_files/figure-html/fig-interactionplot-mixed-3fac-1.png){#fig-interactionplot-mixed-3fac fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n## Repeated measurement ANOVA\n\n::: callout-caution\n## Achtung, bitte beachten!\n\nWillst du wirklich eine *repeated* ANOVA rechnen oder doch eher eine mixed ANOVA? Der Unterschied ist subtil und hängt davon ab, welche Behandlungskombinationen deine einzelnen Beobachtungen erhalten haben. Schaue im Zweifel nochmal oben in der Einleitung um dich zu versichern. Häufig möchtest du nämlich eine mixed ANOVA rechnen.\n:::\n\nSchauen wir also einmal was die repeated ANOVA einmal macht. Hier nochmal ganz wichtig zu Anfang. Wir werden jetzte *jede* Beobachtung mit *jeder* Faktorkombination zu *jedem* Zeitpunkt messen. Das heißt in unserem Konkreten Fall, dass wir bei jeden Katzenfloh die Sprungweite zu jedem Zeitpunkt messen. Das macht ja auch erstmal Sinn. Das wäre dann die einfaktorielle repated ANOVA. Wir haben sonst auch keinen weiteren Faktor im Experiment. Wenn wir jetzt noch die Fütterungsart als Faktor hinzunehmen, dann füttern wir jeden Floh mit allen drei Arten der Fütterung. Jeder Floh erhält Zuckerwasser, springt dann mehrfach und wir messen die Sprungweite. Das machen wir dann mit dem selben Floh nochmal für die Ernährungsart Blut und Ketchup. Wenn dann noch ein zweiter Behandlungsfaktor hinzukommt wie das Workout, dann müssen wir unter jeder Workoutbedinung einmal alle drei Fütterungsarten die Sprungweiten für einen Floh durchmessen. Das heißt wir messen dann einen einzelnen Floh ganz schön oft. Im Bereich der Agrarwissenschaften mag diese Art der wiederholten Behandlung eher selten vorkommen. Daher hier auch ausdrücklich die Warnung, sich nochmal klar zu machen, wie du die einzelnen Beobachtungen nun bemisst. Ich habe auch erst ein wenig gebraucht um die repeated ANOVA von Design her zu verstehen.\n\n### Einfaktoriell\n\nBeginnen wir mit der einfaktoriellen repeated ANOVA. Hier haben wir die Fragestellung vorliegen, ob die Zeit einen Einfluss auf die Sprungweiten der Katzenflöhe hat. Wir haben sonst keinen weiteren Behandlungsfaktor. Wir messen einfach nur die Sprungweite der Katzenflöhe wiederholt und schauen, ob sich die Sprungweiten über die Zeit ändern. Das Experiment ist eher ungewöhnlich, da wir hier ja nur wiederholt messen und sonst nichts tun. Faktisch ist es ein *proof-of-principle*, ob wir überhaupt einen Effekt der Zeit auf die Sprungweite haben.\n\n::: panel-tabset\n## `{base}`\n\nJetzt ist im Prinzip die Schreiweise das Besondere. Wir haben hier jetzt nur die Zeit als einen Einflussfaktor. Den packen wir jetzt einmal vorne in unser Modell und dann einmal hinten in den Fehlerterm. Dann müssen wir auch hier sagen, dass wir die Beobachtungen wiederholt im Faktor Zeit gemessen haben. Dann können wir auch schon die ANOVA rechnen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl)|> \n  tidy() |> \n  na.omit() |> \n  select(term, df, statistic, p.value) |> \n  mutate(p.value = pvalue(p.value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  term        df statistic p.value\n  <chr>    <dbl>     <dbl> <chr>  \n1 time_fct     3      19.1 <0.001 \n```\n\n\n:::\n:::\n\n\n\n\n\nWir sehen, dass der p-Wert kleiner ist als das Signifikanzniveau $\\alpha$ gleich 5% und damit haben wir einen signifkanten Einfluss der Zeit auf die Sprungweite der Katzenflöhe. Mehr testen wir hier auch nicht. Wir haben ja auch nur die Zeit als Faktor in unserem Modell.\n\nWenn du dann noch einen Effektschätzer brauchst, dann kannst du das R Paket `{effectsize}` mit der Funktion `eta_squared()` nutzen. Wir wollen dann noch das [generalisierte Eta$^2$](https://easystats.github.io/effectsize/articles/anovaES.html#generalized-eta2) nutzen, da wir die Zeitpunkte nur beobachten und nicht als experimentellen Faktor festgelegt haben. Dazu dann auch mehr in der Arbeit von @olejnik2003generalized mit dem Titel [Generalized eta and omega squared statistics: measures of effect size for some common research designs](https://coshima.davidrjfikis.com/EPRS8540/uploadf07/olejnik_PsychMeth2003.pdf).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl) |> \n  eta_squared(generalized = \"time_fct\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Effect Size for ANOVA (Type I)\n\nGroup        | Parameter | Eta2 (generalized) |       95% CI\n------------------------------------------------------------\n.id:time_fct |  time_fct |               0.46 | [0.22, 1.00]\n\n- Observed variables: time_fct\n- One-sided CIs: upper bound fixed at [1.00].\n```\n\n\n:::\n:::\n\n\n\n\n\n## `{rstatix}`\n\nWir können auch das R Paket `{rstatix}` nutzen. Hier rufen wir am Ende dann doch auch nur die `aov()` Funktion auf, schreiben aber die Variablen in unseren Daten etwas anders in die Funkion `anova_test()`. Du musst eben wissen, dass hier die abhängige Variable `dv` die Sprungweite ist, du dann die Beobachtungen in `wid` schreibst und die Zeit in die Option `within`. Am Ende ist es dann auch hier eine Geschmackssache, welche Funktion dir besser gefällt und passt.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstatix_aov <- anova_test(data = repeated_fac1_tbl, \n                          dv = jump_length, wid = .id, within = time_fct)\nget_anova_table(rstatix_aov)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nANOVA Table (type III tests)\n\n    Effect DFn DFd      F        p p<.05   ges\n1 time_fct   3  33 19.146 2.26e-07     * 0.465\n```\n\n\n:::\n:::\n\n\n\n\n\nEs kommt das Gleiche numerisch raus, wie schon bei `aov()`. Wir erhalten hier aber zusätzlich noch einen Effektschätzer in der Spalte `ges`, was dem Eta$^2$ entspricht. Demensprechend ein Vorteil der Funktion.\n\n## `{afex}`\n\nDas R Paket `{afex}` kommt bei einer so simplen einfaktoriellen repeated ANOVA dann auf die gleichen Zahlen wie schon die beiden vorherigen Algorithmen. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben. Ich bevorzuge dann ja die Schreibweise hier von `{afex}`, da ich diese hier etwas klarer finde als bei `{rstatix}`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(jump_length ~ time_fct + Error(.id/time_fct), data = repeated_fac1_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: jump_length\n    Effect          df   MSE         F  ges p.value\n1 time_fct 2.68, 29.52 11.85 19.15 *** .465   <.001\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nDas R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(jump_length ~ time_fct + (time_fct|.id), data = repeated_fac1_tbl)\n```\n:::\n\n\n\n\n\n## `{MANOVA.RM}`\n\nAm Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem einfaktoriellen Fall die gleichen Werte wie in den anderen R Paketen erhalten. Hir haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRM(jump_length ~ time_fct, data = repeated_fac1_tbl, \n   subject = \".id\", within = \"time_fct\", iter = 100, \n   resampling = \"Perm\", seed = 1234) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall: \njump_length ~ time_fct\nA repeated measures analysis with 1 within-subject factor(s) ( time_fct ) and 0 between-subject factor(s). \n\nDescriptive:\n           time_fct  n  Means Lower 95 % CI Upper 95 % CI\ntime_fct         t1 12 24.081        22.212        25.950\ntime_fct.1       t2 12 30.642        28.189        33.096\ntime_fct.2       t3 12 28.107        24.974        31.239\ntime_fct.3       t4 12 21.410        18.982        23.838\n\nWald-Type Statistic (WTS):\n         Test statistic df  p-value \ntime_fct \"69.318\"       \"3\" \"<0.001\"\n\nANOVA-Type Statistic (ATS):\n         Test statistic df1     df2   p-value \ntime_fct \"19.146\"       \"2.684\" \"Inf\" \"<0.001\"\n\np-values resampling:\n         Perm (WTS)\ntime_fct \"<0.001\"  \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### Zweifaktoriell\n\nDie zweifaktorielle repeated ANOVA wird jetzt schon interessanter. Wir haben jetzt nämlich neben der Zeit als Faktor noch eine Behandlung vorliegen. In unserem Beispiel erhält *jeder* Floh drei Arten der Fütterung wiederholt gefüttert. Zum einen erhält jeder Floh ein Zuckerwasser, dann Blut und zum Schluss Ketchup als Nahrung. Die Reihenfolge sollte sich dann von Floh Floh noch unterscheiden und die Zeiten zwischen den Behandlungen dann so lang gewählt werden, dass die Ernährung förmlich ausgewaschen ist. Die Idee ist, dass die vorherige Ernährungsform keinen Einfluss auf die neue Ernährung hat. Dann müssen wir das Ganze ja auch noch wiederholt über vier Zeitpunkte die Sprungweite messen. Daher misst du hier ganz schön viel. Häufig haben wir dieses Design nicht in den Agrarwissenschaften vorliegen. Wir können aber im Bereich der Nutztierwissenschaften schon das ein oder andere Mal so einen Fall vorliegen haben, wo wir Tiere wiederholt mit einer Behandlung verarzten.\n\n::: panel-tabset\n## `{base}`\n\nDie Frage ist jetzt immer, wie schreibe ich jetzt das Modell richtig? Der komplizierte Teil ist eigentlich der Fehlerterm `Error()` aber auch der Teil davor. Ich nutze hier wieder die Kurzschreibweise mit dem Stern `*` um alle Faktorkombinationen plus Interaktion im Modell zu haben. Das wird eben dann ab zwei Faktoren etwas groß. So ist es dann weniger anfällig für Fehler. Dann musst du noch darauf achten, dass du in dem Fehlerterm die Klammern richtig setzt, sonst funktioniert es dort auch nicht. Erst kommt der Spaltenname für die einzelnen Flöhe `.id` und dahinter nach dem Slash `/` dann die Faktorkombinationen der Behandlungen und der Zeit. Dann räume ich die Ausgabe nochmal vollkommen auf, damit ich auch was sehe.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * time_fct + Error(.id/(feeding * time_fct)), \n    data = repeated_fac2_tbl) |> \n  tidy() |> \n  na.omit() |> \n  select(term, df, statistic, p.value) |> \n  mutate(p.value = pvalue(p.value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  term                df statistic p.value\n  <chr>            <dbl>     <dbl> <chr>  \n1 feeding              2    151.   <0.001 \n2 time_fct             3     64.7  <0.001 \n3 feeding:time_fct     6      9.48 <0.001 \n```\n\n\n:::\n:::\n\n\n\n\n\nWie wir sehen sind beide Faktoren der Zeit und der Fütterungsart signifikant. Der p-Wert ist kleiner als das Signifikanzniveau $\\alpha$ gleich 5%. Auch haben wir eine signifikante Interaktion zwischen den Fütterungsarten und der Zeit. Daher zeigen die Fütterungsarten unterschiedliche Sprungweiten zu den verschiedenen Zeitpunkten.\n\nDann können wir uns auch den Effektschätzer Eta\\^$^2$ berechnen lassen. Hier müssen wir dann das ANOVA Modell einmal in die Funktion `eta_squared()` stecken und darauf achten, dass wir angeben, dass wir die Zeitpunkte nur beobachtet haben und nicht experimentell festgelegt. Deshalb kommt `time_fct` noch in die Option `generalized` mit rein. Die Effektschätzer unterscheiden sich hier immer ein wenig, dass kommt dann immer auf den verwendeten Algorithmus an.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * time_fct + Error(.id/(feeding * time_fct)), \n    data = repeated_fac2_tbl) |> \n  eta_squared(generalized = c(\"time_fct\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Effect Size for ANOVA (Type I)\n\nGroup                |        Parameter | Eta2 (generalized) |       95% CI\n---------------------------------------------------------------------------\n.id:feeding          |          feeding |               0.48 | [0.20, 1.00]\n.id:time_fct         |         time_fct |               0.40 | [0.15, 1.00]\n.id:feeding:time_fct | feeding:time_fct |               0.13 | [0.00, 1.00]\n\n- Observed variables: time_fct\n- One-sided CIs: upper bound fixed at [1.00].\n```\n\n\n:::\n:::\n\n\n\n\n\n## `{rstatix}`\n\nDas R Paket `{rstatix}` hat eine andere Schreibweise des Modells. Im Prinzip schreiben wir hier wieder nicht das Modell auf, sondern weisen die Spaltennamen dann den jeweiligen Optionen zu. Hier werden dann auch alle Interaktionen gerechnet, du kannst die Interaktionen aller Faktorkombinationen nicht abstellen. Wir setzten dann unseren Endpunkt `jump_length` in die Option `dv` und die einzelnen Beobachtungen in die Option `wid`. Dann müssen wir noch die beiden Faktoren der Zeit und der Behandlung in die Option `within` einfügen. Dann haben wir auch schon alles zusammen. Was hier etwas doof ist, ist das wir hier die Formelschreibweise in R verlassen, die wir dann aber überall sonst nutzen. Dafür erhalten wir dann aber das Eta$^2$ gleich als `ges` wieder aus der Funktion zurück.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstatix_aov <- anova_test(data = repeated_fac2_tbl, \n                          dv = jump_length, wid = .id, \n                          within = c(feeding, time_fct))\nget_anova_table(rstatix_aov)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nANOVA Table (type III tests)\n\n            Effect DFn DFd       F        p p<.05   ges\n1          feeding   2  22 150.881 1.43e-13     * 0.667\n2         time_fct   3  33  64.693 6.57e-14     * 0.459\n3 feeding:time_fct   6  66   9.480 1.69e-07     * 0.216\n```\n\n\n:::\n:::\n\n\n\n\n\nWir erhalten die gleichen Ergebnisse wie schon bei der Funktion `aov()` wiedergegeben. Das überrascht auch nicht, den die Berechnung ist ja die gleiche Berechnung wie auch in `aov()` nur eben dann mit einem anderen Funktionsaufruf.\n\n## `{afex}`\n\nDas R Paket `{afex}` nutzt die Formelschreibweise und kann auch genau so bedient werden wie schon die Funktion `aov()`. Dafür können wir aber mit der Option `type` auch anderen Typen der ANOVA nutzen und nicht nur die Type I ANOVA in `aov()`. Das ist eigentlich die große Stärke von dem R Paket `{afex}`, dass wir hier flexibel bei der Auswahl der Typen sind. Bei der einfaktoriellen ANOVA war es noch egal, aber hier macht es mit zwei Faktoren dann schon einen Unterschied welche Art der ANOVA du rechnen möchtest. Ich nutze hier den Standard und damit die Type III ANOVA. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(jump_length ~ feeding * time_fct + Error(.id/feeding * time_fct), \n        data = repeated_fac2_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: jump_length\n            Effect          df   MSE          F  ges p.value\n1          feeding 1.84, 20.24 18.95 150.88 *** .667   <.001\n2         time_fct 2.43, 26.71 14.23  64.69 *** .459   <.001\n3 feeding:time_fct 3.94, 43.39 19.43   9.48 *** .216   <.001\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nDie Ergebnisse sind ähnlich wie schon bei den beiden anderen Algorithmen, aber hier macht es dann einen Unterschied welche ANOVA grechnet wird. Wir rechnen hier dann ja eine Type 3 ANOVA. Die p-Werte sind aber alle so gering, dass es dann am Ende keinen so großen Unterschied mehr macht.\n\nDas R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(jump_length ~ feeding * time_fct + (feeding * time_fct|.id), \n      data = repeated_fac2_tbl)\n```\n:::\n\n\n\n\n\n## `{MANOVA.RM}`\n\nAm Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem zweifaktoriellen Fall die ähnlichen Werte wie in den anderen R Paketen erhalten. Hier fängt es dann etwas an zu variieren. Hier haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht. Ich habe dann einmal hier die Anzeige der Funktion ausgeschaltet, da hier der Output dann sehr lang wird. Du kannst dir beispielhaft die Ausgabe einmal bei der einfaktoriellen repeated ANOVA weiter oben einmal anschaue oder eben den Code selber einmal durchführen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRM(jump_length ~ feeding * time_fct, data = repeated_fac2_tbl, \n   subject = \".id\", within = c(\"feeding\", \"time_fct\"), iter = 100, \n   resampling = \"Perm\", seed = 1234) |> \n  summary()\n```\n:::\n\n\n\n\n:::\n\n### Dreifaktoriell\n\nAls letztes betrachten wir einen sehr exotischen Fall im Bereich der Agrarwissenschaften. Auch in anderen Forschungsbereichen ist die dreifaktorielle repeated ANOVA eher selten bis nicht vorhanden. Warum ist das so? Zum einen haben wir ja wieder unseren Faktor der Zeit. Wir messen hier viermal die Sprungweite eines Katzenflohs. Da wir aber dann noch zusätzlich zu dem Faktor der Zeit zwei weitere Behandlungen haben, kommen wir auf eine große Anzahl an Faktorkombinationen, die *jeder* Floh wiederholt durchlaufen muss. In unserem Fall haben wir ja die drei Fütterungsarten mit Zuckerwasser als Kontrolle, dem Blut sowie Ketchup als Ernährung. Dazu kommt dann noch ein Workout, dass jeder Floh gemacht hat oder nicht. Daher muss für jeden Floh jede Kombination der Fütterungsart und des Workouts wiederholt die Sprungweite gemessen werden. Das führt zu einem enormen Aufwand. Zum einen musst du ja immer Pausen zwischen den Behandlungen machen, damit sich die Effekte wieder auswaschen und es mit einem frischen Floh losgehen kann. Das ist eine zeitliche Belastung. Zum anderen ist es natürlich auch so, dass über die Zeit eventuell ein Floh nicht mehr kann oder gar verstirbt. Dann ist die ganze Messreihe für den Floh obsolet. Du siehst, diese Form des experimentellen Designs ist eher selten in Abschlussarbeiten und kommt eher in klinischen Studien oder längerfristigen agrarwissenschaftlichen Experimenten vor.\n\n::: panel-tabset\n## `{base}`\n\nDie Frage ist jetzt immer, wie schreibe ich jetzt das Modell richtig? Der komplizierte Teil ist eigentlich der Fehlerterm `Error()` aber auch der Teil davor. Ich nutze hier wieder die Kurzschreibweise mit dem Stern `*` um alle Faktorkombinationen plus Interaktion im Modell zu haben. Das wird eben dann ab schon zwei Faktoren etwas groß und mit drei Faktoren sehr unübersichtlich. So ist es dann weniger anfällig für Fehler. Dann musst du noch darauf achten, dass du in dem Fehlerterm die Klammern richtig setzt, sonst funktioniert es dort auch nicht. Erst kommt der Spaltenname für die einzelnen Flöhe `.id` und dahinter nach dem Slash `/` dann die Faktorkombinationen der Behandlungen und der Zeit. Dann räume ich die Ausgabe nochmal vollkommen auf, damit ich auch was sehe.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * workout * time_fct + \n      Error(.id/(feeding * workout * time_fct)), \n    data = repeated_fac3_tbl) |> \n  tidy() |> \n  na.omit() |> \n  select(term, df, statistic, p.value) |> \n  mutate(p.value = pvalue(p.value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  term                        df statistic p.value\n  <chr>                    <dbl>     <dbl> <chr>  \n1 feeding                      2   781.    <0.001 \n2 workout                      1  1000.    <0.001 \n3 time_fct                     3    84.2   <0.001 \n4 feeding:workout              2     2.87  0.078  \n5 feeding:time_fct             6    52.3   <0.001 \n6 workout:time_fct             3     0.472 0.704  \n7 feeding:workout:time_fct     6     0.873 0.520  \n```\n\n\n:::\n:::\n\n\n\n\n\nWir erhalten jetzt eine Menge an Ausgabe wieder. Insbesondere die vielen Interaktionen führen natürlich zu mehr Ausgabe. Aber auch hier sind erstmal die Haupteffekte der Art der Fütterung und des Workout am interessantesten. Wir sehen hier, dass beide Faktoren signifikant sind, der p-Wert liegt unter dem Signifikanzniveau von $\\alpha$ gleich 5%. Wir haben dann auch eine signifikante Zeitkomponente. Daher werden sich die Sprungweiten auch über die Zeit ändern. Am Ende ist dann nur die Interaktion zwischen der Fütterungsart und der Zeit signifikant. Anscheinend verhalten sich die Fütterungsarten nicht gleich über alle Zeitpunkte hinweg.\n\nDann können wir noch die Effektschätzer Eta$^2$ für alle Faktoren und deren Interaktionen berechnen. Ich habe dann auch hier aufgeräumt und die Eta$^2$-Werte einmal gerundet, damit du besser sehen kannst, welche der Werte überhaupt größer sind. Auch hier sehen wir dann, dass die Hauptfaktoren den größten Effekt haben, gefolgt von den Zeitpunkten und der Interaktion zwischen den Fütterungsarten und der Zeit.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(jump_length ~ feeding * workout * time_fct + \n      Error(.id/(feeding * workout * time_fct)), \n    data = repeated_fac3_tbl) |> \n  eta_squared(generalized = c(\"time_fct\")) |> \n  select(Parameter, Eta2_generalized) |> \n  mutate(Eta2_generalized = round(Eta2_generalized, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Effect Size for ANOVA\n\nParameter                | Eta2 (generalized)\n---------------------------------------------\nfeeding                  |               0.45\nworkout                  |               0.51\ntime_fct                 |               0.38\nfeeding:workout          |               0.01\nfeeding:time_fct         |               0.26\nworkout:time_fct         |               0.00\nfeeding:workout:time_fct |               0.00\n```\n\n\n:::\n:::\n\n\n\n\n\n## `{rstatix}`\n\nDas R Paket `{rstatix}` hat eine andere Schreibweise des Modells. Im Prinzip schreiben wir hier wieder nicht das Modell auf, sondern weisen die Spaltennamen dann den jeweiligen Optionen zu. Hier werden dann auch alle Interaktionen gerechnet, du kannst die Interaktionen aller Faktorkombinationen nicht abstellen. Wir setzten dann unseren Endpunkt `jump_length` in die Option `dv` und die einzelnen Beobachtungen in die Option `wid`. Dann müssen wir noch die beiden Faktoren der Zeit und der beiden Behandlungen in die Option `within` einfügen. Dann haben wir auch schon alles zusammen. Was hier etwas doof ist, ist das wir hier die Formelschreibweise in R verlassen, die wir dann aber überall sonst nutzen. Dafür erhalten wir dann aber das Eta$^2$ gleich als `ges` wieder aus der Funktion zurück.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstatix_aov <- anova_test(data = repeated_fac3_tbl, \n                          dv = jump_length, wid = .id, \n                          within = c(feeding, workout, time_fct))\nget_anova_table(rstatix_aov)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nANOVA Table (type III tests)\n\n                    Effect DFn DFd       F        p p<.05   ges\n1                  feeding   2  22 781.468 3.69e-21     * 0.700\n2                  workout   1  11 999.674 3.76e-12     * 0.749\n3                 time_fct   3  33  84.199 1.52e-15     * 0.518\n4          feeding:workout   2  22   2.874 7.80e-02       0.018\n5         feeding:time_fct   6  66  52.306 3.41e-23     * 0.428\n6         workout:time_fct   3  33   0.472 7.04e-01       0.003\n7 feeding:workout:time_fct   6  66   0.873 5.20e-01       0.013\n```\n\n\n:::\n:::\n\n\n\n\n\nWir erhalten die gleichen Ergebnisse wie schon bei der Funktion `aov()` wiedergegeben. Das überrascht auch nicht, den die Berechnung ist ja die gleiche Berechnung wie auch in `aov()` nur eben dann mit einem anderen Funktionsaufruf.\n\n## `{afex}`\n\nDas R Paket `{afex}` nutzt die Formelschreibweise und kann auch genau so bedient werden wie schon die Funktion `aov()`. Dafür können wir aber mit der Option `type` auch anderen Typen der ANOVA nutzen und nicht nur die Type I ANOVA in `aov()`. Das ist eigentlich die große Stärke von dem R Paket `{afex}`, dass wir hier flexibel bei der Auswahl der Typen sind. Bei der einfaktoriellen ANOVA war es noch egal, aber hier macht es mit zwei Faktoren dann schon einen Unterschied welche Art der ANOVA du rechnen möchtest. Ich nutze hier den Standard und damit die Type III ANOVA. Auch erhälst du bei der Funktion `aov_car()` einen Wert für Eta$^2$ in der Spalte `ges` wiedergegeben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(jump_length ~ feeding * workout * time_fct + \n          Error(.id/feeding * workout * time_fct), \n        data = repeated_fac3_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: jump_length\n                    Effect          df   MSE          F  ges p.value\n1                  feeding 1.65, 18.15 10.60 781.47 *** .700   <.001\n2                  workout       1, 11 17.54 999.67 *** .749   <.001\n3                 time_fct 2.68, 29.52 27.90  84.20 *** .518   <.001\n4          feeding:workout 1.71, 18.84 21.94     2.87 + .018    .088\n5         feeding:time_fct 3.96, 43.61 21.16  52.31 *** .428   <.001\n6         workout:time_fct 2.54, 27.91 15.60       0.47 .003    .674\n7 feeding:workout:time_fct 3.57, 39.22 24.44       0.87 .013    .479\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nDie Ergebnisse sind ähnlich wie schon bei den beiden anderen Algorithmen, aber hier macht es dann einen Unterschied welche ANOVA grechnet wird. Wir rechnen hier dann ja eine Type 3 ANOVA. Die p-Werte sind aber alle so gering, dass es dann am Ende keinen so großen Unterschied mehr macht.\n\nDas R Paket `{afex}` erlaubt es auch die Modelle nach der Schreibweise der linearen gemischten Modelle zu definieren. Das ist für mich eigentlich etwas angenehmer, da man sich dann in einer Formelwelt aufhält mehr dazu dann im [Kapitel zu gemischten Modellen](#sec-mixed). Also die Ergebnisse sind die Gleichen. Ich brauche es nur als Referenz für mich zum nachschlagen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(jump_length ~ feeding * workout * time_fct + \n        (feeding * workout * time_fct|.id), \n      data = repeated_fac3_tbl)\n```\n:::\n\n\n\n\n\n## `{MANOVA.RM}`\n\nAm Ende dann noch die Funktion `RM()` aus dem R Paket. Erstmal erhalten wir auch hier weder drei statistische Tests, obwohl wir nur nach einem gefragt haben. Ich würde auch hier nur die Ausgabe von `ANOVA-Type Statistic (ATS)` betrachten. Auch hier sehen wir, dass wir in einem dreifaktoriellen Fall die ähnlichen Werte wie in den anderen R Paketen erhalten. Je mehr Faktoren wir haben desto stärker werden dann auch die Unterschiede, da natürlich auch mehr Parameter geschätzt werden müssen. Hier haben wir dann aber noch mehr Informationen, die wir dann brauchen oder auch nicht. Ich habe dann einmal hier die Anzeige der Funktion ausgeschaltet, da hier der Output dann sehr lang wird. Du kannst dir beispielhaft die Ausgabe einmal bei der einfaktoriellen repeated ANOVA weiter oben einmal anschauen oder eben den Code selber einmal durchführen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRM(jump_length ~ feeding * workout * time_fct, data = repeated_fac3_tbl, \n   subject = \".id\", within = c(\"feeding\", \"workout\", \"time_fct\"), iter = 100, \n   resampling = \"Perm\", seed = 1234) |> \n  summary()\n```\n:::\n\n\n\n\n:::\n\nDamit haben wir es dann auch geschafft. Was ist noch kommt sind die Anwendungsbeispiele in der mixed ANOVA. Ich habe noch keine Daten für eine repeated ANOVA bei mir liegen, daher warte ich hier mal ab, was noch kommt. Die beiden Beispiele zeigen aber einmal schön wie du eine zweifaktorielle mixed ANOVA rechnen kannst sowie eine dreifaktorielle mixed ANOVA. In beiden Fällen habe ich dann noch den Posthoc-Test in `{emmeans}` ergänzt. Ich nutze hier einmal die Funktionen aus dem R Paket `{afex}` aber du kannst auch ein anderes Paket oder `aov()` nutzen.\n\n:::: callout-tip\n## Anwendungsbeispiel: Gurkenwachstum (2-faktorielle mixed ANOVA)\n\nIn diesem beispiel wollen wir uns einmal das Gurkenwachstum anschauen. Wir haben dazu drei Gurkensorten Proloog, Quarto und Katrina vorliegen. Wir lassen jeweils sechs Gurken pro Sorte über vierzehn Wochen wachsen. Wir messen dabei jede Woche einmal die Länge von Gurken sowie deren Durchmesser. Hier kommt natürlich die Frage auf, welche Gurken messen wir eigentlich und so eine Pflanze hat ja auch mehrere Gurken. Das lassen wir hier mal im Raum stehen, wir haben einfach eine Gurken, die immer länger werden. Wir laden erstmal die Daten ein und nehmen aber nur die Sorten `group` und die Messzeitpunkte mit in die Analyse.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngurke_tbl <- read_excel(\"data/wachstum_gurke.xlsx\") |> \n  clean_names() |> \n  select(group = versuchsgruppe, t1:t14) |>\n  mutate(group = as_factor(group)) \n```\n:::\n\n\n\n\n\nIn der folgenden Tabelle siehst du dann nochmal einen Ausschnitt aus den Daten. Wir werden jetzt gleich nur nach der Länge `L` filtern und auch die Daten aus dem Wide-Format in das Long-Format überführen.\n\n\n\n\n\n::: {#tbl-anwendung-gurke .cell tbl-cap='Datensatz zu dem Längen- und Dickenwachstum von Gurken. Hier sind nur die Messzeitpunkte `t1` bis `t4` dargestellt.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_000pm8d1licgbexfmn9c</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_000pm8d1licgbexfmn9c\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">group</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>Proloog L </td>\n                  <td>5.5  </td>\n                  <td>6.1  </td>\n                  <td>7.4  </td>\n                  <td>8.9  </td>\n                </tr>\n                <tr>\n                  <td>Proloog L </td>\n                  <td>4.6  </td>\n                  <td>5.1  </td>\n                  <td>6.4  </td>\n                  <td>5.7  </td>\n                </tr>\n                <tr>\n                  <td>Proloog L </td>\n                  <td>5.3  </td>\n                  <td>5.8  </td>\n                  <td>6.8  </td>\n                  <td>8.3  </td>\n                </tr>\n                <tr>\n                  <td>...       </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                  <td>...  </td>\n                </tr>\n                <tr>\n                  <td>Katrina D </td>\n                  <td>0.86 </td>\n                  <td>0.87 </td>\n                  <td>0.9  </td>\n                  <td>1.1  </td>\n                </tr>\n                <tr>\n                  <td>Katrina D </td>\n                  <td>0.62 </td>\n                  <td>0.67 </td>\n                  <td>0.7  </td>\n                  <td>0.71 </td>\n                </tr>\n                <tr>\n                  <td>Tageslänge</td>\n                  <td>13.98</td>\n                  <td>14.05</td>\n                  <td>14.12</td>\n                  <td>14.18</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_frn61k91f2rr4kc2az6a(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_000pm8d1licgbexfmn9c\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_000pm8d1licgbexfmn9c');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_frn61k91f2rr4kc2az6a(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_000pm8d1licgbexfmn9c\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\nDie Längen werden mit einem `L` hinter dem Sortennamen angezeigt und der Durchmesser mit einem `D` hinter der Sorte. Deshalb filtern wir hier gleich mal nur die Daten mit den Gurkenlängen raus. Dann bauen wir uns noch einen Faktor mit den entsprechenden Namen. Die Daten brauchen wir noch im Long-Format und dazu nutze ich dann die Funktion `pivot_longer()`. Am Ende möchte ich immer nochmal die Zeitpunkte als Faktor sowie numerisch. Manchmal ist das eine einfacher in `{ggplot}` abzubilden als das andere.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngurke_time_len_tbl <- gurke_tbl |> \n  filter(str_detect(group, \"L$\")) |> \n  rownames_to_column(\".id\") |> \n  mutate(group = factor(group, labels = c(\"Proloog\", \"Quarto\", \"Katrina\"))) |> \n  pivot_longer(cols = t1:t14,\n               values_to = \"length\",\n               names_to = \"time\") |> \n  mutate(time_fct = as_factor(time),\n         time_num = as.numeric(time_fct)) |> \n  filter(length != 0)\n```\n:::\n\n\n\n\n\nDann kommen wir auch schon zur visuellen Darstellung der Daten. Hier habe ich dann einmal über alle vierzehn Zeitpunkte die mittlere Länge sowie die mediane Länge dargestellt. Die einzelnen Punkte stellen die einzelnen Beobachtungen dar. Hier fällt auf, dass eventuell einzelne Gurken eine etwas seltsames Längenwachstum haben. Wir würden ja davon ausgehen, dass eine Gurke wächst über die Zeit und nicht schrumpft. Am Ende sehen wir noch, dass die letzten Wochen nicht mehr vollständig bemessen wurden. Hier mag es dann Sinn machen, die letzten Wochen bis Woche `t12` zu entfernen. Dann haben wir einen besseren Datensatz.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(gurke_time_len_tbl, \n       aes(time_fct, length, color = group, \n           group = group)) +\n  theme_minimal() +\n  geom_point2() +\n  stat_summary(fun = \"mean\", geom = \"line\") +\n  stat_summary(fun = \"median\", geom = \"line\", linetype = 2) +\n  scale_color_okabeito() +\n  theme(legend.position = \"top\")+\n  labs(x = \"Zeitpunkte der Messung\", y = \"Gurkenlänge [cm]\",\n       color = \"Sorte\")\n```\n\n::: {.cell-output-display}\n![Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar.](stat-tests-anova-mixed_files/figure-html/fig-anwendung-gurke-01-1.png){#fig-anwendung-gurke-01 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nUm die einzelnen Gurkenpflanzen besser zu verstehen, habe ich einmal die Pflanzen einzeln als Verlauf über die Zeit dargestellt. Hier sehen wir dann wirklich einige seltsame Pflanzen. Ich habe hier nochmal über die Funktion `geom_label_repel()` die IDs der einzelnen Pflanzen zu den Verläufen ergänzt. Ich habe mir dann noch die Mühe gemacht, die Werte dann auch immer an den letzten Zeitpunkt zu schreiben. Wir sehen sehr schön, dass mit der Pflanze 2 irgendwas nicht stimmt. Die Gurkenpflanze 2 wächst nämlich nicht sondern schrumpft über die Zeit.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmax_time_tbl <- gurke_time_len_tbl |> \n group_by(group, .id) |> \n  filter(time_num == max(time_num))\n\nggplot(gurke_time_len_tbl, \n       aes(time_fct, log(length), color = group, \n           group = .id)) +\n  theme_minimal() +\n  geom_point2() +\n  geom_line(linetype = 11) +\n  geom_label_repel(data = max_time_tbl, aes(time_fct, log(length), label = .id),              \n    box.padding = unit(0.35, \"lines\"), point.padding = unit(0.4, \"lines\"),\n    segment.color = 'grey50', show.legend = FALSE) +\n  scale_x_discrete(expand = expansion(mult = c(0, .1))) +\n  scale_color_okabeito() +\n  theme(legend.position = \"top\")+\n  labs(x = \"Zeitpunkte der Messung\", y = \"Gurkenlänge [cm] (log-scale)\",\n       color = \"Sorte\")\n```\n\n::: {.cell-output-display}\n![Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen für das individuelle Wachstum der einzelnen Gurken. Die Label am Ende des Wachstums stellen die Pflanzen IDs dar.](stat-tests-anova-mixed_files/figure-html/fig-anwendung-gurke-02-1.png){#fig-anwendung-gurke-02 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nDann können wir auch schon mit der Analyse der Daten mit einer mixed ANOVA beginnen. Je nachdem welche Schreibweise der Modelle in der ANOVA du bevorzugst, kannst du zwischen den beiden Funktionen `aov_car()` und `aov_4()` wählen. Ich habe hier für mich beide Formen einmal dargestellt. In beiden Fällen kommt das Gleiche raus, es geht eben nur um die Form der Darstellung der Modelle.\n\n::: panel-tabset\n## `aov_car()`\n\nIn dem Modell für R `{base}` nutzen wir die Schreibweise mit der Funktion `Error()` um den Fehlerterm und die Abhänigkeiten in dem Fehlerterm anzugeben. Hier haben wir die einzelnen Beobachtungen `.id` wiederholt in den Messzeitpunkten `time_fct` gemessen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(length ~ group * time_fct + Error(.id/time_fct), \n        data = gurke_time_len_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: length\n          Effect          df   MSE         F  ges p.value\n1          group       2, 13 74.07 25.08 *** .704   <.001\n2       time_fct 1.39, 18.11 33.11 92.69 *** .732   <.001\n3 group:time_fct 2.79, 18.11 33.11 15.46 *** .477   <.001\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nWas sehen wir? Alle Faktoren und die Interaktion sind signifikant, da der p-Wert kleiner ist als das Signifikanzniveau $\\alpha$ gleich 5%. Im Weiteren sehen wir auch, dass die Effekte in der Spalte `ges` als Eta$^2$ für die Versuchsgruppen sowie für die Zeit stark sind. Auch die Interaktion hat einen bedeutenden Effekt. Das wundert uns nicht, da wir ja Gurken haben, die über die Zeit weniger wachsen als alle anderen Gurken. Die Interaktion siehst du dann ganz gut an der Gurke Nr. 2 sowie an anderen Gurken gegen Ende der Untersuchung.\n\n## `aov_4`\n\nIn dem Modell für R nach dem R Paket `{lme4}` und anderen Paketen nutzen wir die Schreibweise mit den Klammern `()` und dem Strich `|` um den Fehlerterm und die Abhänigkeiten in dem Fehlerterm anzugeben. Hier haben wir die einzelnen Beobachtungen `.id` wiederholt in den Messzeitpunkten `time_fct` gemessen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(length ~ group * time_fct + (time_fct|.id), \n      data = gurke_time_len_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: length\n          Effect          df   MSE         F  ges p.value\n1          group       2, 13 74.07 25.08 *** .704   <.001\n2       time_fct 1.39, 18.11 33.11 92.69 *** .732   <.001\n3 group:time_fct 2.79, 18.11 33.11 15.46 *** .477   <.001\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nFür die Interpretation bitte den Tab zu der Funktion `aov_car()` beachten. Die Ausgaben sind die gleichen numerischen Werte und da beschreibe ich das für dich dann nur einmal.\n:::\n\nAm Ende wollen wir dann noch die paarweisen Vergleich in `{emmeans}` rechnen. Dazu können wir dann direkt das Modell aus `aov_car()` nutzen und uns alls paarweisen Vergleiche *getrennt* für die Zeitpunkte wiedergeben lassen. Ändere einfach den Stich `|` durch einen Stern `*`, wenn du über alle Zeitpunkte hinweg vergleichen willst.\n\nEs kommt jetzt ein riesiger Wust an Ausgabe. Am Ende können wir dann aber an jedem Zeitpunkt schauen, ob sich die drei Linien voneinander unterscheiden. Wir hätten hier natürlich nochmal die Daten aufreinigen müssen. Die Aufreinigung würde dann aber hier das Beispiel im Umfang sprengen. Auch habe ich hier auf eine Adjustierung der p-Werte verzichtet. Deshalb hier nur einmal die schnelle Analyse.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(length ~ group * time_fct + Error(.id/time_fct), \n        data = gurke_time_len_tbl) |> \n  emmeans(~ group | time_fct) |> \n  cld(Letters = letters, adjust = \"none\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime_fct = t1:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    2.25 0.142 13     1.94     2.56  a    \n Katrina   3.26 0.156 13     2.92     3.60   b   \n Proloog   5.08 0.156 13     4.74     5.42    c  \n\ntime_fct = t2:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    2.52 0.154 13     2.18     2.85  a    \n Katrina   3.50 0.168 13     3.14     3.86   b   \n Proloog   5.54 0.168 13     5.18     5.90    c  \n\ntime_fct = t3:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    2.77 0.195 13     2.34     3.19  a    \n Katrina   3.68 0.214 13     3.22     4.14   b   \n Proloog   6.56 0.214 13     6.10     7.02    c  \n\ntime_fct = t4:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    3.00 0.337 13     2.27     3.73  a    \n Katrina   3.98 0.369 13     3.18     4.78  a    \n Proloog   7.68 0.369 13     6.88     8.48   b   \n\ntime_fct = t5:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    3.23 0.452 13     2.26     4.21  a    \n Katrina   4.30 0.495 13     3.23     5.37  a    \n Proloog   8.20 0.495 13     7.13     9.27   b   \n\ntime_fct = t6:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    3.57 0.653 13     2.16     4.98  a    \n Katrina   5.14 0.716 13     3.59     6.69  a    \n Proloog   9.46 0.716 13     7.91    11.01   b   \n\ntime_fct = t7:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    3.95 0.864 13     2.08     5.82  a    \n Katrina   5.94 0.946 13     3.90     7.98  a    \n Proloog  11.42 0.946 13     9.38    13.46   b   \n\ntime_fct = t8:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    4.53 1.152 13     2.04     7.02  a    \n Katrina   6.90 1.262 13     4.17     9.63  a    \n Proloog  13.40 1.262 13    10.67    16.13   b   \n\ntime_fct = t9:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    4.78 1.319 13     1.93     7.63  a    \n Katrina   7.52 1.444 13     4.40    10.64  a    \n Proloog  15.62 1.444 13    12.50    18.74   b   \n\ntime_fct = t10:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    5.25 1.501 13     2.01     8.49  a    \n Katrina   8.40 1.644 13     4.85    11.95  a    \n Proloog  17.36 1.644 13    13.81    20.91   b   \n\ntime_fct = t11:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    5.72 1.686 13     2.08     9.36  a    \n Katrina   9.20 1.846 13     5.21    13.19  a    \n Proloog  19.52 1.846 13    15.53    23.51   b   \n\ntime_fct = t12:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    6.28 1.725 13     2.56    10.01  a    \n Katrina  10.02 1.890 13     5.94    14.10  a    \n Proloog  20.96 1.890 13    16.88    25.04   b   \n\ntime_fct = t13:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    8.23 1.934 13     4.06    12.41  a    \n Katrina  13.10 2.118 13     8.52    17.68  a    \n Proloog  28.52 2.118 13    23.94    33.10   b   \n\ntime_fct = t14:\n group   emmean    SE df lower.CL upper.CL .group\n Quarto    8.68 1.893 13     4.59    12.77  a    \n Katrina  13.58 2.074 13     9.10    18.06  a    \n Proloog  30.06 2.074 13    25.58    34.54   b   \n\nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n:::\n\n\n\n\n::::\n\n:::: callout-tip\n## Anwendungsbeispiel: Grünkohlhöhe (3-faktorielle mixed ANOVA)\n\nIm nächsten Beispiel schauen wir uns einmal die Höhe von Grünkohl an. Wir haben hier zwei Arten von Lichtgabe sowie zwei Sorten vorliegen. Dann messen wir die Höhe des Grünkohls noch an sieben Terminen. Daher haben wir hier wirklich mal eine dreifaktorielle ANOVA vorliegen. Da unsere beiden Behandlungsfaktoren nur zwei Level haben, können wir hier fast auf einen Post-hoc Test verzichten. Wir brauchen den Post-hoc Test aber dann für die Vergleiche in den jeweiligen Zeitpunkten. Wir laden also unseren Datensatz und nehmen nur die Wachstumsdaten mit den sieben Zeitpunkten.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkale_tbl <- read_excel(\"data/kale_time_height.xlsx\") |> \n  clean_names() |> \n  select(light, variety, t1:t7) |>\n  mutate(light = as_factor(light),\n         variety = as_factor(variety)) \n```\n:::\n\n\n\n\n\nDann hier einmal der Auszug aus den Daten zu dem Wachstum des Grünkohls. Ich habe hier nur die ersten vier Zeitpunkte ausgewählt.\n\n\n\n\n\n::: {#tbl-anwendung-kale .cell tbl-cap='Datensatz zu dem Höhenwachstum von Grünkohl. Hier sind nur die Messzeitpunkte `t1` bis `t4` dargestellt.'}\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_l3mvotg1b745pzb97z52</title>\n    <style>\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-striped\" id=\"tinytable_l3mvotg1b745pzb97z52\" style=\"table-layout: fixed; width: 100% !important; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">light</th>\n                <th scope=\"col\">variety</th>\n                <th scope=\"col\">t1</th>\n                <th scope=\"col\">t2</th>\n                <th scope=\"col\">t3</th>\n                <th scope=\"col\">t4</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>dark light  </td>\n                  <td>Nero di Toscana</td>\n                  <td>2.5</td>\n                  <td>3.5</td>\n                  <td>7   </td>\n                  <td>8.6</td>\n                </tr>\n                <tr>\n                  <td>dark light  </td>\n                  <td>Nero di Toscana</td>\n                  <td>3.3</td>\n                  <td>3.6</td>\n                  <td>5.5 </td>\n                  <td>10 </td>\n                </tr>\n                <tr>\n                  <td>dark light  </td>\n                  <td>Nero di Toscana</td>\n                  <td>4.5</td>\n                  <td>5.6</td>\n                  <td>5.75</td>\n                  <td>6  </td>\n                </tr>\n                <tr>\n                  <td>...         </td>\n                  <td>...            </td>\n                  <td>...</td>\n                  <td>...</td>\n                  <td>... </td>\n                  <td>...</td>\n                </tr>\n                <tr>\n                  <td>bright light</td>\n                  <td>Oldenbor       </td>\n                  <td>2.4</td>\n                  <td>4  </td>\n                  <td>6.25</td>\n                  <td>8.7</td>\n                </tr>\n                <tr>\n                  <td>bright light</td>\n                  <td>Oldenbor       </td>\n                  <td>2  </td>\n                  <td>3.8</td>\n                  <td>6   </td>\n                  <td>8.3</td>\n                </tr>\n                <tr>\n                  <td>bright light</td>\n                  <td>Oldenbor       </td>\n                  <td>3.8</td>\n                  <td>4.2</td>\n                  <td>7   </td>\n                  <td>8.5</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_0ne5kufmxpyop0kllwit(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_l3mvotg1b745pzb97z52\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_l3mvotg1b745pzb97z52');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_0ne5kufmxpyop0kllwit(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_l3mvotg1b745pzb97z52\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nkale_time_height_tbl <- kale_tbl |> \n  rownames_to_column(\".id\") |> \n  pivot_longer(cols = t1:t7,\n               values_to = \"height\",\n               names_to = \"time\") |> \n  mutate(time_fct = as_factor(time),\n         time_num = as.numeric(time_fct)) \n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(kale_time_height_tbl, \n       aes(time_fct, height, color = light, linetype = variety,\n           group = .id)) +\n  theme_minimal() +\n  geom_line() +\n  scale_color_okabeito() +\n  theme(legend.position = \"top\")+\n  labs(x = \"Zeitpunkte der Messung\", y = \"Gurkenlänge [cm] (log-scale)\",\n       color = \"Licht\", linetype = \"Sorte\")\n```\n\n::: {.cell-output-display}\n![Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar.](stat-tests-anova-mixed_files/figure-html/fig-anwendung-kale-02-1.png){#fig-anwendung-kale-02 fig-align='center' width=768}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(kale_time_height_tbl, \n       aes(time_fct, height, color = light, linetype = variety,\n           shape = variety,\n           group = interaction(light, variety))) +\n  theme_minimal() +\n  geom_point() +\n  stat_summary(fun = \"mean\", geom = \"line\") +\n  scale_color_okabeito() +\n  theme(legend.position = \"top\")+\n  labs(x = \"Zeitpunkte der Messung\", y = \"Gurkenlänge [cm]\",\n       color = \"Licht\", shape = \"Sorte\", linetype = \"Sorte\") \n```\n\n::: {.cell-output-display}\n![Scatterplot des Längenwachstums der drei Gurkensorten über vierzehn Wochen. Die gestrichtelten Linien stellen den Median und die durchgezogene Line den Mittelwert der Gruppen dar.](stat-tests-anova-mixed_files/figure-html/fig-anwendung-kale-01-1.png){#fig-anwendung-kale-01 fig-align='center' width=768}\n:::\n:::\n\n\n\n\n\nDann können wir auch schon mit der Analyse der Daten mit einer mixed ANOVA beginnen. Je nachdem welche Schreibweise der Modelle in der ANOVA du bevorzugst, kannst du zwischen den beiden Funktionen `aov_car()` und `aov_4()` wählen. Ich habe hier für mich beide Formen einmal dargestellt. In beiden Fällen kommt das Gleiche raus, es geht eben nur um die Form der Darstellung der Modelle.\n\n::: panel-tabset\n## `aov_car()`\n\nIn dem Modell für R `{base}` nutzen wir die Schreibweise mit der Funktion `Error()` um den Fehlerterm und die Abhänigkeiten in dem Fehlerterm anzugeben. Hier haben wir die einzelnen Beobachtungen `.id` wiederholt in den Messzeitpunkten `time_fct` gemessen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(height ~ light * variety * time_fct + Error(.id/time_fct), \n        data = kale_time_height_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: height\n                  Effect          df   MSE          F  ges p.value\n1                  light       1, 12 26.75  20.69 *** .430   <.001\n2                variety       1, 12 26.75     5.55 * .168    .036\n3          light:variety       1, 12 26.75       0.04 .001    .855\n4               time_fct 1.58, 18.96 21.84 217.64 *** .911   <.001\n5         light:time_fct 1.58, 18.96 21.84   11.12 ** .343    .001\n6       variety:time_fct 1.58, 18.96 21.84       1.21 .054    .310\n7 light:variety:time_fct 1.58, 18.96 21.84       0.20 .009    .768\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\n## `aov_4`\n\nIn dem Modell für R nach dem R Paket `{lme4}` und anderen Paketen nutzen wir die Schreibweise mit den Klammern `()` und dem Strich `|` um den Fehlerterm und die Abhänigkeiten in dem Fehlerterm anzugeben. Hier haben wir die einzelnen Beobachtungen `.id` wiederholt in den Messzeitpunkten `time_fct` gemessen.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_4(height ~ light * variety * time_fct + (time_fct|.id), \n      data = kale_time_height_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type 3 tests)\n\nResponse: height\n                  Effect          df   MSE          F  ges p.value\n1                  light       1, 12 26.75  20.69 *** .430   <.001\n2                variety       1, 12 26.75     5.55 * .168    .036\n3          light:variety       1, 12 26.75       0.04 .001    .855\n4               time_fct 1.58, 18.96 21.84 217.64 *** .911   <.001\n5         light:time_fct 1.58, 18.96 21.84   11.12 ** .343    .001\n6       variety:time_fct 1.58, 18.96 21.84       1.21 .054    .310\n7 light:variety:time_fct 1.58, 18.96 21.84       0.20 .009    .768\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n\nSphericity correction method: GG \n```\n\n\n:::\n:::\n\n\n\n\n\nFür die Interpretation bitte den Tab zu der Funktion `aov_car()` beachten. Die Ausgaben sind die gleichen numerischen Werte und da beschreibe ich das für dich dann nur einmal.\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\neta_2_vec <- map_dbl(0:5, \\(i) {\n  aov_car(height ~ light * variety * time_fct + Error(.id/time_fct), \n        data = filter(kale_time_height_tbl, time_num > i)) |> \n    eta_squared(generalized = \"time_fct\") |> \n    pull(Eta2_generalized) |> \n    extract(5)\n})\n\ntibble(time = as_factor(c(\"alle\", \">t1\", \">t2\", \">t3\", \">t4\", \">t5\")),\n       eta2 = eta_2_vec) |> \n  ggplot(aes(time, eta2, group = 1)) +\n  theme_minimal() +\n  geom_line() +\n  scale_y_continuous(limits = c(0, 0.05)) +\n  labs(x = \"Betrachtete Zeitpunkt\", y = expression(\"Eta\"^2))\n```\n\n::: {.cell-output-display}\n![Der Effektschätzer Eta$^2$ der Interaktion zeischen den Zeitpunkten und der Lichtstärke in Abhängigkeit der betrachteten Zeitpunkte. Insbesondere die frühen Zeitpunkte führen zu einem hohen Eta$^2$-Wert der Interaktion. Ohne die frühen Zeitpunkte fällt der Eta$^2$-Wert ab.](stat-tests-anova-mixed_files/figure-html/fig-anwendung-kale-03-1.png){#fig-anwendung-kale-03 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nIn unserem Fall ist der Posthoc-Test ja eigentlich mit nur zwei Lichtstärken und zwei Sorten nicht unbedingt nötig. Wenn du aber natürlich die Unterschiede für die einzelnen Zeitpunkte brauchst, dann kann dir hier `{emmeans}` helfen. Wir gehen hier von Vamrianzhomogenität in den Zeitpunkten aus. Dafür modellieren wir dann über alle Zeitpunkte hinweg die Varianz. Irgendwas ist ja immer. Hier kann man sicherlich noch weiter optimieren und mal bei den [gemischten Modellen](#sec-mixed) vorbeischauen, aber für die Anwendung reicht diese Auswertung auf jeden Fall aus.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov_car(height ~ light * variety * time_fct + Error(.id/time_fct), \n        data = kale_time_height_tbl) |> \n  emmeans(~ light * variety | time_fct, adjust = \"none\") |> \n  cld(Letters = letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime_fct = t1:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor          1.93 0.441 12    0.963     2.89  a    \n bright light Oldenbor          2.67 0.441 12    1.713     3.64  a    \n dark light   Nero di Toscana   3.45 0.441 12    2.488     4.41  a    \n bright light Nero di Toscana   3.77 0.441 12    2.813     4.74  a    \n\ntime_fct = t2:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor          3.02 0.347 12    2.268     3.78  a    \n dark light   Nero di Toscana   3.92 0.347 12    3.168     4.68  ab   \n bright light Oldenbor          4.03 0.347 12    3.268     4.78  ab   \n bright light Nero di Toscana   4.85 0.347 12    4.093     5.61   b   \n\ntime_fct = t3:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor          4.67 0.425 12    3.750     5.60  a    \n dark light   Nero di Toscana   5.75 0.425 12    4.825     6.68  ab   \n bright light Oldenbor          6.39 0.425 12    5.462     7.31  ab   \n bright light Nero di Toscana   6.83 0.425 12    5.900     7.75   b   \n\ntime_fct = t4:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor          6.03 0.728 12    4.440     7.61  a    \n dark light   Nero di Toscana   7.83 0.728 12    6.240     9.41  a    \n bright light Oldenbor          8.25 0.728 12    6.665     9.84  a    \n bright light Nero di Toscana  11.65 0.728 12   10.065    13.24   b   \n\ntime_fct = t5:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor          9.50 1.932 12    5.291    13.71  a    \n dark light   Nero di Toscana  11.94 1.932 12    7.729    16.15  ab   \n bright light Oldenbor         14.50 1.932 12   10.291    18.71  ab   \n bright light Nero di Toscana  18.69 1.932 12   14.479    22.90   b   \n\ntime_fct = t6:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor         13.88 2.160 12    9.168    18.58  a    \n dark light   Nero di Toscana  17.38 2.160 12   12.668    22.08  a    \n bright light Oldenbor         22.40 2.160 12   17.693    27.11  ab   \n bright light Nero di Toscana  26.98 2.160 12   22.268    31.68   b   \n\ntime_fct = t7:\n light        variety         emmean    SE df lower.CL upper.CL .group\n dark light   Oldenbor         19.38 2.426 12   14.088    24.66  a    \n dark light   Nero di Toscana  22.98 2.426 12   17.688    28.26  ab   \n bright light Oldenbor         30.00 2.426 12   24.713    35.29   b   \n bright light Nero di Toscana  32.88 2.426 12   27.588    38.16   b   \n\nConfidence level used: 0.95 \nP value adjustment: tukey method for comparing a family of 4 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n:::\n\n\n\n\n::::\n\n## Referenzen {.unnumbered}\n",
    "supporting": [
      "stat-tests-anova-mixed_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}