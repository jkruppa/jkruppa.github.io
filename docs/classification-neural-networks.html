<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ein Kochbuch mit Rezepten aus der Bio Data Science, Biostatistik, Biometrie und Statistik zum selber nachkochen!">

<title>76&nbsp; Neural networks – Bio Data Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./abspann.html" rel="next">
<link href="./classification-svm.html" rel="prev">
<link href="./cover2024_favi.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-05fe91a66cf75bbbb8c9664867fe5124.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-05a8b96638736df272eeeeef67138371.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="76&nbsp; Neural networks – Bio Data Science">
<meta property="og:description" content="Ein Kochbuch mit Rezepten der Bio Data Science, Biostatistik, Biometrie und Statistik">
<meta property="og:image" content="https://github.com/jkruppa/jkruppa.github.io/raw/master/cover2024.png">
<meta property="og:site_name" content="Bio Data Science">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./classification-preface.html">Klassifikation oder maschinelles Lernen</a></li><li class="breadcrumb-item"><a href="./classification-neural-networks.html"><span class="chapter-number">76</span>&nbsp; <span class="chapter-title">Neural networks</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Bio Data Science</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/jkruppa/jkruppa.github.io/" title="Quellcode" class="quarto-navigation-tool px-1" aria-label="Quellcode"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Willkommen</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./organisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Organisation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./literature.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Bibliothek</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./forschungsprozess.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Forschungsprozess</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./abschlussarbeit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Abschlussarbeit</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./example-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Datenbeispiele</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example-fleas-dogs-cats.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Von Flöhen auf Tieren</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example-gummi-bears.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Von Gummibärchen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example-complex.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Von komplexeren Daten</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example-database.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Von Datenbanken</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./programing-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programmieren in R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-letters-numbers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Daten in R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Operatoren, Funktionen und Pakete</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-import.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Daten einlesen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-dplyr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Daten bearbeiten</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-strings.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Reguläre Ausdrücke</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-purrr-furrr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Ein <code>purrr</code> Cookbook</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programing-quarto-shiny.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Quarto und Shiny App</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./eda-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Explorative Datenanalyse</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda-descriptive.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Deskriptive Statistik</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda-ggplot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Visualisierung von Daten</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda-distribution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Verteilung von Daten</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda-transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Transformieren von Daten</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./stat-tests-preface-theory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Testen von Hypothesen</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Die Testentscheidung</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-theorie.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Die Testtheorie</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-effect.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Der Effektschätzer</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-pretest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Der Pre-Test oder Vortest</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./experimental-design-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Experimentelle Designs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./experimental-design-r.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Versuchsplanung in R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./experimental-design-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Einfache Designs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./experimental-design-advanced.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Fortgeschrittene Designs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./experimental-design-samplesize.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Fallzahlplanung</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./stat-tests-preface-app.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statistische Gruppenvergleiche</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-R.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Testen in R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-ttest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Der t-Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Die ANOVA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-ancova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Die ANCOVA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-utest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Der Wilcoxon-Mann-Whitney-Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-kruskal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Der Kruskal-Wallis-Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-friedman.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Der Friedman Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-chi-test.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Der <span class="math inline">\(\mathcal{X}^2\)</span>-Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-anteil-test.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Der Anteilstest</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-diagnostic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Der diagnostische Test</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-trendtest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Der Trendtest</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-permutationstest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Der Permutationstest</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-posthoc2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">Der Post-hoc Test</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./stat-linear-reg-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Grundlagen des Modellierens</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-linear-reg-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Simple lineare Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">42</span>&nbsp; <span class="chapter-title">Multiple lineare Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-linear-reg-quality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">43</span>&nbsp; <span class="chapter-title">Modelgüte</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-linear-reg-corr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">44</span>&nbsp; <span class="chapter-title">Korrelation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-outlier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">45</span>&nbsp; <span class="chapter-title">Ausreißer</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-variable-selection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">46</span>&nbsp; <span class="chapter-title">Variablenselektion</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-missing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">47</span>&nbsp; <span class="chapter-title">Fehlende Werte</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-sensitivity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">48</span>&nbsp; <span class="chapter-title">Sensitivitätsanalyse</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./stat-modeling-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statistisches Modellieren</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-R.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">49</span>&nbsp; <span class="chapter-title">Modellieren in R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-gaussian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">50</span>&nbsp; <span class="chapter-title">Gaussian Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-poisson.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">51</span>&nbsp; <span class="chapter-title">Poisson Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-beta.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">52</span>&nbsp; <span class="chapter-title">Beta Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-multinom.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">53</span>&nbsp; <span class="chapter-title">Multinomiale / Ordinale Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-logistic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">54</span>&nbsp; <span class="chapter-title">Logistische Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-prob-model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">55</span>&nbsp; <span class="chapter-title">Linear Probability Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-mixed.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">56</span>&nbsp; <span class="chapter-title">Lineare gemischte Modelle</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-gee.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">57</span>&nbsp; <span class="chapter-title">Generalized Estimating Equations (GEE)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-non-linear.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">58</span>&nbsp; <span class="chapter-title">Nicht lineare Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-robust-quantile.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">59</span>&nbsp; <span class="chapter-title">Robuste und Quantilesregression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-survival.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">60</span>&nbsp; <span class="chapter-title">Überlebenszeitanalysen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-noninferiority.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">61</span>&nbsp; <span class="chapter-title">Äquivalenz oder Nichtunterlegenheit</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-meta.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">62</span>&nbsp; <span class="chapter-title">Metaanalysen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-cluster.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">63</span>&nbsp; <span class="chapter-title">Clusteranalysen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-pca.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">64</span>&nbsp; <span class="chapter-title">Multivariate Verfahren</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-modeling-survey.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">65</span>&nbsp; <span class="chapter-title">Fragebogenanalyse</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./time-space-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Zeitliche und räumliche Analysen</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./time-space-pseudo-time-series.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">66</span>&nbsp; <span class="chapter-title">Pseudo Zeitreihen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./time-space-time-series.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">67</span>&nbsp; <span class="chapter-title">Zeitreihen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./time-space-spatial-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">68</span>&nbsp; <span class="chapter-title">Räumliche Daten</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./classification-preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Klassifikation oder maschinelles Lernen</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">69</span>&nbsp; <span class="chapter-title">Grundlagen der Klassifikation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">70</span>&nbsp; <span class="chapter-title">Data splitting</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-pre-processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">71</span>&nbsp; <span class="chapter-title">Data preprocessing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-model-compare.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">72</span>&nbsp; <span class="chapter-title">Vergleich von Algorithmen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-knn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">73</span>&nbsp; <span class="chapter-title"><span class="math inline">\(k\)</span> nearest neighbor</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-randomforest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">74</span>&nbsp; <span class="chapter-title">Decision trees</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-svm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">75</span>&nbsp; <span class="chapter-title">Support vector machines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./classification-neural-networks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">76</span>&nbsp; <span class="chapter-title">Neural networks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./abspann.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Abspann</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-spielecke.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">77</span>&nbsp; <span class="chapter-title">Spielecke</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stat-tests-anova2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">78</span>&nbsp; <span class="chapter-title">Die ANOVA</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#genutzte-r-pakete" id="toc-genutzte-r-pakete" class="nav-link active" data-scroll-target="#genutzte-r-pakete"><span class="header-section-number">76.1</span> Genutzte R Pakete</a></li>
  <li><a href="#neuronale-netzwerke-theoretisch" id="toc-neuronale-netzwerke-theoretisch" class="nav-link" data-scroll-target="#neuronale-netzwerke-theoretisch"><span class="header-section-number">76.2</span> Neuronale Netzwerke theoretisch</a></li>
  <li><a href="#neuronales-netz-anschaulicher" id="toc-neuronales-netz-anschaulicher" class="nav-link" data-scroll-target="#neuronales-netz-anschaulicher"><span class="header-section-number">76.3</span> Neuronales Netz anschaulicher</a></li>
  <li><a href="#neuronales-netz-mathematischer" id="toc-neuronales-netz-mathematischer" class="nav-link" data-scroll-target="#neuronales-netz-mathematischer"><span class="header-section-number">76.4</span> Neuronales Netz mathematischer</a></li>
  <li><a href="#daten" id="toc-daten" class="nav-link" data-scroll-target="#daten"><span class="header-section-number">76.5</span> Daten</a></li>
  <li><a href="#neuronale-netze-mit-neuralnet" id="toc-neuronale-netze-mit-neuralnet" class="nav-link" data-scroll-target="#neuronale-netze-mit-neuralnet"><span class="header-section-number">76.6</span> Neuronale Netze mit <code>neuralnet</code></a></li>
  <li><a href="#neuronale-netze-mit-nnet" id="toc-neuronale-netze-mit-nnet" class="nav-link" data-scroll-target="#neuronale-netze-mit-nnet"><span class="header-section-number">76.7</span> Neuronale Netze mit <code>nnet</code></a></li>
  <li><a href="#neuronale-netze-mit-keras-tensorflow" id="toc-neuronale-netze-mit-keras-tensorflow" class="nav-link" data-scroll-target="#neuronale-netze-mit-keras-tensorflow"><span class="header-section-number">76.8</span> Neuronale Netze mit Keras / Tensorflow</a></li>
  <li><a href="#tuning" id="toc-tuning" class="nav-link" data-scroll-target="#tuning"><span class="header-section-number">76.9</span> Tuning</a></li>
  <li><a href="#referenzen" id="toc-referenzen" class="nav-link" data-scroll-target="#referenzen">Referenzen</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/jkruppa/jkruppa.github.io/edit/master/classification-neural-networks.qmd" class="toc-action"><i class="bi bi-github"></i>Seite editieren</a></li><li><a href="https://github.com/jkruppa/jkruppa.github.io/issues/new" class="toc-action"><i class="bi empty"></i>Problem melden</a></li><li><a href="https://github.com/jkruppa/jkruppa.github.io/blob/master/classification-neural-networks.qmd" class="toc-action"><i class="bi empty"></i>Quellcode anzeigen</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./classification-preface.html">Klassifikation oder maschinelles Lernen</a></li><li class="breadcrumb-item"><a href="./classification-neural-networks.html"><span class="chapter-number">76</span>&nbsp; <span class="chapter-title">Neural networks</span></a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-neural" class="quarto-section-identifier"><span class="chapter-number">76</span>&nbsp; <span class="chapter-title">Neural networks</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Gesamten Code zeigen</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Gesamten Code verbergen</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">Quellcode anzeigen</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Letzte Änderung am 20. May 2024 um 07:56:30</em></p>
<p>So, das war ein ganz schönes Brett, TensorFlow bzw. Keras auf dem Rechner zu installieren. Es gibt zwar einen <a href="https://tensorflow.rstudio.com/install/">Quick start um Tensorflow zu installieren</a> aber dann hatte ich das schöne Problem der GPU auf dem macOS mit M1 Chip. Die Lösung für die <a href="https://tensorflow.rstudio.com/install/local_gpu">Local GPU</a> hat mich auf dem macOS einen Tag Nerven gekostet. Das mag dann auf einem Windows Rechner anders sein bzw. andere Probleme verursachen. Schlussendlich ist die Nutzung von <em>neural networks</em> auf keinen Laptops vielleicht auch nicht so die beste Idee. Wir würden die Algorithmen eher auf Hochleistungsrechner durchführen und dann vermutlich eine Linuxdistribution verwenden. Dennoch werde ich hier einmal Tensorflow in R vorstellen. Die Pakete für die Integration von dem eigenständigen Algorithmus Tensorflow gibt es und wenn es dann mal installiert ist, funktioniert auch alles super. Da Tensorflow in Phyton programmiert ist, muss auch Phyton auf dem Rechner installiert sein. Du siehst also, es ist einiges einzurichten, damit wir Deep learning betreiben können. Hier möchte ich dann auch gerne auf <span class="citation" data-cites="mueller2019deep">Mueller und Massaron (<a href="#ref-mueller2019deep" role="doc-biblioref">2019</a>)</span> verweisen, der zu dem Thema Deep learning einen guten Einstieg liefert. Denn wir machen hier eigentlich kein Deep learning, denn unsere neuronalen Netzwerke werden nicht viele Schichten haben, dass würde hier mein kleiner Rechner auch gar nicht schaffen.</p>
<p>Neben TensorFlow / Keras zeige ich auch nochmal die Anwendung der etwas veralteten R Pakete <code>{neuralnet}</code> und <code>{nnet}</code>. Wie immer musst du selber entscheiden, was du brauchst. Der Vorteil des Paketes <code>{nnet}</code> ist, dass wir das Paket zum einen mit Rezepten und Tuning gut nutzen können. Zum anderen brauchen wir aber nicht diesen Installationsmarathon wie bei TensorFlow / Keras. Ich präsnetiere hier einfach die Auswahl und du schaust dann was passt.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Wir immer basiert dieser Text zum Teilen auch auf guten Tutorien im Netz. Zum einen ist es das Tutorium <a href="https://blog.ephorie.de/understanding-the-magic-of-neural-networks">Understanding the Magic of Neural Networks</a> und das Tutorium <a href="https://wiki.pathmind.com/neural-network">A Beginner’s Guide to Neural Networks and Deep Learning</a>. Beide Tutorien sind in Englisch und Teile beider Tutorien hat auch diesen Text hier inspiriert. Nicht zu vergessen das Tutorium <a href="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">A Quick Introduction to Neural Networks</a>.</p>
</div></div><section id="genutzte-r-pakete" class="level2" data-number="76.1">
<h2 data-number="76.1" class="anchored" data-anchor-id="genutzte-r-pakete"><span class="header-section-number">76.1</span> Genutzte R Pakete</h2>
<p>Wir wollen folgende R Pakete in diesem Kapitel nutzen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(tidyverse, tidymodels, magrittr, </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>               janitor, keras, tensorflow, see,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>               neuralnet, NeuralNetTools,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>               OneR, readxl, </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>               conflicted)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2025429</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>An der Seite des Kapitels findest du den Link <em>Quellcode anzeigen</em>, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.</p>
</section>
<section id="neuronale-netzwerke-theoretisch" class="level2 page-columns page-full" data-number="76.2">
<h2 data-number="76.2" class="anchored" data-anchor-id="neuronale-netzwerke-theoretisch"><span class="header-section-number">76.2</span> Neuronale Netzwerke theoretisch</h2>
<p>Neuronale Netze ordnen <em>Inputs</em> den <em>Outputs</em> zu. Wir haben also Eingaben und erhalten eine Ausgabe zurück. Neuronale Netze finden Korrelationen. Neuronale Netzwerke sin auch als “universeller Approximator” bekannt, weil dad Netzwerk lernen kann, eine unbekannte Funktion <span class="math inline">\(f(x) = y\)</span> zwischen einer beliebigen Eingabe <span class="math inline">\(x\)</span> und einer beliebigen Ausgabe <span class="math inline">\(y\)</span> zu approximieren. Dabei gilt die Vorraussetzung, dass <span class="math inline">\(x\)</span> und <span class="math inline">\(y\)</span> in einem Zusammenhang durch Korrelation oder Kausalität stehen. Während des Lernprozesses findet ein neuronales Netz das richtige <span class="math inline">\(f()\)</span> oder die richtige Art der Umwandlung von <span class="math inline">\(x\)</span> in <span class="math inline">\(y\)</span>, sei es <span class="math inline">\(f(x) = 3x + 12\)</span> oder <span class="math inline">\(g(f(x)) = 9x - 0.1\)</span>. Wie du sehen kannst, gibt es auch bei dem neuralen Netzwerk eigentlich um ein Modell. Und unser Modell ist nicht anders, als eine multiple lineare Regresion in der klassischen Statistik.</p>
<p>Deep Learning ist der Name, den wir für <em>gestapelte neuronale Netze</em> verwenden und damit meinen wir Netze, die aus mehreren Schichten bestehen. Die einzelnen Schichten bestehen aus Knotenpunkten. Ein Knoten ist einfach ein Ort, an dem Berechnungen stattfinden, frei nach dem Vorbild eines Neurons im menschlichen Gehirn, das feuert, wenn es auf ausreichende Reize trifft. Ein Knoten kombiniert Eingaben aus den Daten mit einer Reihe von Koeffizienten oder Gewichten, die diese Eingaben entweder verstärken oder abschwächen. Somit geben dann die Knoten den Eingaben eine Bedeutung im Hinblick auf die Aufgabe die der Algorithmus zu lernen versucht. Häufig ist dies die Aufgabe die Eingabe zu finden die am hilfreichsten die Daten fehlerfrei klassifiziert? Diese Eingangsgewichtungen werden summiert, und die Summe wird dann durch die so genannte Aktivierungsfunktion eines Knotens geleitet, um zu bestimmen, ob und in welchem Ausmaß dieses Signal weiter durch das Netzwerk geleitet werden soll. Am Ende kann nur ein weitergeleitetes Signal das Endergebnis als einen Klassifizierungsvorgang beeinflussen. Wenn das Signal durch das Neuron durchläuft, ist dieses Neuron “aktiviert” worden.</p>
<p>In <a href="#fig-class-nnet-01" class="quarto-xref">Abbildung&nbsp;<span>76.5</span></a> ist ein Diagramm dargestellt, dass einen Knoten darstellt. Wir haben immer ein Inputlayer in dem wir hier drei Inputneuronen <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span> und <span class="math inline">\(x_3\)</span> finden. Das sind auch unsere Variablen in den Daten, die wir in das Modell stecken. Ganz oben finden wir noch als blaues Neuron ein Biasneuron dargestellt. Du kannst dir das Biasneuron wie den Intercept in der linearen Regresion vorstellen. Jedes der Neuronen hat ein Gewicht <span class="math inline">\(w_0\)</span> bis <span class="math inline">\(w_3\)</span>. Diese Gewichte werden durch eine Netzinputfunktion in der Form <span class="math inline">\(w_0 + w_1 x_1 + w_2x_3\)</span> aufsummiert und dann an eine Aktivierungsfunktion weitergeleitet. Die Aktivierungsfunktion entscheidet hierbei, ob das Neuron aktiv wird und damit dann auch die Gewichte weiterleitet oder eben inaktiv wird. Es gibt viele Aktivierungsfunktionen, die alle unterschiedliche Eigenschaften haben. Im Folgenden sind einmal die wichtigisten Aktivierungsfunktionen beschrieben.</p>
<ul>
<li>Die lineare Aktivierungsfunktion skaliert eine Eingabe einfach um einen Faktor, was bedeutet, dass es eine lineare Beziehung zwischen den Eingaben und der Ausgabe gibt.</li>
<li>Sigmoid-Aktivierungsfunktion ist “S”-förmig. Sie kann der Ausgabe Nichtlinearität hinzufügen und gibt einen binären Wert von 0 oder 1 zurück.</li>
<li>Die Tanh-Aktivierungsfunktion ist eine Erweiterung der sigmoidalen Aktivierungsfunktion. Daher kann Tanh verwendet werden, um der Ausgabe Nichtlinearität hinzuzufügen. Die Ausgabe liegt im Bereich von -1 bis 1. Die Tanh-Funktion verschiebt das Ergebnis der sigmoiden Aktivierungsfunktion.</li>
<li>Die Rektifizierte lineare Einheits-Aktivierungsfunktion (RELU) ist eine der am häufigsten verwendeten Aktivierungsfunktionen. RELU wird bevorzugt in den Hidden Layer verwendet. Das Konzept ist linear vom Nullpunkt ausgehend. Die RELU fügt der Ausgabe auch Nichtlinearität hinzu. Allerdings kann das Ergebnis von 0 bis unendlich reichen.</li>
<li>Die Softmax-Aktivierungsfunktion ist eine Erweiterung der Sigmoid-Aktivierungsfunktion. Die Softmax-Funktion fügt der Ausgabe eine Nichtlinearität hinzu. Sie wird jedoch hauptsächlich für Klassifizierungen verwendet, bei denen mehrere Klassen von Ergebnissen berechnet werden können. Wir haben dann einen Multiclass-Fall vorliegen.</li>
</ul>
<p>Im Prinzip ist eine Aktivierungsfunktion nichts anderes als die Link Funktion in der multiplen linearen Regression. <a href="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">Aber das geht dann hier zu weit.</a> Häufig wird dann die Netzinputfunktion und die Aktivierungsfunktion in einem Knotenpunkt dargestellt.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Mehr über Aktivierungsfunktionen kannst du im Tutorium <a href="https://medium.com/analytics-vidhya/neural-networks-in-a-nutshell-bb013f40197d">Neural Networks In a Nutshell</a> erfahren.</p>
</div></div><div id="fig-class-nnet-01" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-nnet-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/class-neuralnet-01.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Abbildung&nbsp;76.1— Darstellung von drei Inputneuronen x_1, x_2, x_3, einem Biasneuron 1 mit den jeweiligen weitergeleiteten Gewichten w_1, w_2, w_3 und w_0. Die Summierungsfunktion sowie die Aktivierungsfunktion werden meist in einen gemeinsamen Knoten dargestellt. Hier sind beide Formen einmal abgebildet. Wenn das Neuron aktiviert ist, gibt es die Summe als Output weiter."><img src="images/class-neuralnet-01.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-nnet-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.1— Darstellung von drei Inputneuronen <span class="math inline">\(x_1, x_2, x_3\)</span>, einem Biasneuron <span class="math inline">\(1\)</span> mit den jeweiligen weitergeleiteten Gewichten <span class="math inline">\(w_1, w_2, w_3\)</span> und <span class="math inline">\(w_0\)</span>. Die Summierungsfunktion sowie die Aktivierungsfunktion werden meist in einen gemeinsamen Knoten dargestellt. Hier sind beide Formen einmal abgebildet. Wenn das Neuron aktiviert ist, gibt es die Summe als Output weiter.
</figcaption>
</figure>
</div>
<p>In der <a href="#fig-class-nnet-02" class="quarto-xref">Abbildung&nbsp;<span>76.2</span></a> sehen wir dann ein ganze Netz an Neuronen. Wir haben ein Inputlayer und mehrere Hiddenlayer die am Ende dann in ein Outputlayer enden. Meistens wollen wir eine binäre Klassifikation rechnen, so dass am Ende dann zwi Outputknoten stehen. Die Hiddenlayer können unterschiedlich viele Knoten enthalten und meistens gibt es auch mehrere Abstufungen. Das heißt wir fnagen mit mehreren Knoten pro Hiddenlayer an und reduzieren dann die Anzahl der Knoten pro Hiddenlayer über die Breite des neuronalen Netzwerkes.</p>
<div id="fig-class-nnet-02" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-nnet-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/class-neuralnet-02.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Abbildung&nbsp;76.2— Darstellung von drei Inputneuronen x_1, x_2, x_3 ohne ein Biasneuron. Die drei Inputbeurnen leiten ihre Gewichte an die Hidden Layer Neoronen weiter. In jedem diesem Neuron findet eine Summiierung in eine eventuelle Aktivierung statt. Aktivierte Neuronen leiten die Summation als Gewichte dann an weitere Hidden Layer Neuronen weiter. Am Ende findet eine Entscheidung in den Outputneuronen statt."><img src="images/class-neuralnet-02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-nnet-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.2— Darstellung von drei Inputneuronen <span class="math inline">\(x_1, x_2, x_3\)</span> ohne ein Biasneuron. Die drei Inputbeurnen leiten ihre Gewichte an die Hidden Layer Neoronen weiter. In jedem diesem Neuron findet eine Summiierung in eine eventuelle Aktivierung statt. Aktivierte Neuronen leiten die Summation als Gewichte dann an weitere Hidden Layer Neuronen weiter. Am Ende findet eine Entscheidung in den Outputneuronen statt.
</figcaption>
</figure>
</div>
<p>Spannenderweise sind viele Dinge in einem neuronalen Netzwerk nichts anderes als eine intelligente Hintereinanderschaltung von multiple linearen Regressionen Deshalb gibt es in der <a href="#tbl-class-nn-01" class="quarto-xref">Tabelle&nbsp;<span>76.1</span></a> auch einmal eine Übersicht der Begriffe in dem Sprachraum der neuronalen Netze und der klassischen logistischen Regression. Wir sehen hier einiges an gleichen Konzepten.</p>
<div id="tbl-class-nn-01" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-class-nn-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabelle&nbsp;76.1— Welche Begriff in dem Sprachraum der neuronalen Netze lässt sich zu welchem Begriff in der logistischen Regression zuordnen?
</figcaption>
<div aria-describedby="tbl-class-nn-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 35%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Neural network</th>
<th style="text-align: left;">Logistic regression (eng.)</th>
<th>Logistische Regression (deu.)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Activation function</td>
<td style="text-align: left;">Link function</td>
<td>Link Funktion</td>
</tr>
<tr class="even">
<td style="text-align: left;">Weights</td>
<td style="text-align: left;">Coefficients / Slope</td>
<td>Koeffizienten / Steigung</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bias</td>
<td style="text-align: left;">Intercept</td>
<td>Intercept</td>
</tr>
<tr class="even">
<td style="text-align: left;">Variance</td>
<td style="text-align: left;">Residuals</td>
<td>Fehler / Residuen</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Learning</td>
<td style="text-align: left;">Fitting</td>
<td>Modellieren</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p><a href="https://stackoverflow.com/questions/2480650/what-is-the-role-of-the-bias-in-neural-networks">What is the role of the bias in neural networks?</a></p>
</div></div><p>Wenn ein neuronales Netz auf dem Trainingssatz trainiert wird, wird es mit einer Reihe von Gewichten initialisiert. Diese Gewichte werden dann während der Trainingsperiode optimiert und die optimalen Gewichte werden erzeugt. Das ist ein wichtiger Punkt. Wir erzeugen zufällig die Gewichte am Anfang und lassen uns dann die Gewichte mehr oder minder zufällig weiteroptimieren. Sonst würden ja bei jedem Knoten die gleichen Zahlen rauskommen. Wir optimieren aber nicht nur einmal sondern meistens mehrfach. Das heißt wir lassen das neuronale Netzwerk mehrfach wachsen und optimieren bei jedem Wachstum die Gewicte so, dass der Fehler geringer wird.</p>
<p>Die Epoche (eng. <em>epoch</em>) ist einer der Eingabeparameter des Algorithmus. Stelle dir die Epoche als eine Schleife vor. Die Schleife bestimmt, wie oft ein Lernalgorithmus die Gewichte aktualisiert. Wenn der Wert der Epoche 1 ist, bedeutet dies, dass das neuronale Netz einmal läuft um die Gewichte zu aktualisieren. Wenn die Epoche einen Wert von 5 hat, wird das neuronale Netzwerk fünfmal aktualisiert. Hier ist der Unterschied zu den Entscheidungsbäumen auffällig. Entscheidungsbäume werden in einem Random Forest gemittelt. Die Epochen eines neuronalen Netzwerkes hängen aber miteinander zusammen.</p>
<div class="page-columns page-full"><p></p><div class="no-row-height column-margin column-container"><span class="margin-aside">Ein neuronales Netz ist eine korrigierende Rückkopplungsschleife, die Gewichte belohnt, die seine korrekten Vermutungen unterstützen, und Gewichte bestraft, die es zu Fehlern verleiten.</span></div></div>
<p>Damit wir wissen, ob unser Netzwerk über die Epochen besser wird, brauchen wir eine Verlustfunktion (eng. <em>loss function</em>). Die Verlustfunktion wird auch als Kostenfunktion (eng. <em>cost function</em>) bezeichnet. Sie errechnet den Fehler. Um genau zu sein, ist die Kostenfunktion der Durchschnitt der Verlustfunktionen. Dies ist die Funktion, die der Optimierungsalgorithmus zu minimieren versucht. Es gibt eine große Anzahl von Verlustfunktionen, wie den mittleren quadratischen Fehler oder die binäre Kreuzentropie.</p>
<p>Die Verlustfunktion sagt dem neuronalen Netz im Wesentlichen, welche Maßnahmen es ergreifen muss, um die Accuracy zu verbessern. Diese Information wird dann verwendet, um genaueren Gewichte zu erzeugen. Danach kann dann das neuronale Netz kann die Daten erneut weiterverarbeiten.</p>
<p>Am Rande möchte ich noch die Begriffe Forward Propagation und Back Propagation erwähnen. Beide Begriffe beschreiben, wie das Lernen innerhalb eines neuronalen Netzwerk abläuft. Klassisch ist die Forward Propagation. Dabei reicht ein Knoten die Informationen an den nächsten Knoten weiter. Das Lernen erfolgt <em>vorwärts</em>. Die andere Möglichkeit ist, das Netzwerk wachsen zu lassen und dann <em>rückwärts</em> die Gewichte der Knoten zu verbessern. Wir haben dann eine Back Propagation vorliegen.</p>
</section>
<section id="neuronales-netz-anschaulicher" class="level2" data-number="76.3">
<h2 data-number="76.3" class="anchored" data-anchor-id="neuronales-netz-anschaulicher"><span class="header-section-number">76.3</span> Neuronales Netz anschaulicher</h2>
<p>In unserem folgenden Beispiel ist Rotkäppchen das neuronale Netz. Rotkäppchen hat folgende Informationen zu drei möglichen Outcomes vorliegen. Rotkäppchen weiß also, dass es im Wald oder im Haus drei Personen treffen kann. Entweder trifft sie die Großmutter, den großen, bösen Wolf oder den Holzfäller. Gott sei Dank kennt Rotkäppchen die Eigenschaften der drei Charaktere und kann daran sich folgende Matrix aufbauen. Wir lesen die Tabelle wie folgt, wir haben die Spalte <code>grosse_ohren</code> und wir haben drei Werte mit der Spalte assoziiert. Wir wissen aber nicht welche Zeile welcher Charakter ist. Wir wollen die Zuordnung einmal mit dem neuronalen Netzwerk durchführen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>little_red_tbl <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">grosse_ohren =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>), </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">grosse_augen =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">grosse_zaehne =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>) , </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">freundlich =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">faltig =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">gutaussehend =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                         <span class="at">renn_weg =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                         <span class="at">schrei =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                         <span class="at">ruf_holzfaeller =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                         <span class="at">plaudere =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                         <span class="at">geh_hin =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                         <span class="at">biete_essen =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                         <span class="at">rettung =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In der <a href="#tbl-little_red_data" class="quarto-xref">Tabelle&nbsp;<span>76.2</span></a> sehen wir die Daten nbochmal in das Input Layer und das Output Layer aufgespaltet. Die Frage ist, was soll Rotkäppchen tun, wenn die die Eigenschaften des Input Layers beobachtet? Wir wollen jetzt anhand eines neuronalen Netzes die Input Layer dem Output Layer zuordnen.</p>
<div id="tbl-little_red_data" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-little_red_data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabelle&nbsp;76.2— Die beiden Datensätze für das neuronale Netzwerk. Wie lässt sich der Input sinnvoll mit dem Output verbinden? Wir geben dafür drei Hidden Layers vor, die dann die Charaktere Wolf, Goßmutter und den Holzfäller repräsentieren.
</figcaption>
<div aria-describedby="tbl-little_red_data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-little_red_data" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-little_red_data-1" class="do-not-create-environment quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-little_red_data-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Daten des Input Layers.
</figcaption>
<div aria-describedby="tbl-little_red_data-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table id="tbl-little_red_data-1" class="do-not-create-environment caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: left;">grosse_ohren</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">grosse_augen</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">grosse_zaehne</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">freundlich</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">faltig</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">gutaussehend</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-little_red_data" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-little_red_data-2" class="do-not-create-environment quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-little_red_data-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Daten des Output Layers.
</figcaption>
<div aria-describedby="tbl-little_red_data-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table id="tbl-little_red_data-2" class="do-not-create-environment caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: left;">renn_weg</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">schrei</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ruf_holzfaeller</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">plaudere</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">geh_hin</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">biete_essen</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rettung</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
</div>
</div>
</figure>
</div>
<p>Im Folgenden siehst du einmal den Code für das simple neuronale Netzwerk. Wir haben die Spalten des Input Layer durch das <code>~</code> von den Spalten des Output Layers getrennt. Darüber hinaus wollen wir noch drei Hidden Layer Knoten haben. Jeweils einen Knoten für jeden unserer drei Charaktere.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>neuralnetwork <span class="ot">&lt;-</span> <span class="fu">neuralnet</span>(renn_weg <span class="sc">+</span> schrei <span class="sc">+</span> ruf_holzfaeller <span class="sc">+</span> plaudere <span class="sc">+</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                             geh_hin <span class="sc">+</span> biete_essen <span class="sc">+</span> rettung <span class="sc">~</span> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                             grosse_ohren <span class="sc">+</span> grosse_augen <span class="sc">+</span> grosse_zaehne <span class="sc">+</span> </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                             freundlich <span class="sc">+</span> faltig <span class="sc">+</span> gutaussehend,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                           <span class="at">data =</span> little_red_tbl, <span class="at">hidden =</span> <span class="dv">3</span>, </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                           <span class="at">exclude =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">15</span>, <span class="dv">22</span>, <span class="dv">26</span>, <span class="dv">30</span>, <span class="dv">34</span>, <span class="dv">38</span>, <span class="dv">42</span>, <span class="dv">46</span>), </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">lifesign =</span> <span class="st">"none"</span>, <span class="at">linear.output =</span> <span class="cn">FALSE</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In <a href="#fig-class-nn-01" class="quarto-xref">Abbildung&nbsp;<span>76.3</span></a> sehen wir das neuronale Netzwerk einmal abgebildet. Da wir uns so ein simples Beispiel ausgedacht haben, können wir das Beispiel hier auch einmal visualisieren. Wir sehen hier nochmal auf der linken Seite das Input Layer und auf der rechten Seite das Output Layer. Die schwarzen, dicken Linien stellen die bedeutenden Gewichte dar. Wir sehen also, dass <code>grosse_ohren</code>, <code>grosse_augen</code> und <code>grosse_zaehne</code> mit dem Hidden Layer H3 verbunden sind. Von dem Hidden Layer H3 gehen dann die Linien zu <code>renn_weg</code>, <code>schrei</code> und <code>ruf_holzfaeller</code>. Wir sehen daran, dass das neuronale Netzwerk in H3 den großen, bösen Wolf erkannt hat. Da wir jetzt sehen, dass H1 hauptsächlich <code>faltig</code> ist, können wir hier auf die Repräsentation der Großmutter schließen. Ebenso ist H2 <code>gutaussehend</code>, so dass wir hierauf die Repräsenrtation des Holzfällers schließen können. Die Zuordnungen des Output Layers passen dementsprechend dann auch.</p>
<div class="cell" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotnet</span>(neuralnetwork, <span class="at">bias =</span> <span class="cn">FALSE</span>, <span class="at">pad_x =</span> <span class="fl">0.73</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-class-nn-01" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-nn-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="classification-neural-networks_files/figure-html/fig-class-nn-01-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Abbildung&nbsp;76.3— Visualisierung des neuronalen Netzwerkes mit drei vorgebenen Hidden Layers. Die Hidden Layers repräsentieren in diesem Beispiel die Characktere Wolf, Großmutter und den Holzfäller."><img src="classification-neural-networks_files/figure-html/fig-class-nn-01-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-nn-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.3— Visualisierung des neuronalen Netzwerkes mit drei vorgebenen Hidden Layers. Die Hidden Layers repräsentieren in diesem Beispiel die Characktere Wolf, Großmutter und den Holzfäller.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="neuronales-netz-mathematischer" class="level2 page-columns page-full" data-number="76.4">
<h2 data-number="76.4" class="anchored" data-anchor-id="neuronales-netz-mathematischer"><span class="header-section-number">76.4</span> Neuronales Netz mathematischer</h2>
<p>Das folgende etwas mathematische Beispiel ist von <span class="citation" data-cites="kubat2017introduction">Kubat (<a href="#ref-kubat2017introduction" role="doc-biblioref">2017</a>)</span>, pp.&nbsp;65-73, entnommen. Ich habe das Beispiel dann für R adaptiert, so dass wir hier auch R Code zum ausprobieren haben. Bevor wir damit anfangen, hier nochmal auf einfache Weise erklärt, was beim Lernen mit einem neuronalen Netzwerk geschieht.</p>
<p>Eingaben werden als Inputs in das Netz eingegeben. Die Koeffizienten bzw. Gewichte ordnen diese Eingabe einer Reihe von Vermutungen zu, die das Netz am Ende anstellt. Hierbei erfolgt die Zuornung mehr oder minder zufällig. Wir beginnen ja auch mit einem Satz an zufällig ausgewählten Gewichten, die wir dann innerhalb des neuronalen Netzwerks optimieren wollen.</p>
<p><span class="math display">\[
Eingabe * Gewichtung = Vermutung
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><span class="math display">\[
input * weight = guess
\]</span></p>
</div></div><p>Die gewichtete Eingabe führt zu einer Vermutung darüber, was die Eingabe ist. Das neuronale Netz vergleicht dann seine Vermutung mit einer Wahrheit über die Daten und berechnet daraus einen Fehler. Wir wissen, dass wir zehn kranke und acht gesunde Ferkel in dem Datensatz haben, wie viele kann das neuronale Netzwerk anhand der Gewichte und dem Input richtig zuordnen oder eben falsch zuordnen?</p>
<p><span class="math display">\[
Wahrheit - Vermutung = Fehler
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><span class="math display">\[
truth - guess = error
\]</span></p>
</div></div><p>Die Differenz zwischen der Schätzung des neuronalen Netzes und der Wahrheit ist der Fehler. Das Netzwerk misst diesen Fehler und minimiert den Fehler über das Modell, indem es die Gewichte in dem Maße anpasst, wie sie zum Fehler beigetragen haben.</p>
<p><span class="math display">\[
Fehler * Beitrag\; des\; Gewichts\; zum\; Fehler = Anpassung
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><span class="math display">\[
error * weight's\; contribution\; to\; error = adjustment
\]</span></p>
</div></div><p>Die drei obigen Formeln beschreiben die drei Hauptfunktionen neuronaler Netze: Bewertung der Eingaben, Berechnung des Verlusts und Aktualisierung des Modells, um den dreistufigen Prozess von vorne zu beginnen. Ein neuronales Netz ist eine korrigierende Rückkopplungsschleife, die Gewichte belohnt, die seine korrekten Vermutungen unterstützen, und Gewichte bestraft, die es zu Fehlern verleiten.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Das Buch <a href="https://link.springer.com/book/10.1007/978-3-319-63913-0">An Introduction to Machine Learning</a> kannst du dir an der HS Osnabrück als PDF über die Hochschule runterladen.</p>
</div></div><p>Betrachten wir also einmal ein simples Datenbeispiel von vier Beobachtungen mit jeweils einem <span class="math inline">\(x_1\)</span> und einem <span class="math inline">\(x_2\)</span> Wert als Prädiktor. Der Wert den <span class="math inline">\(x_1\)</span> oder <span class="math inline">\(x_2\)</span> annehmen können sind binär. Wir haben also für unsere beiden Prädiktoren nur <span class="math inline">\(0/1\)</span> Werte vorliegen. Unser Label <span class="math inline">\(y\)</span> ist ebenfalls binär. Entweder ist die betreffende Beobachtung erkrankt oder eben nicht. In unserem Beispiel sind die ersten beiden Beobachtungen nicht erkrankt und die letzten beiden Beobachtungen sind erkrankt. Schauen wir uns den Datensatz einmal an.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>data_tbl <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">x_1 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">x_2 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>data_tbl</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4 × 3
      y   x_1   x_2
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1     0     0     0
2     0     1     0
3     1     0     1
4     1     1     1</code></pre>
</div>
</div>
<p>Faktisch wollen wir jetzt eine Grade durch die Punkte legen, so dass wir die gesunden von den kranken Beobachtungen trennen können. Praktisch machen wir das mit einer linearen Funktion <span class="math inline">\(h(x)\)</span>, die uns anhand von <span class="math inline">\(x_1\)</span> und <span class="math inline">\(x_2\)</span> eine Aussagen über den Status von <span class="math inline">\(y\)</span> ermöglicht. Wir erhalten zuerst einen <em>numerischen</em> Wert, den wir dann noch mit einer Regel in eine <span class="math inline">\(0/1\)</span> Entscheidung umwandeln müssen.</p>
<p><span class="math display">\[
h(x) \sim w_0 + w_1 \cdot x_1 + w_2 \cdot x_2
\]</span></p>
<p>Nun können wir die Formel nochmal kompakter schreiben.</p>
<p><span class="math display">\[
h(x) \sim \sum_{i = 0}^{n=2} w_i x_i
\]</span></p>
<p>Wir drücken im Folgenden damit aus, das wir auch die Gewichte <span class="math inline">\(w_i\)</span> mit den einzelnen <span class="math inline">\(x_i\)</span> multiplizieren und anschließend aufsummieren. Anhand der aufsummierten Zahl aus <span class="math inline">\(h(x)\)</span> können wir dann eine Entscheidung für <span class="math inline">\(0/1\)</span> treffen. In unserem Beispiel entscheiden wir uns dazu, das wir <span class="math inline">\(y=0\)</span> annehmen wenn <span class="math inline">\(h(x) &lt; 0\)</span> ist oder aber <span class="math inline">\(y=1\)</span> annehmen, wenn <span class="math inline">\(h(x) \geq 0\)</span> ist. Wir können das einmal formal aufschreiben.</p>
<p><span class="math display">\[
h(x)=
\begin{cases}
    1,&amp; \text{wenn } h(x)\geq 0\\
    0,              &amp; \text{ansonsten}
\end{cases}
\]</span></p>
<p>Nichts anders ist dann auch unser Neuron, was die Entscheidungen trifft. Wir haben vier verschiedene <span class="math inline">\(x_1\)</span> und <span class="math inline">\(x_2\)</span> Kombinationen und gewichten diese beiden <span class="math inline">\(x\)</span> dann noch einem Gewichtsvektor. Wenn wir dann als aufsummiertes Ergebnis eine Zahl größer als <span class="math inline">\(0\)</span> erhalten, dann gibt unser Neuron als Klassifikationsergebnis ein <span class="math inline">\(1\)</span> wieder.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>neuron <span class="ot">&lt;-</span> <span class="cf">function</span>(input, weights) {<span class="fu">ifelse</span>(input <span class="sc">%*%</span> weights <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wir brauchen also zum einen die Inputmatrix. Die bauen wir uns einmal mit der Funktion <code>model.matrix()</code>. Dann haben wir drei Spalten für jedes Gewicht <span class="math inline">\(w\)</span>. Dann brauchen wir noch die drei Gewichte <span class="math inline">\(w_0\)</span>, <span class="math inline">\(w_1\)</span> und <span class="math inline">\(w_2\)</span>. Nichts anders als der Intercept und die Steigung in einem linearen Modell.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>input <span class="ot">&lt;-</span> data_tbl <span class="sc">%$%</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">model.matrix</span>(<span class="sc">~</span> x_1 <span class="sc">+</span> x_2)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>input</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept) x_1 x_2
1           1   0   0
2           1   1   0
3           1   0   1
4           1   1   1
attr(,"assign")
[1] 0 1 2</code></pre>
</div>
</div>
<p>Wir wählen <em>zufällig</em> drei Gewichte aus, die wir dann in unser Modell geben. Die Gwichte werden dann innerhalb des neuronalen Netzwerks dann optimiert. Die Wahl der passenden Gewichte ist dann noch eine Frage für sich, aber hier haben wir diese drei Werte ausgewählt.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>weights <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Dann brauchen wir noch ein <span class="math inline">\(\eta\)</span>, dass beschreibt, um wie viel wir die Gewichte pro Runde der Optimierung verändern wollen. Wir wählen hier einen Wert von <span class="math inline">\(0.2\)</span>. Je kleiner der Wert, desto länger braucht das neuronale Netzwerk um ein Optimum zu finden. Pro Schritt können ja die Gewichte nur wenig geändertw werden. Ist das <span class="math inline">\(\eta\)</span> zu groß dann sind die Änderungen der Gewichte auch groß und es kann sein, dass das neuronale Netzwerk gar keine optimalen Gewichte findet. Die Auflösung ist einfach nicht gering genug.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>eta <span class="ot">&lt;-</span> <span class="fl">0.2</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jetzt laufen wir einmal durch vier Epochen. In jeder Epoche werden wir unser Gewicht dann wieder optimieren und dann mit den optimierten Gewichten weiter rechnen. Wir lassen uns aber in jeder Schleife einmal die Gewichte ausgeben.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>){</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  adjust <span class="ot">&lt;-</span> (data_tbl<span class="sc">$</span>y[i] <span class="sc">-</span> <span class="fu">neuron</span>(weights, input[i,])) <span class="sc">*</span> input[i,]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  weights <span class="ot">&lt;-</span> weights <span class="sc">+</span> eta <span class="sc">*</span> adjust</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Adjust: "</span>, adjust, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Weights: "</span>, weights, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Adjust:  -1 0 0 
Weights:  -0.1 0.3 0.4 
Adjust:  -1 -1 0 
Weights:  -0.3 0.1 0.4 
Adjust:  0 0 0 
Weights:  -0.3 0.1 0.4 
Adjust:  0 0 0 
Weights:  -0.3 0.1 0.4 </code></pre>
</div>
</div>
<p>Die Gewichte ändern sich in jedem Schritt um den Wert von <span class="math inline">\(0.2\)</span>. Mehr geht auch nicht, denn wir geben mit <span class="math inline">\(\eta\)</span> vor, um wieviel sich die Gewichte erhöhen oder erniedrigen können. Im ersten Schritt reduzieren wir das erste Gewicht um den Wert von <span class="math inline">\(\eta\)</span>. Im zweiten Schritt reduzieren wir erneut das erste Gewicht und darüber hinaus auch noch das zweite Gewicht. Wir sind dann schon am Optimum, denn wir erhalten keine weiteren Anpassungen mehr. Vermutlich können wir schon am zweiten Schritt das Outcome perfekt auftrennen.</p>
<p>Schauen wir einmal was passiert, wenn wir unser <code>input</code> mit den Gewichten aus unserem simplen Algorithmus multiplizieren.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>input <span class="sc">%*%</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.4</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  [,1]
1 -0.3
2 -0.2
3  0.1
4  0.2</code></pre>
</div>
</div>
<p>Unsere ersten zwei Beobachtungen erhalten einen negativen Wert und unsere letzten beiden Beobachtungen einen positiven Wert. Nach unserer Regeln werden Zahlen kleiner als Null zu <span class="math inline">\(0\)</span> und Zahlen größer als Null zu <span class="math inline">\(1\)</span>. Da wir die Regel auch in dem Neuron abgespeichert haben, können wir uns einmal das Outcome mit den Input und den berechnete Gewichten wiedergeben lassen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">neuron</span>(input, <span class="at">weights =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.4</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  [,1]
1    0
2    0
3    1
4    1</code></pre>
</div>
</div>
<p>Wir erhalten eine perfekte Übereinstimmung von der Vorhersage mit unseren Trainingsdaten. Der Algorithmus ist in der Lage mit der Regel in dem Neuron und den berechneten Gewichten unser Outcome korrekt mit den Trainingsdaten vorherzusagen.</p>
</section>
<section id="daten" class="level2" data-number="76.5">
<h2 data-number="76.5" class="anchored" data-anchor-id="daten"><span class="header-section-number">76.5</span> Daten</h2>
<p>In Folgenden wollen wir uns aber mal auf einen echten Datensatz konzentrieren. Wir nutzen daher einmal den Gummibärchendatensatz. Als unser Label und daher als unser Outcome nehmen wir das Geschlecht <code>gender</code>. Dabei wollen wir dann die weiblichen Studierenden vorhersagen. Im Weiteren nehmen wir nur die Spalte Geschlecht sowie als Prädiktoren die Spalten <code>most_liked</code>, <code>age</code>, <code>semester</code>, und <code>height</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>gummi_tbl <span class="ot">&lt;-</span> <span class="fu">read_excel</span>(<span class="st">"data/gummibears.xlsx"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">gender =</span> <span class="fu">as_factor</span>(gender),</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">most_liked =</span> <span class="fu">as_factor</span>(most_liked)) <span class="sc">|&gt;</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(gender, most_liked, age, semester, height) <span class="sc">|&gt;</span> </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">drop_na</span>(gender)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wir dürfen keine fehlenden Werte in den Daten haben. Wir können für die Prädiktoren später die fehlenden Werte imputieren. Aber wir können keine Labels imputieren. Daher entfernen wir alle Beobachtungen, die ein <code>NA</code> in der Variable <code>gender</code> haben. Wir haben dann insgesamt <span class="math inline">\(n = 811\)</span> Beobachtungen vorliegen. In <a href="classification-pre-processing.html#tbl-gummi-prepro" class="quarto-xref">Tabelle&nbsp;<span>71.5</span></a> sehen wir nochmal die Auswahl des Datensatzes in gekürzter Form.</p>
<div class="cell">
<div id="tbl-gummi-model-compare" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-gummi-model-compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabelle&nbsp;76.3— Auszug aus dem Daten zu den Gummibärchendaten.
</figcaption>
<div aria-describedby="tbl-gummi-model-compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: center;">gender</th>
<th style="text-align: center;">most_liked</th>
<th style="text-align: center;">age</th>
<th style="text-align: center;">semester</th>
<th style="text-align: center;">height</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">m</td>
<td style="text-align: center;">lightred</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">193</td>
</tr>
<tr class="even">
<td style="text-align: center;">w</td>
<td style="text-align: center;">yellow</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">159</td>
</tr>
<tr class="odd">
<td style="text-align: center;">w</td>
<td style="text-align: center;">white</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">159</td>
</tr>
<tr class="even">
<td style="text-align: center;">w</td>
<td style="text-align: center;">white</td>
<td style="text-align: center;">36</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">180</td>
</tr>
<tr class="odd">
<td style="text-align: center;">m</td>
<td style="text-align: center;">white</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">180</td>
</tr>
<tr class="even">
<td style="text-align: center;">m</td>
<td style="text-align: center;">green</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">180</td>
</tr>
<tr class="odd">
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
<tr class="even">
<td style="text-align: center;">w</td>
<td style="text-align: center;">green</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">184</td>
</tr>
<tr class="odd">
<td style="text-align: center;">m</td>
<td style="text-align: center;">darkred</td>
<td style="text-align: center;">19</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">184</td>
</tr>
<tr class="even">
<td style="text-align: center;">w</td>
<td style="text-align: center;">lightred</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">180</td>
</tr>
<tr class="odd">
<td style="text-align: center;">m</td>
<td style="text-align: center;">darkred</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">170</td>
</tr>
<tr class="even">
<td style="text-align: center;">m</td>
<td style="text-align: center;">green</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">181</td>
</tr>
<tr class="odd">
<td style="text-align: center;">m</td>
<td style="text-align: center;">darkred</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">182</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>Unsere Fragestellung ist damit, können wir anhand unserer Prädiktoren männliche von weiblichen Studierenden unterscheiden und damit auch klassifizieren? Um die Klassifikation mit Entscheidungsbäumen rechnen zu können brauchen wir wie bei allen anderen Algorithmen auch einen Trainings- und Testdatensatz. Wir splitten dafür unsere Daten in einer 3 zu 4 Verhältnis in einen Traingsdatensatz sowie einen Testdatensatz auf. Der Traingsdatensatz ist dabei immer der größere Datensatz. Da wir aktuell nicht so viele Beobachtungen in dem Gummibärchendatensatz haben, möchte ich mindestens 100 Beobachtungen in den Testdaten. Deshalb kommt mir der 3:4 Split sehr entgegen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>gummi_data_split <span class="ot">&lt;-</span> <span class="fu">initial_split</span>(gummi_tbl, <span class="at">prop =</span> <span class="dv">3</span><span class="sc">/</span><span class="dv">4</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wir speichern uns jetzt den Trainings- und Testdatensatz jeweils separat ab. Die weiteren Modellschritte laufen alle auf dem Traingsdatensatz, wie nutzen dann erst ganz zum Schluss einmal den Testdatensatz um zu schauen, wie gut unsere trainiertes Modell auf den neuen Testdaten funktioniert.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>gummi_train_data <span class="ot">&lt;-</span> <span class="fu">training</span>(gummi_data_split)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>gummi_test_data  <span class="ot">&lt;-</span> <span class="fu">testing</span>(gummi_data_split)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Nachdem wir die Daten vorbereitet haben, müssen wir noch das Rezept mit den Vorverabreitungsschritten definieren. Wir schreiben, dass wir das Geschlecht <code>gender</code> als unser Label haben wollen. Daneben nehmen wir alle anderen Spalten als Prädiktoren mit in unser Modell, das machen wir dann mit dem <code>.</code> Symbol. Da wir noch fehlende Werte in unseren Prädiktoren haben, imputieren wir noch die numerischen Variablen mit der Mittelwertsimputation und die nominalen fehlenden Werte mit Entscheidungsbäumen. Dann müssen wir noch alle numerischen Variablen normalisieren und alle nominalen Variablen dummykodieren. Am Ende werde ich nochmal alle Variablen entfernen, sollte die Varianz in einer Variable nahe der Null sein.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>gummi_rec <span class="ot">&lt;-</span> <span class="fu">recipe</span>(gender <span class="sc">~</span> ., <span class="at">data =</span> gummi_train_data) <span class="sc">|&gt;</span> </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_mean</span>(<span class="fu">all_numeric_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_bag</span>(<span class="fu">all_nominal_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_range</span>(<span class="fu">all_numeric_predictors</span>(), <span class="at">min =</span> <span class="dv">0</span>, <span class="at">max =</span> <span class="dv">1</span>) <span class="sc">|&gt;</span> </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_dummy</span>(<span class="fu">all_nominal_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_nzv</span>(<span class="fu">all_predictors</span>())</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>gummi_rec <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 4
  variable   type      role      source  
  &lt;chr&gt;      &lt;list&gt;    &lt;chr&gt;     &lt;chr&gt;   
1 most_liked &lt;chr [3]&gt; predictor original
2 age        &lt;chr [2]&gt; predictor original
3 semester   &lt;chr [2]&gt; predictor original
4 height     &lt;chr [2]&gt; predictor original
5 gender     &lt;chr [3]&gt; outcome   original</code></pre>
</div>
</div>
<p>Alles in allem haben wir ein sehr kleines Modell. Wir haben ja nur ein Outcome und vier Prädiktoren. Trotzdem sollte dieser Datensatz reichen um zu erklären wie Keras oder Tensorflow funktionieren. Am Ende muss man sich aber auch ehrlich machen und sagen, dass ein Datensatz mit unter tausend Beobachtungen eigentlich keinen großen Sinn für ein neuronales Netz macht. Deshalb ist das hier eher eine Demonstration des Algorithmus.</p>
</section>
<section id="neuronale-netze-mit-neuralnet" class="level2 page-columns page-full" data-number="76.6">
<h2 data-number="76.6" class="anchored" data-anchor-id="neuronale-netze-mit-neuralnet"><span class="header-section-number">76.6</span> Neuronale Netze mit <code>neuralnet</code></h2>
<p>Neuronale Netze mit den R Paketen <code>{neuralnet}</code> und dem R Paket <code>{nnet}</code> sind mehr oder minder veraltet (eng. <em>outdated</em>). Wir können das Paket <code>{neuralnet}</code> nicht über die <code>{parsnip}</code> Umgebung nutzen. Deshalb hier einmal zu Fuß mit all den Komplikationen, die das so mit sich bringt. Auf der anderen Seite liefert das Paket <code>{neuralnet}</code> auch gute Ergebnisse mit wenig rechenlaufzeit. Da musst du dann einmal abwägen, was du in deiner Arbei so brauchst.</p>
<p>Das die Funktion <code>neuralnet()</code> nicht mit den Workflow kann, müssen wir uns erstmal wieder den Traingsdatendatz und den Testdatensatz aus unserem Rezept extrahieren. Den Traingsdatensatz können wir uns über die Funktion <code>juice()</code> einmal aus dem Rezept ziehen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>gummi_train_tbl <span class="ot">&lt;-</span> gummi_rec <span class="sc">|&gt;</span> </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">prep</span>() <span class="sc">|&gt;</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">juice</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Den Testdatensatz müssen wir mit dem Rezept einmal backen. Dann müssen wir noch die Spalte <code>gender</code> in eine numerische Spalte umwandeln. Sonst klappt das später nicht mit der Prädiktion und der Konfusionsmatrix.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>gummi_test_tbl <span class="ot">&lt;-</span> gummi_rec <span class="sc">|&gt;</span> </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">prep</span>() <span class="sc">|&gt;</span> </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">bake</span>(gummi_test_data) <span class="sc">|&gt;</span> </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">gender =</span> <span class="fu">as_factor</span>(<span class="fu">ifelse</span>(gender <span class="sc">==</span> <span class="st">"m"</span>, <span class="dv">0</span>, <span class="dv">1</span>)))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Dann können wir auch schon die Funktion <code>neuralnet</code> auf unsere Daten anwenden. Wir wollen fünfmal über die Traingsdaten iterieren (<code>rep = 5</code>). Später heißt dieses Iterieren dann auch <code>epoch</code>. Dann müssen wir noch den Threshold für den Fehler festlegen, der gerade noch so akzeptabel ist und wo das Wachstum endet. Je kleiner, desto länger dauer der Prozess. Mit einem <code>threshold = 0.2</code> sind wir aber schon sehr weit oben, sonst ist der Wert bei <span class="math inline">\(0.01\)</span>. Hier musst ein wenig selber mit den Parametern spielen. Eine Tuningmöglichkeit oder eine Kreuzvalidierung musst du dir dann selber programmieren. Wir nehmen dann fünf Hiddenlayers mit jeweils fünf Knoten pro Hiddenlayer.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>neuralnet_fit <span class="ot">&lt;-</span> <span class="fu">neuralnet</span>(gender <span class="sc">~</span>., <span class="at">data =</span> gummi_train_tbl, <span class="at">rep =</span> <span class="dv">5</span>, <span class="at">threshold =</span> <span class="fl">0.2</span>,</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">hidden =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">5</span>), <span class="at">lifesign =</span> <span class="st">"minimal"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>hidden: 5, 5    thresh: 0.2    rep: 1/5    steps:    2275   error: 62.95676 time: 0.65 secs
hidden: 5, 5    thresh: 0.2    rep: 2/5    steps:    3417   error: 59.51404 time: 0.93 secs
hidden: 5, 5    thresh: 0.2    rep: 3/5    steps:     650   error: 69.49287 time: 0.15 secs
hidden: 5, 5    thresh: 0.2    rep: 4/5    steps:    1250   error: 66.29715 time: 0.3 secs
hidden: 5, 5    thresh: 0.2    rep: 5/5    steps:    1563   error: 68.33043 time: 0.41 secs</code></pre>
</div>
</div>
<p>Wenn wir das Modell haben, dann können wir uns hier ganz einfach mal das beste neuronale Netzwerk anschauen. Also die Wiederholung mit dem kleinsten Fehler. In Abbildung <a href="#fig-class-nn-02" class="quarto-xref">Abbildung&nbsp;<span>76.4</span></a> sehen wir das Netzwerk einmal dargestellt. Die blauen Knoten stellen die Biasknoten dar. Die Zahlen an den Kanten stellen dann die Gewichte dar, die von dem jeweiligen Knoten weitergegeben werden. Die Interpretation des Netzwerks ist so schwer, es ist eben nur eine visuelle Darstellung. Da so eine Abbildung etwas schwer zu interpretieren ist, erlaubt ein neurales Interpretationsdiagramm mehr Einblicke. Die schwarzen Kanten haben einen höheren Einfluss als die grauen Kanten. Die exakte Interpretation der Knoten und der Kanten ist aber dennoch schwierig.</p>
<div class="cell page-columns page-full" data-layout-nrow="1" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(neuralnet_fit, <span class="at">rep =</span> <span class="st">"best"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plotnet</span>(neuralnet_fit, <span class="at">rep =</span> <span class="st">"best"</span>, <span class="at">bias =</span> <span class="cn">FALSE</span>, <span class="at">pad_x =</span> <span class="fl">0.59</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-class-nn-02" class="quarto-layout-panel page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-class-nn-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<div class="quarto-layout-row page-full">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell page-columns page-full" data-ref-parent="fig-class-nn-02" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-class-nn-02-1" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-align="center">
<figure class="quarto-float quarto-subfloat-fig figure page-columns page-full">
<div aria-describedby="fig-class-nn-02-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<a href="classification-neural-networks_files/figure-html/fig-class-nn-02-1.png" class="lightbox page-columns page-full" data-gallery="fig-class-nn-02" title="Abbildung&nbsp;76.4&nbsp;(a)— Neuronales Netzwerk mit den Gewichten und dem Bias als numerische Representation."><img src="classification-neural-networks_files/figure-html/fig-class-nn-02-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img column-page" data-ref-parent="fig-class-nn-02" width="768"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-class-nn-02-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Neuronales Netzwerk mit den Gewichten und dem Bias als numerische Representation.
</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell page-columns page-full" data-ref-parent="fig-class-nn-02" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-class-nn-02-2" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-align="center">
<figure class="quarto-float quarto-subfloat-fig figure page-columns page-full">
<div aria-describedby="fig-class-nn-02-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<a href="classification-neural-networks_files/figure-html/fig-class-nn-02-2.png" class="lightbox page-columns page-full" data-gallery="fig-class-nn-02" title="Abbildung&nbsp;76.4&nbsp;(b)— Neurales Interpretationsdiagramm für ein neurales Netzwerk."><img src="classification-neural-networks_files/figure-html/fig-class-nn-02-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img column-page" data-ref-parent="fig-class-nn-02" width="768"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-class-nn-02-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Neurales Interpretationsdiagramm für ein neurales Netzwerk.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-nn-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.4— Abbildung des neuronalen Netzwerks mit dem kleinsten Fehler.
</figcaption>
</figure>
</div>
</div>
<p>Am Ende machen wir das Ganze ja nicht um etwas <em>interpretieren</em> zu können, sondern um eine Vorhersage zu treffen. Das machen wir mit der Funktion <code>predict()</code>. Jetzt wird es wieder nervig. Wir müssen usn merken, dass unser Faktor zwei Level hat mit <code>0</code> und <code>1</code> wobei die <code>m = 0</code> und <code>w = 1</code> ist. Als wäre das nicht schon nervig genug, haben wir dann in der Ausgabe von <code>predict()</code> nur eine Matrix mit zwei Spalten. Wir brauchen die zweite Spalte, da wir das Geschlecht <code>w</code> vorhersagen wollen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>neuralnet_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(neuralnet_fit, gummi_test_tbl) <span class="sc">|&gt;</span> </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">round</span>(<span class="dv">2</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Kurzer Check, ob wir auch alles richtig gemacht haben.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(neuralnet_pred[,<span class="dv">1</span>])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.08  1.06</code></pre>
</div>
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(neuralnet_pred[,<span class="dv">2</span>])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.07  1.07</code></pre>
</div>
</div>
<p>Und wir stellen fest, dass hier irgendwas mit unserer Wahrscheinlichkeit für die Klassenzugehörigkeit nicht stimmt. Wir haben negative Werte und Werte über Eins. Das macht für eine Wahrscheinlichkeit keinen Sinn.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Stopp!
</div>
</div>
<div class="callout-body-container callout-body">
<p>Jetzt müssen wir hier erstmal anhalten, denn wir erhalten sinnlose Wahrscheinlichkeiten zurück. Ich würde hier erstmal das Modell überprüfen und die Daten anpassen. Jedenfalls geht es so nicht weiter…</p>
</div>
</div>
<p>Ich zeige aber noch wie du dir die Konfusionsmatrix berechnest. Da musst du dich wieder strecken um alles in die Funktion <code>conf_mat()</code> richtig rein zu kriegen. Aber Vorsicht, erst wenn du die Wahrscheinlichkeiten hingekriegt hast, dann kannst du mit der Konfusionsmatrix weitermachen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>neuralnet_cm <span class="ot">&lt;-</span> <span class="fu">conf_mat</span>(<span class="at">data =</span> <span class="fu">data.frame</span>(<span class="at">.pred_class =</span> <span class="fu">as.factor</span>(<span class="fu">round</span>(neuralnet_pred[,<span class="dv">2</span>])),</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">gender =</span> <span class="fu">as.factor</span>(<span class="fu">pull</span>(gummi_test_tbl, gender))), </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                         gender, .pred_class)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Dann können wir uns die Konfusionsmatrix auch einmal wiedergeben lassen. Ich wäre hier sehr vorsichtig, was die Werte angeht. Wir haben gerade komische Wahrscheinlichkeiten wiedergegeben bekommen. Daher würde ich der Sache hier nicht trauen und nochmal an der Funktion <code>neuralnet()</code> mit anderen Parametern herumprobieren. Man sieht, es hat auch einen Grund warum manche Funktionen nicht in der <code>parsnip</code> Umgebung implementiert sind.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>neuralnet_cm <span class="sc">|&gt;</span> </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  summary <span class="sc">|&gt;</span> </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate_if</span>(is.numeric, round, <span class="dv">2</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Hier ist also wirklich Vorsicht geboten, wenn wir uns die Ergebnisse anschauen. Die Ergebnisse sind zwar nicht so schlecht, aber wir vertrauen da nicht dem Algorithmus, wenn wir ungültige Wahrscheinlichkeiten erhalten.</p>
</section>
<section id="neuronale-netze-mit-nnet" class="level2" data-number="76.7">
<h2 data-number="76.7" class="anchored" data-anchor-id="neuronale-netze-mit-nnet"><span class="header-section-number">76.7</span> Neuronale Netze mit <code>nnet</code></h2>
<p>Wir können aber das R Paket <code>{nnet}</code> mit unserer bekannten Rezeptumgebung nutzen und uns damit das Leben einfacher machen. Das macht auch in diesem Fall sehr viel mehr Sinn, da wir ja nur komische Wahrscheinlichkeiten der Klassenzugehörigkeit aus der Funktion <code>neuralnet()</code> wiederbekommen. Also das ganze einmal ohne wildes Installieren von Tensorflow / Keras. Ein simples neurales Netzwerk in R mit der Engine aus <code>nnet</code>.</p>
<p>In unserem Beispiel lassen wir einhundert Replikationen laufen (<code>epoch = 100</code>) und wählen auch hier mal fünf Hidden Layers (<code>hidden_units = 5</code>). Dann wollen wir natürlich eine Klassifikation rechnen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>nnet_mod <span class="ot">&lt;-</span> <span class="fu">mlp</span>(<span class="at">epochs =</span> <span class="dv">100</span>, <span class="at">hidden_units =</span> <span class="dv">5</span>) <span class="sc">|&gt;</span> </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"nnet"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wir bringen wieder unser Modell mit dem Rezept des Gummibärchendatensatzes zusammen und können dann den Workflow abspeicherb.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>nnet_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(nnet_mod) <span class="sc">|&gt;</span> </span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wie immer starten wir dann den Workflow mit der Funktion <code>fit()</code> und erhalten das <code>nnet</code> Modell zurück.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>nnet_fit <span class="ot">&lt;-</span> nnet_wflow <span class="sc">|&gt;</span> </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  parsnip<span class="sc">::</span><span class="fu">fit</span>(gummi_train_data)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jetzt müssen wir nur noch mit der Funktion <code>augment</code> uns die Vorhersagen mit dem Testdatensatz wiedergeben lassen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>nnet_aug <span class="ot">&lt;-</span> <span class="fu">augment</span>(nnet_fit, gummi_test_data ) </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Da wir hier etwas vorsichtig geworden sind, nochmal schnell schauen, ob unsere Wahrscheinlichkeiten der Klassenzugehörigkeit auch wirklich eine Wahrscheinlichkeit ist.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pluck</span>(nnet_aug, <span class="st">".pred_w"</span>) <span class="sc">|&gt;</span> <span class="fu">range</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.2689414 0.7310586</code></pre>
</div>
</div>
<p>Ja, das passt soweit und wir können uns dann die Konfusionsmatrix berechnen lassen. Die Ergebnisse sind jetzt nicht so berauschend, aber auf der anderen Seite richtiger als in der Funktion <code>neuralnet()</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>nnet_cm <span class="ot">&lt;-</span> nnet_aug <span class="sc">|&gt;</span> </span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">conf_mat</span>(gender, .pred_class)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>nnet_cm</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>          Truth
Prediction  m  w
         m 85 16
         w 19 83</code></pre>
</div>
</div>
<p>Dann schauen wir uns nochmal die ganzen anderen Gütekriterien aus der Konfusionsmatrix einmal an.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>nnet_cm <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             binary         0.828
 2 kap                  binary         0.655
 3 sens                 binary         0.817
 4 spec                 binary         0.838
 5 ppv                  binary         0.842
 6 npv                  binary         0.814
 7 mcc                  binary         0.656
 8 j_index              binary         0.656
 9 bal_accuracy         binary         0.828
10 detection_prevalence binary         0.498
11 precision            binary         0.842
12 recall               binary         0.817
13 f_meas               binary         0.829</code></pre>
</div>
</div>
<p>Die Ergebnisse sind höchstens okay. Die Accuracy ist nicht sehr hoch und auch der Rest der Werte ist eher mittelmäßig. Das Ganze sehen wir dann in <a href="#fig-class-nnet-01" class="quarto-xref">Abbildung&nbsp;<span>76.5</span></a> auch nochmal entsprechend in der ROC Kurve visualisiert. Die ROC Kurve sieht nur mittelmäßig aus. Wir müssten hier auf jeden Fall nochmal über Kreuzvalidierung und Tuning nachdenken. Ohne Kreuzvalidierung und Tuning würde ich das Modell nicht anwenden.</p>
<div class="cell" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>nnet_aug <span class="sc">|&gt;</span> </span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-class-nnet-01" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-nnet-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="classification-neural-networks_files/figure-html/fig-class-nnet-01-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Abbildung&nbsp;76.5— ROC Kurve für den nnet Algorithmus."><img src="classification-neural-networks_files/figure-html/fig-class-nnet-01-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="480"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-nnet-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.5— ROC Kurve für den <code>nnet</code> Algorithmus.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="neuronale-netze-mit-keras-tensorflow" class="level2 page-columns page-full" data-number="76.8">
<h2 data-number="76.8" class="anchored" data-anchor-id="neuronale-netze-mit-keras-tensorflow"><span class="header-section-number">76.8</span> Neuronale Netze mit Keras / Tensorflow</h2>
<p>Jetzt kommen wir zum dicksten Brett. Was wir hier machen ist eigentlich nur ein schwacher Abglanz was Tensorflow eigentlich kann. Über den Algorithmus werden ganze Bücher geschrieben und die Anwendung auf einem Laptop oder Standrechner ist eigentlich dem Algorithmus nicht würdig. Wir werden hier auch nicht alles aus dem Algorithmus raus holen. Das geht auch gar nicht. Wenn du dich tiefer mit der Materie beschäftigen willst, dann ist dies hier ein guter Startpunkt. Wenn du Probleme hast Tensorflow zum Laufen zu kriegen, dann kannst du auch für die einfache Anwendung <code>nnet</code> nutzen. Mit ein wenig Tuning sollten da auch gute Ergebnisse bei herauskommen.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Wenn du richtig Tensorflow mit R nutzen willst, dann gibt es hier noch das umfangreiche Tutorium für <a href="https://colorado.rstudio.com/rsc/churn/modeling/tensorflow-w-r.nb.html">Tensorflow with R</a>. Insbesondere die Nutzung von <code>lime</code> um die Black Box des neuronalen Netzwerks zu erklären wird hier nochmal gezeigt.</p>
</div></div><p>Die Funktion <code>mlp()</code> erlaubt uns als Engine <code>keras</code> zu verweden und damit ein neurales Netzwerk mit dem Tensorflow Algorithmus zu rechnen. Mehr brauchen wir an dieser Stelle erstaml nicht tun. Wir werden hier erstmal keine Tuning Parameter angeben. Später im Kapitel werden wir dann noch ein Tuning für den Algorithmus rechnen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>keras_mod <span class="ot">&lt;-</span> <span class="fu">mlp</span>() <span class="sc">|&gt;</span> </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"keras"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jetzt bringen wir noch das Rezept des Gummibärchendatensatzes mit dem Modell in einem Workflow zusammen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>keras_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(keras_mod) <span class="sc">|&gt;</span> </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jetzt können mit mit der Funktion <code>fit()</code> das Modell rechnen. Wenn du Keras und Tensorflow nicht installiert hast, dann wird jetzt meist eine automatische Installation starten. Oder aber du hast dir vorher schon Tensorflow und Keras installiert. Schaue dazu gerne einmal den <a href="https://tensorflow.rstudio.com/install/">Quick start um Tensorflow zu installieren an</a>.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1/20
17/17 - 4s - loss: 0.6937 - 4s/epoch - 250ms/step
Epoch 2/20
17/17 - 0s - loss: 0.6930 - 84ms/epoch - 5ms/step
Epoch 3/20
17/17 - 0s - loss: 0.6926 - 67ms/epoch - 4ms/step
Epoch 4/20
17/17 - 0s - loss: 0.6921 - 66ms/epoch - 4ms/step
Epoch 5/20
17/17 - 0s - loss: 0.6917 - 69ms/epoch - 4ms/step
Epoch 6/20
17/17 - 0s - loss: 0.6913 - 67ms/epoch - 4ms/step
Epoch 7/20
17/17 - 0s - loss: 0.6908 - 66ms/epoch - 4ms/step
Epoch 8/20
17/17 - 0s - loss: 0.6905 - 65ms/epoch - 4ms/step
Epoch 9/20
17/17 - 0s - loss: 0.6900 - 66ms/epoch - 4ms/step
Epoch 10/20
17/17 - 0s - loss: 0.6896 - 65ms/epoch - 4ms/step
Epoch 11/20
17/17 - 0s - loss: 0.6892 - 65ms/epoch - 4ms/step
Epoch 12/20
17/17 - 0s - loss: 0.6887 - 66ms/epoch - 4ms/step
Epoch 13/20
17/17 - 0s - loss: 0.6883 - 65ms/epoch - 4ms/step
Epoch 14/20
17/17 - 0s - loss: 0.6878 - 67ms/epoch - 4ms/step
Epoch 15/20
17/17 - 0s - loss: 0.6873 - 66ms/epoch - 4ms/step
Epoch 16/20
17/17 - 0s - loss: 0.6868 - 65ms/epoch - 4ms/step
Epoch 17/20
17/17 - 0s - loss: 0.6864 - 65ms/epoch - 4ms/step
Epoch 18/20
17/17 - 0s - loss: 0.6859 - 65ms/epoch - 4ms/step
Epoch 19/20
17/17 - 0s - loss: 0.6853 - 65ms/epoch - 4ms/step
Epoch 20/20
17/17 - 0s - loss: 0.6847 - 65ms/epoch - 4ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>6/6 - 0s - 75ms/epoch - 13ms/step
6/6 - 0s - 17ms/epoch - 3ms/step</code></pre>
</div>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>keras_fit <span class="ot">&lt;-</span> keras_wflow <span class="sc">|&gt;</span> </span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  parsnip<span class="sc">::</span><span class="fu">fit</span>(gummi_train_data)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wenn der Algorithmus durchgelaufen ist, was schon ein paar Sekunden dauern kann, dann können wir danach das Modell nutzen um unser Geschlecht vorherzusagen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>keras_aug <span class="ot">&lt;-</span> <span class="fu">augment</span>(keras_fit, gummi_test_data) </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Wir lassen uns dann wieder die Konfusionsmatrix wiedergeben. Wir sehen, dass wir sehr mies dran sind. Wir haben eine nahezu zufällige Einteilung der Geschlechter durch die Vorhersage.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>keras_cm <span class="ot">&lt;-</span> keras_aug <span class="sc">|&gt;</span> </span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">conf_mat</span>(gender, .pred_class)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>keras_cm</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>          Truth
Prediction  m  w
         m 82 92
         w  0  1</code></pre>
</div>
</div>
<p>Was schon in der Konfusionsmatrix ziemlich mies aussah, wird natürlich auch so in der Zusammenfassung wiedergegeben.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>keras_cm <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             binary        0.474 
 2 kap                  binary        0.0101
 3 sens                 binary        1     
 4 spec                 binary        0.0108
 5 ppv                  binary        0.471 
 6 npv                  binary        1     
 7 mcc                  binary        0.0712
 8 j_index              binary        0.0108
 9 bal_accuracy         binary        0.505 
10 detection_prevalence binary        0.994 
11 precision            binary        0.471 
12 recall               binary        1     
13 f_meas               binary        0.641 </code></pre>
</div>
</div>
<p>Was sehen wir? Wir sehen, dass unsere Accuracy mit unter 50% schon mehr schlecht ist. Die Zuordnung der Geschlechter wird vom Algorithmus rein zufällig durchgeführt. Wir können daher nicht von einem guten Algorithmus sprechen. In <a href="#fig-class-keras-01" class="quarto-xref">Abbildung&nbsp;<span>76.6</span></a> sehen wir die gewollt schlechte ROC Kurve aus einem <code>keras</code> Algorithmus ohne Tuning. Warum war die nochmal gewollt schlecht? Ich will hier einmal zeigen, dass ein neuronales Netz aus dem Tensorflow Algorithmus meistens ohne ein Tuning sehr schlecht ist. Das kann sich aber durch ein Tuning sehr schnell drehen.</p>
<div class="cell" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>keras_aug <span class="sc">|&gt;</span> </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-class-keras-01" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-keras-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="classification-neural-networks_files/figure-html/fig-class-keras-01-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Abbildung&nbsp;76.6— ROC Kurve für den keras Algorithmus."><img src="classification-neural-networks_files/figure-html/fig-class-keras-01-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="480"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-keras-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.6— ROC Kurve für den <code>keras</code> Algorithmus.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Kann ich auch eine Kreuzvalidierung für Keras / Tensorflow durchführen?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ja, kannst du. Wenn du <em>nur</em> eine Kreuzvalidierung durchführen willst, findest du alles im <a href="classification-knn.html" class="quarto-xref"><span>Kapitel 73</span></a> für den <span class="math inline">\(k\)</span>-NN Algorithmus. Du musst dort nur den Workflow ändern und schon kannst du alles auch auf Keras / Tensorflow Algorithmus anwenden.</p>
</div>
</div>
</section>
<section id="tuning" class="level2" data-number="76.9">
<h2 data-number="76.9" class="anchored" data-anchor-id="tuning"><span class="header-section-number">76.9</span> Tuning</h2>
<p>Was heißt Tuning? Wie bei einem Auto können wir an verschiedenen Stellschrauben bei einem mathematischen Algorithmus schrauben. Welche Schrauben und Teile das sind, hängt dann wieder vom Algorithmus ab. Im Falle des xgboost Algorithmus können wir an folgenden Parametern drehen und jeweils schauen, was dann mit unserer Vorhersage passiert. Insgesamt hat der <a href="https://parsnip.tidymodels.org/reference/details_mlp_keras.html">keras Algorithmus fünf Tuningparameter</a>, wir wählen jetzt für uns hier drei aus. Ich nehme hier auch nur drei Parameter, da sich dann drei Parameter noch sehr gut visuell darstellen lassen. In der Anwendung wäre dann natürlich besser alle Parameter zu tunen, aber das dauert dann auch lange.</p>
<ul>
<li><code>hidden_units</code>, Anzahl der Ebenen (eng. <em>layer</em>) in dem neuronalen Netzwerk. Wie viele Ebenen soll unser Netzwerk haben? Oder auch wie <em>deep</em> soll das Netzwerk gebaut werden?</li>
<li><code>penalty</code>, ein Wert für die Regulierung des neuronalen Netzwerk.</li>
<li><code>epochs</code>, bezieht sich auf einen Zyklus durch die Layer für den gesamten Trainingsdatensatz. Wie oft rechnen wir den Trainingsdatensatz und trainieren unser Netzwerk?</li>
</ul>
<p>Nun ist es so, dass wir natürlich nicht händisch alle möglichen Kombinationen von der Anzahl der ausgewählten Variablen pro Baum, der kleinsten Knotengröße und der Anzahl der Bäume berechnen wollen. Das sind ziemlich viele Kombinationen und wir kommen dann vermutlich schnell durcheinander. Deshalb gibt es die Funktion <code>tune()</code> aus dem R Paket <code>{tune}</code>, die uns einen Prozess anbietet, das Tuning automatisiert durchzuführen.</p>
<p>Da ich nicht ewig warten wollte, habe ich noch das parallele Rechnern aktiviert, in dem ich mir die Anzahl an Rechenkernen minus eins wiedergeben habe lassen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>cores <span class="ot">&lt;-</span> parallel<span class="sc">::</span><span class="fu">detectCores</span>() <span class="sc">-</span> <span class="dv">1</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Als erstes müssen wir uns ein Objekt bauen, das aussieht wie ein ganz normales Modell in der Klassifikation. Aber wir ergänzen jetzt noch hinter jeder zu tunenden Option noch die Funktion <code>tune()</code>. Das sind die Parameter des Algorithmus, die wir später tunen wollen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>tune_spec <span class="ot">&lt;-</span> <span class="fu">mlp</span>(<span class="at">hidden_units =</span> <span class="fu">tune</span>(),</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">penalty =</span> <span class="fu">tune</span>(), </span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">epochs =</span> <span class="fu">tune</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"keras"</span>, <span class="at">num.threads =</span> cores) <span class="sc">|&gt;</span> </span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>) </span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>tune_spec</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Single Layer Neural Network Model Specification (classification)

Main Arguments:
  hidden_units = tune()
  penalty = tune()
  epochs = tune()

Engine-Specific Arguments:
  num.threads = cores

Computational engine: keras </code></pre>
</div>
</div>
<p>Jetzt bauen wir uns den Workflow indem wir statt unserem Modell, die Tuninganweisung in den Workflow reinnehmen. Echt simpel und straightforward. Das Rezept bleibt ja das Gleiche.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>gummi_tune_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(tune_spec) <span class="sc">|&gt;</span> </span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jetzt müssen wir noch alle Kombinationen aus den drei Parametern <code>hidden_units</code>, <code>penalty</code> und <code>epochs</code> ermitteln. Das macht die Funktion <code>grid_regular()</code>. Es gibt da noch andere Funktionen in dem R Paket <code>{tune}</code>, aber ich konzentriere mich hier auf die einfachste. Jetzt müssen wir noch die Anzahl an Kombinationen festlegen. Ich möchte für jeden Parameter fünf Werte tunen. Daher nutze ich hier die Option <code>levels = 5</code> auch damit hier die Ausführung nicht so lange läuft. Fange am besten mit <code>levels = 5</code> an und schaue, wie lange das zusammen mit der Kreuzvalidierung dann dauert. Dann kannst du die Levels noch hochschrauben. Beachte aber, dass mehr Level nur mehr <em>Zwischenschritte</em> bedeutet. Jede Option hat eine Spannweite <code>range</code>, die du dann anpassen musst, wenn du <em>höhere</em> Werte haben willst. Mehr Level würden nur mehr Zwischenschritte bedeuten.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>gummi_grid <span class="ot">&lt;-</span> <span class="fu">grid_regular</span>(<span class="fu">hidden_units</span>(<span class="at">range =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">100</span>)),</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">penalty</span>(),</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">epochs</span>(<span class="at">range =</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">200</span>)),</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>                           <span class="at">levels =</span> <span class="dv">5</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Das Tuning nur auf dem Trainingsdatensatz durchzuführen ist nicht so eine gute Idee. Deshalb nutzen wir hier auch die Kreuzvalidierung. Eigentlich ist eine 10-fache Kreuzvalidierung mit <span class="math inline">\(v=10\)</span> besser. Das dauert mir dann aber hier im Skript viel zu lange. Deshalb habe ich hier nur <span class="math inline">\(v=5\)</span> gewählt. Wenn du das Tuning rechnest, nimmst du natürlich eine 10-fach Kreuzvalidierung.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>gummi_folds <span class="ot">&lt;-</span> <span class="fu">vfold_cv</span>(gummi_train_data, <span class="at">v =</span> <span class="dv">5</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Nun bringen wir den Workflow zusammen mit dem Tuninggrid und unseren Sets der Kreuzvaidierung. Daher pipen wir den Workflow in die Funktion <code>tune_grid()</code>. Als Optionen brauchen wir die Kreuzvaldierungsdatensätze und das Tuninggrid. Wenn du <code>control_grid(verbose = TRUE)</code> wählst, dann erhälst du eine Ausgabe wie weit das Tuning gerade ist. <strong>Achtung!</strong>, das Tuning dauert seine Zeit. Im Falle des keras Algorithmus dauert das Tuning <strong>extrem lange</strong>, aber immer noch nur ein paar Stunden. Wenn du dann alle fünf Parameter des keras Algorithmustunen wollen würdest, dann würde die Berechnung Tage dauern. Deshalb ist ein Großerechner mit mehreren Kernen unabdingbar für die Nutzung von <em>deep learning</em> Du kannst das Ergebnis des simpleren Tunings auch in der Datei <code>gummi_xgboost_tune_res.rds</code> finden.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="ot">&lt;-</span> gummi_tune_wflow <span class="sc">|&gt;</span> </span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">tune_grid</span>(<span class="at">resamples =</span> gummi_folds,</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">grid =</span> gummi_grid,</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">control =</span> <span class="fu">control_grid</span>(<span class="at">verbose =</span> <span class="cn">FALSE</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Damit du nicht das Tuning durchlaufen lassen musst, habe ich das Tuning in die Datei <code>gummi_xgboost_tune_res.rds</code> abgespeichert und du kannst dann über die Funktion <code>read_rds()</code> wieder einlesen. Dann kannst du den R Code hier wieder weiter ausführen.</p>
<p>Nachdem das Tuning durchgelaufen ist, können wir uns über die Funktion <code>collect_metrics()</code>, die Ergebnisse des Tunings für jede Kombination der drei Parameter <code>hidden_units</code>, <code>penalty</code> und <code>epochs</code> wiedergeben lassen. Diese Ausgabe ist super unübersichtlich. Ich habe mich ja am Anfange des Abschnitts auch für drei Tuningparameter entschieden, da sich dann diese drei Parameter noch gut visualisieren lassen. Deshalb einmal die Abbildung der mittleren Accuarcy und der mittleren AUC-Werte über alle Kreuzvalidierungen.</p>
<div class="cell" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_metrics</span>() <span class="sc">|&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">hidden_units =</span> <span class="fu">as_factor</span>(hidden_units),</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">penalty =</span> <span class="fu">as_factor</span>(penalty)) <span class="sc">|&gt;</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(epochs, mean, <span class="at">color =</span> hidden_units, <span class="at">linetype =</span> penalty)) <span class="sc">+</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> .metric, <span class="at">scales =</span> <span class="st">"free"</span>, <span class="at">nrow =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>(<span class="at">labels =</span> scales<span class="sc">::</span><span class="fu">label_number</span>()) <span class="sc">+</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_okabeito</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-class-keras-02" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-keras-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="classification-neural-networks_files/figure-html/fig-class-keras-02-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Abbildung&nbsp;76.7— Tuning Kurven für den keras Algorithmus."><img src="classification-neural-networks_files/figure-html/fig-class-keras-02-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="576"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-keras-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.7— Tuning Kurven für den <code>keras</code> Algorithmus.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Damit wir nicht händisch uns die beste Kombination raussuchen müssen, können wir die Funktion <code>show_best()</code> nutzen.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show_best</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in show_best(gummi_tune_res): No value of `metric` was given; "roc_auc"
will be used.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 9
  hidden_units     penalty epochs .metric .estimator  mean     n std_err .config
         &lt;int&gt;       &lt;dbl&gt;  &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  
1           75    1   e- 5    200 roc_auc binary     0.899     5  0.0156 Prepro…
2          100    1   e- 5    200 roc_auc binary     0.898     5  0.0137 Prepro…
3           50    1   e- 5    200 roc_auc binary     0.897     5  0.0144 Prepro…
4           50    1   e-10    200 roc_auc binary     0.897     5  0.0149 Prepro…
5          100    3.16e- 8    200 roc_auc binary     0.896     5  0.0152 Prepro…</code></pre>
</div>
</div>
<p>Das war die Funktion <code>show_best()</code> aber wir können uns auch die gleich die besten Parameter nach der Accuracy raus ziehen. Das Rausziehen der besten Parameter macht für uns die Funktion <code>select_best()</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>best_keras <span class="ot">&lt;-</span> gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select_best</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in select_best(gummi_tune_res): No value of `metric` was given;
"roc_auc" will be used.</code></pre>
</div>
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>best_keras</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 4
  hidden_units penalty epochs .config               
         &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt; &lt;chr&gt;                 
1           75 0.00001    200 Preprocessor1_Model114</code></pre>
</div>
</div>
<p>Wir sehen, dass wir <code>hidden_units = 75</code> wählen sollten. Dann müssen wir als Penalty <code>penalty = 0.0000000001</code> nutzen. Die Anzahl an Durchläufen pro Training ist dann <code>epochs = 200</code>. Müssen wir jetzt die Zahlen wieder in ein Modell eingeben? Nein, müssen wir nicht. Mit der Funktion <code>finalize_workflow()</code> können wir dann die besten Parameter aus unserem Tuning gleich mit dem Workflow kombinieren. Dann haben wir unseren finalen, getunten Workflow. Du siehst dann auch in der Ausgabe, dass die neuen Parameter in dem keras Algorithmus übernommen wurden</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>final_gummi_wf <span class="ot">&lt;-</span> gummi_tune_wflow <span class="sc">|&gt;</span> </span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">finalize_workflow</span>(best_keras)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>final_gummi_wf </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>══ Workflow ════════════════════════════════════════════════════════════════════
Preprocessor: Recipe
Model: mlp()

── Preprocessor ────────────────────────────────────────────────────────────────
5 Recipe Steps

• step_impute_mean()
• step_impute_bag()
• step_range()
• step_dummy()
• step_nzv()

── Model ───────────────────────────────────────────────────────────────────────
Single Layer Neural Network Model Specification (classification)

Main Arguments:
  hidden_units = 75
  penalty = 1e-05
  epochs = 200

Engine-Specific Arguments:
  num.threads = cores

Computational engine: keras </code></pre>
</div>
</div>
<p>Jetzt bleibt uns nur noch der letzte Fit übrig. Wir wollen unseren finalen, getunten Workflow auf die Testdaten anwenden. Dafür gibt es dann auch die passende Funktion. Das macht für uns die Funktion <code>last_fit()</code>, die sich dann die Informationen für die Trainings- und Testdaten aus unserem Datensplit von ganz am Anfang extrahiert.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>final_fit <span class="ot">&lt;-</span> final_gummi_wf <span class="sc">|&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">last_fit</span>(gummi_data_split) </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>6/6 - 1s - 509ms/epoch - 85ms/step
6/6 - 0s - 18ms/epoch - 3ms/step</code></pre>
</div>
</div>
<p>Da wir immer noch eine Kreuzvaldierung rechnen, müssen wir dann natürlich wieder alle Informationen über alle Kreuzvaldierungsdatensätze einsammeln. Dann erhalten wir unsere beiden Gütekriterien für die Klassifikation des Geschlechts unser Studierenden nach dem keras Algorithmus. Die Zahlen sind schon gut für echte Daten. Eine Accuracy von 81% bedeutet das wir über acht von zehn Studierenden richtig klassifizieren. Die AUC ist auch schon fast hervorragend, wir bringen kaum Label durcheinander.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>final_fit <span class="sc">|&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_metrics</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 4
  .metric  .estimator .estimate .config             
  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               
1 accuracy binary         0.806 Preprocessor1_Model1
2 roc_auc  binary         0.910 Preprocessor1_Model1</code></pre>
</div>
</div>
<p>Dann bleibt uns nur noch die ROC Kurve zu visualisieren. Da wir wieder etwas faul sind, nutzen wir die Funktion <code>autoplot()</code>. Als Alternative geht natürlich auch das <a href="https://web.expasy.org/pROC/screenshots.html">R Paket <code>{pROC}</code></a>, was eine Menge mehr Funktionen und Möglichkeiten bietet.</p>
<div class="cell" data-layout-align="center">
<details open="" class="code-fold">
<summary>R Code [zeigen / verbergen]</summary>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>final_fit <span class="sc">|&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_predictions</span>() <span class="sc">|&gt;</span> </span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-class-keras-03" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-keras-03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="classification-neural-networks_files/figure-html/fig-class-keras-03-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Abbildung&nbsp;76.8— ROC Kurve für den keras Algorithmus nach der Kreuvalidierung und dem Tuning."><img src="classification-neural-networks_files/figure-html/fig-class-keras-03-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="480"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-keras-03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;76.8— ROC Kurve für den <code>keras</code> Algorithmus nach der Kreuvalidierung und dem Tuning.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Da wir eine ROC Kurve hier vorliegen haben, die sehr weit weg von der Diagonalen ist, haben wir sehr viele richtig vorhergesagte Studierende in unseren Testdaten. Unser Modell funktioniert um das Geschlecht von Studierenden anhand unserer Gummibärchendaten vorherzusagen. Besonders bei den neuronalen Netzwerken sieht man, wenn du die ROC Kurven vor und nach dem Tuning vergleichst, wie wichtig das Tuning ist. Dabei haben wir hier nur die abgespeckte Variante genutzt, da mein Rechner nicht länger laufen sollte.</p>
</section>
<section id="referenzen" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="referenzen">Referenzen</h2>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-kubat2017introduction" class="csl-entry" role="listitem">
Kubat M. 2017. An introduction to machine learning. Springer.
</div>
<div id="ref-mueller2019deep" class="csl-entry" role="listitem">
Mueller JP, Massaron L. 2019. Deep Learning for dummies. John Wiley &amp; Sons.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./classification-svm.html" class="pagination-link" aria-label="Support vector machines">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">75</span>&nbsp; <span class="chapter-title">Support vector machines</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./abspann.html" class="pagination-link" aria-label="Abspann">
        <span class="nav-page-text">Abspann</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb79" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo = FALSE}</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="in">pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc)</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="fu"># Neural networks {#sec-neural}</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>*Letzte Änderung am `r format(fs::file_info("classification-neural-networks.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>So, das war ein ganz schönes Brett, TensorFlow bzw. Keras auf dem Rechner zu installieren. Es gibt zwar einen <span class="co">[</span><span class="ot">Quick start um Tensorflow zu installieren</span><span class="co">](https://tensorflow.rstudio.com/install/)</span> aber dann hatte ich das schöne Problem der GPU auf dem macOS mit M1 Chip. Die Lösung für die <span class="co">[</span><span class="ot">Local GPU</span><span class="co">](https://tensorflow.rstudio.com/install/local_gpu)</span> hat mich auf dem macOS einen Tag Nerven gekostet. Das mag dann auf einem Windows Rechner anders sein bzw. andere Probleme verursachen. Schlussendlich ist die Nutzung von *neural networks* auf keinen Laptops vielleicht auch nicht so die beste Idee. Wir würden die Algorithmen eher auf Hochleistungsrechner durchführen und dann vermutlich eine Linuxdistribution verwenden. Dennoch werde ich hier einmal Tensorflow in R vorstellen. Die Pakete für die Integration von dem eigenständigen Algorithmus Tensorflow gibt es und wenn es dann mal installiert ist, funktioniert auch alles super. Da Tensorflow in Phyton programmiert ist, muss auch Phyton auf dem Rechner installiert sein. Du siehst also, es ist einiges einzurichten, damit wir Deep learning betreiben können. Hier möchte ich dann auch gerne auf @mueller2019deep verweisen, der zu dem Thema Deep learning einen guten Einstieg liefert. Denn wir machen hier eigentlich kein Deep learning, denn unsere neuronalen Netzwerke werden nicht viele Schichten haben, dass würde hier mein kleiner Rechner auch gar nicht schaffen.</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>Neben TensorFlow / Keras zeige ich auch nochmal die Anwendung der etwas veralteten R Pakete <span class="in">`{neuralnet}`</span> und <span class="in">`{nnet}`</span>. Wie immer musst du selber entscheiden, was du brauchst. Der Vorteil des Paketes <span class="in">`{nnet}`</span> ist, dass wir das Paket zum einen mit Rezepten und Tuning gut nutzen können. Zum anderen brauchen wir aber nicht diesen Installationsmarathon wie bei TensorFlow / Keras. Ich präsnetiere hier einfach die Auswahl und du schaust dann was passt.</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>Wir immer basiert dieser Text zum Teilen auch auf guten Tutorien im Netz. Zum einen ist es das Tutorium <span class="co">[</span><span class="ot">Understanding the Magic of Neural Networks</span><span class="co">](https://blog.ephorie.de/understanding-the-magic-of-neural-networks)</span> und das Tutorium <span class="co">[</span><span class="ot">A Beginner's Guide to Neural Networks and Deep Learning</span><span class="co">](https://wiki.pathmind.com/neural-network)</span>. Beide Tutorien sind in Englisch und Teile beider Tutorien hat auch diesen Text hier inspiriert. Nicht zu vergessen das Tutorium <span class="co">[</span><span class="ot">A Quick Introduction to Neural Networks</span><span class="co">](https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/)</span>.</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a><span class="fu">## Genutzte R Pakete</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>Wir wollen folgende R Pakete in diesem Kapitel nutzen.</span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo = TRUE}</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a><span class="in">pacman::p_load(tidyverse, tidymodels, magrittr, </span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a><span class="in">               janitor, keras, tensorflow, see,</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a><span class="in">               neuralnet, NeuralNetTools,</span></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a><span class="in">               OneR, readxl, </span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a><span class="in">               conflicted)</span></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a><span class="in">##</span></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(2025429)</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>An der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.</span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronale Netzwerke theoretisch</span></span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>Neuronale Netze ordnen *Inputs* den *Outputs* zu. Wir haben also Eingaben und erhalten eine Ausgabe zurück. Neuronale Netze finden Korrelationen. Neuronale Netzwerke sin auch als "universeller Approximator" bekannt, weil dad Netzwerk lernen kann, eine unbekannte Funktion $f(x) = y$ zwischen einer beliebigen Eingabe $x$ und einer beliebigen Ausgabe $y$ zu approximieren. Dabei gilt die Vorraussetzung, dass $x$ und $y$ in einem Zusammenhang durch Korrelation oder Kausalität stehen. Während des Lernprozesses findet ein neuronales Netz das richtige $f()$ oder die richtige Art der Umwandlung von $x$ in $y$, sei es $f(x) = 3x + 12$ oder $g(f(x)) = 9x - 0.1$. Wie du sehen kannst, gibt es auch bei dem neuralen Netzwerk eigentlich um ein Modell. Und unser Modell ist nicht anders, als eine multiple lineare Regresion in der klassischen Statistik.</span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-38"><a href="#cb79-38" aria-hidden="true" tabindex="-1"></a>Deep Learning ist der Name, den wir für *gestapelte neuronale Netze* verwenden und damit meinen wir Netze, die aus mehreren Schichten bestehen. Die einzelnen Schichten bestehen aus Knotenpunkten. Ein Knoten ist einfach ein Ort, an dem Berechnungen stattfinden, frei nach dem Vorbild eines Neurons im menschlichen Gehirn, das feuert, wenn es auf ausreichende Reize trifft. Ein Knoten kombiniert Eingaben aus den Daten mit einer Reihe von Koeffizienten oder Gewichten, die diese Eingaben entweder verstärken oder abschwächen. Somit geben dann die Knoten den Eingaben eine Bedeutung im Hinblick auf die Aufgabe die der Algorithmus zu lernen versucht. Häufig ist dies die Aufgabe die Eingabe zu finden die am hilfreichsten die Daten fehlerfrei klassifiziert? Diese Eingangsgewichtungen werden summiert, und die Summe wird dann durch die so genannte Aktivierungsfunktion eines Knotens geleitet, um zu bestimmen, ob und in welchem Ausmaß dieses Signal weiter durch das Netzwerk geleitet werden soll. Am Ende kann nur ein weitergeleitetes Signal das Endergebnis als einen Klassifizierungsvorgang beeinflussen. Wenn das Signal durch das Neuron durchläuft, ist dieses Neuron "aktiviert" worden.</span>
<span id="cb79-39"><a href="#cb79-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-40"><a href="#cb79-40" aria-hidden="true" tabindex="-1"></a>In @fig-class-nnet-01 ist ein Diagramm dargestellt, dass einen Knoten darstellt. Wir haben immer ein Inputlayer in dem wir hier drei Inputneuronen $x_1$, $x_2$ und $x_3$ finden. Das sind auch unsere Variablen in den Daten, die wir in das Modell stecken. Ganz oben finden wir noch als blaues Neuron ein Biasneuron dargestellt. Du kannst dir das Biasneuron wie den Intercept in der linearen Regresion vorstellen. Jedes der Neuronen hat ein Gewicht $w_0$ bis $w_3$. Diese Gewichte werden durch eine Netzinputfunktion in der Form $w_0 + w_1 x_1 + w_2x_3$ aufsummiert und dann an eine Aktivierungsfunktion weitergeleitet. Die Aktivierungsfunktion entscheidet hierbei, ob das Neuron aktiv wird und damit dann auch die Gewichte weiterleitet oder eben inaktiv wird. Es gibt viele Aktivierungsfunktionen, die alle unterschiedliche Eigenschaften haben. Im Folgenden sind einmal die wichtigisten Aktivierungsfunktionen beschrieben.</span>
<span id="cb79-41"><a href="#cb79-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-42"><a href="#cb79-42" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Die lineare Aktivierungsfunktion skaliert eine Eingabe einfach um einen Faktor, was bedeutet, dass es eine lineare Beziehung zwischen den Eingaben und der Ausgabe gibt.</span>
<span id="cb79-43"><a href="#cb79-43" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Sigmoid-Aktivierungsfunktion ist "S"-förmig. Sie kann der Ausgabe Nichtlinearität hinzufügen und gibt einen binären Wert von 0 oder 1 zurück.</span>
<span id="cb79-44"><a href="#cb79-44" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Die Tanh-Aktivierungsfunktion ist eine Erweiterung der sigmoidalen Aktivierungsfunktion. Daher kann Tanh verwendet werden, um der Ausgabe Nichtlinearität hinzuzufügen. Die Ausgabe liegt im Bereich von -1 bis 1. Die Tanh-Funktion verschiebt das Ergebnis der sigmoiden Aktivierungsfunktion.</span>
<span id="cb79-45"><a href="#cb79-45" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Die Rektifizierte lineare Einheits-Aktivierungsfunktion (RELU) ist eine der am häufigsten verwendeten Aktivierungsfunktionen. RELU wird bevorzugt in den Hidden Layer verwendet. Das Konzept ist linear vom Nullpunkt ausgehend. Die RELU fügt der Ausgabe auch Nichtlinearität hinzu. Allerdings kann das Ergebnis von 0 bis unendlich reichen.</span>
<span id="cb79-46"><a href="#cb79-46" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>Die Softmax-Aktivierungsfunktion ist eine Erweiterung der Sigmoid-Aktivierungsfunktion. Die Softmax-Funktion fügt der Ausgabe eine Nichtlinearität hinzu. Sie wird jedoch hauptsächlich für Klassifizierungen verwendet, bei denen mehrere Klassen von Ergebnissen berechnet werden können. Wir haben dann einen Multiclass-Fall vorliegen.</span>
<span id="cb79-47"><a href="#cb79-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-48"><a href="#cb79-48" aria-hidden="true" tabindex="-1"></a>Im Prinzip ist eine Aktivierungsfunktion nichts anderes als die Link Funktion in der multiplen linearen Regression. <span class="co">[</span><span class="ot">Aber das geht dann hier zu weit.</span><span class="co">](https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/)</span> Häufig wird dann die Netzinputfunktion und die Aktivierungsfunktion in einem Knotenpunkt dargestellt.</span>
<span id="cb79-49"><a href="#cb79-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-50"><a href="#cb79-50" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-51"><a href="#cb79-51" aria-hidden="true" tabindex="-1"></a>Mehr über Aktivierungsfunktionen kannst du im Tutorium <span class="co">[</span><span class="ot">Neural Networks In a Nutshell</span><span class="co">](https://medium.com/analytics-vidhya/neural-networks-in-a-nutshell-bb013f40197d)</span> erfahren.</span>
<span id="cb79-52"><a href="#cb79-52" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-53"><a href="#cb79-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-54"><a href="#cb79-54" aria-hidden="true" tabindex="-1"></a><span class="al">![Darstellung von drei Inputneuronen $x_1, x_2, x_3$, einem Biasneuron $1$ mit den jeweiligen weitergeleiteten Gewichten $w_1, w_2, w_3$ und $w_0$. Die Summierungsfunktion sowie die Aktivierungsfunktion werden meist in einen gemeinsamen Knoten dargestellt. Hier sind beide Formen einmal abgebildet. Wenn das Neuron aktiviert ist, gibt es die Summe als Output weiter.](images/class-neuralnet-01.png)</span>{#fig-class-nnet-01 fig-align="center" width="100%"}</span>
<span id="cb79-55"><a href="#cb79-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-56"><a href="#cb79-56" aria-hidden="true" tabindex="-1"></a>In der @fig-class-nnet-02 sehen wir dann ein ganze Netz an Neuronen. Wir haben ein Inputlayer und mehrere Hiddenlayer die am Ende dann in ein Outputlayer enden. Meistens wollen wir eine binäre Klassifikation rechnen, so dass am Ende dann zwi Outputknoten stehen. Die Hiddenlayer können unterschiedlich viele Knoten enthalten und meistens gibt es auch mehrere Abstufungen. Das heißt wir fnagen mit mehreren Knoten pro Hiddenlayer an und reduzieren dann die Anzahl der Knoten pro Hiddenlayer über die Breite des neuronalen Netzwerkes.</span>
<span id="cb79-57"><a href="#cb79-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-58"><a href="#cb79-58" aria-hidden="true" tabindex="-1"></a><span class="al">![Darstellung von drei Inputneuronen $x_1, x_2, x_3$ ohne ein Biasneuron. Die drei Inputbeurnen leiten ihre Gewichte an die Hidden Layer Neoronen weiter. In jedem diesem Neuron findet eine Summiierung in eine eventuelle Aktivierung statt. Aktivierte Neuronen leiten die Summation als Gewichte dann an weitere Hidden Layer Neuronen weiter. Am Ende findet eine Entscheidung in den Outputneuronen statt.](images/class-neuralnet-02.png)</span>{#fig-class-nnet-02 fig-align="center" width="100%"}</span>
<span id="cb79-59"><a href="#cb79-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-60"><a href="#cb79-60" aria-hidden="true" tabindex="-1"></a>Spannenderweise sind viele Dinge in einem neuronalen Netzwerk nichts anderes als eine intelligente Hintereinanderschaltung von multiple linearen Regressionen Deshalb gibt es in der @tbl-class-nn-01 auch einmal eine Übersicht der Begriffe in dem Sprachraum der neuronalen Netze und der klassischen logistischen Regression. Wir sehen hier einiges an gleichen Konzepten.</span>
<span id="cb79-61"><a href="#cb79-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-62"><a href="#cb79-62" aria-hidden="true" tabindex="-1"></a>| Neural network      | Logistic regression (eng.) | Logistische Regression (deu.) |</span>
<span id="cb79-63"><a href="#cb79-63" aria-hidden="true" tabindex="-1"></a>|:--------------------|:---------------------------|-------------------------------|</span>
<span id="cb79-64"><a href="#cb79-64" aria-hidden="true" tabindex="-1"></a>| Activation function | Link function              | Link Funktion                 |</span>
<span id="cb79-65"><a href="#cb79-65" aria-hidden="true" tabindex="-1"></a>| Weights             | Coefficients / Slope       | Koeffizienten / Steigung      |</span>
<span id="cb79-66"><a href="#cb79-66" aria-hidden="true" tabindex="-1"></a>| Bias                | Intercept                  | Intercept                     |</span>
<span id="cb79-67"><a href="#cb79-67" aria-hidden="true" tabindex="-1"></a>| Variance            | Residuals                  | Fehler / Residuen             |</span>
<span id="cb79-68"><a href="#cb79-68" aria-hidden="true" tabindex="-1"></a>| Learning            | Fitting                    | Modellieren                   |</span>
<span id="cb79-69"><a href="#cb79-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-70"><a href="#cb79-70" aria-hidden="true" tabindex="-1"></a>: Welche Begriff in dem Sprachraum der neuronalen Netze lässt sich zu welchem Begriff in der logistischen Regression zuordnen? {#tbl-class-nn-01}</span>
<span id="cb79-71"><a href="#cb79-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-72"><a href="#cb79-72" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-73"><a href="#cb79-73" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">What is the role of the bias in neural networks?</span><span class="co">](https://stackoverflow.com/questions/2480650/what-is-the-role-of-the-bias-in-neural-networks)</span></span>
<span id="cb79-74"><a href="#cb79-74" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-75"><a href="#cb79-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-76"><a href="#cb79-76" aria-hidden="true" tabindex="-1"></a>Wenn ein neuronales Netz auf dem Trainingssatz trainiert wird, wird es mit einer Reihe von Gewichten initialisiert. Diese Gewichte werden dann während der Trainingsperiode optimiert und die optimalen Gewichte werden erzeugt. Das ist ein wichtiger Punkt. Wir erzeugen zufällig die Gewichte am Anfang und lassen uns dann die Gewichte mehr oder minder zufällig weiteroptimieren. Sonst würden ja bei jedem Knoten die gleichen Zahlen rauskommen. Wir optimieren aber nicht nur einmal sondern meistens mehrfach. Das heißt wir lassen das neuronale Netzwerk mehrfach wachsen und optimieren bei jedem Wachstum die Gewicte so, dass der Fehler geringer wird.</span>
<span id="cb79-77"><a href="#cb79-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-78"><a href="#cb79-78" aria-hidden="true" tabindex="-1"></a>Die Epoche (eng. *epoch*) ist einer der Eingabeparameter des Algorithmus. Stelle dir die Epoche als eine Schleife vor. Die Schleife bestimmt, wie oft ein Lernalgorithmus die Gewichte aktualisiert. Wenn der Wert der Epoche 1 ist, bedeutet dies, dass das neuronale Netz einmal läuft um die Gewichte zu aktualisieren. Wenn die Epoche einen Wert von 5 hat, wird das neuronale Netzwerk fünfmal aktualisiert. Hier ist der Unterschied zu den Entscheidungsbäumen auffällig. Entscheidungsbäume werden in einem Random Forest gemittelt. Die Epochen eines neuronalen Netzwerkes hängen aber miteinander zusammen.</span>
<span id="cb79-79"><a href="#cb79-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-80"><a href="#cb79-80" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Ein neuronales Netz ist eine korrigierende Rückkopplungsschleife, die Gewichte belohnt, die seine korrekten Vermutungen unterstützen, und Gewichte bestraft, die es zu Fehlern verleiten.</span><span class="co">]</span>{.aside}</span>
<span id="cb79-81"><a href="#cb79-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-82"><a href="#cb79-82" aria-hidden="true" tabindex="-1"></a>Damit wir wissen, ob unser Netzwerk über die Epochen besser wird, brauchen wir eine Verlustfunktion (eng. *loss function*). Die Verlustfunktion wird auch als Kostenfunktion (eng. *cost function*) bezeichnet. Sie errechnet den Fehler. Um genau zu sein, ist die Kostenfunktion der Durchschnitt der Verlustfunktionen. Dies ist die Funktion, die der Optimierungsalgorithmus zu minimieren versucht. Es gibt eine große Anzahl von Verlustfunktionen, wie den mittleren quadratischen Fehler oder die binäre Kreuzentropie.</span>
<span id="cb79-83"><a href="#cb79-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-84"><a href="#cb79-84" aria-hidden="true" tabindex="-1"></a>Die Verlustfunktion sagt dem neuronalen Netz im Wesentlichen, welche Maßnahmen es ergreifen muss, um die Accuracy zu verbessern. Diese Information wird dann verwendet, um genaueren Gewichte zu erzeugen. Danach kann dann das neuronale Netz kann die Daten erneut weiterverarbeiten.</span>
<span id="cb79-85"><a href="#cb79-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-86"><a href="#cb79-86" aria-hidden="true" tabindex="-1"></a>Am Rande möchte ich noch die Begriffe Forward Propagation und Back Propagation erwähnen. Beide Begriffe beschreiben, wie das Lernen innerhalb eines neuronalen Netzwerk abläuft. Klassisch ist die Forward Propagation. Dabei reicht ein Knoten die Informationen an den nächsten Knoten weiter. Das Lernen erfolgt *vorwärts*. Die andere Möglichkeit ist, das Netzwerk wachsen zu lassen und dann *rückwärts* die Gewichte der Knoten zu verbessern. Wir haben dann eine Back Propagation vorliegen.</span>
<span id="cb79-87"><a href="#cb79-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-88"><a href="#cb79-88" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronales Netz anschaulicher</span></span>
<span id="cb79-89"><a href="#cb79-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-90"><a href="#cb79-90" aria-hidden="true" tabindex="-1"></a>In unserem folgenden Beispiel ist Rotkäppchen das neuronale Netz. Rotkäppchen hat folgende Informationen zu drei möglichen Outcomes vorliegen. Rotkäppchen weiß also, dass es im Wald oder im Haus drei Personen treffen kann. Entweder trifft sie die Großmutter, den großen, bösen Wolf oder den Holzfäller. Gott sei Dank kennt Rotkäppchen die Eigenschaften der drei Charaktere und kann daran sich folgende Matrix aufbauen. Wir lesen die Tabelle wie folgt, wir haben die Spalte <span class="in">`grosse_ohren`</span> und wir haben drei Werte mit der Spalte assoziiert. Wir wissen aber nicht welche Zeile welcher Charakter ist. Wir wollen die Zuordnung einmal mit dem neuronalen Netzwerk durchführen.</span>
<span id="cb79-91"><a href="#cb79-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-94"><a href="#cb79-94" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-95"><a href="#cb79-95" aria-hidden="true" tabindex="-1"></a>little_red_tbl <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">grosse_ohren =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>), </span>
<span id="cb79-96"><a href="#cb79-96" aria-hidden="true" tabindex="-1"></a>                         <span class="at">grosse_augen =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb79-97"><a href="#cb79-97" aria-hidden="true" tabindex="-1"></a>                         <span class="at">grosse_zaehne =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>) , </span>
<span id="cb79-98"><a href="#cb79-98" aria-hidden="true" tabindex="-1"></a>                         <span class="at">freundlich =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb79-99"><a href="#cb79-99" aria-hidden="true" tabindex="-1"></a>                         <span class="at">faltig =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), </span>
<span id="cb79-100"><a href="#cb79-100" aria-hidden="true" tabindex="-1"></a>                         <span class="at">gutaussehend =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb79-101"><a href="#cb79-101" aria-hidden="true" tabindex="-1"></a>                         <span class="at">renn_weg =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb79-102"><a href="#cb79-102" aria-hidden="true" tabindex="-1"></a>                         <span class="at">schrei =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb79-103"><a href="#cb79-103" aria-hidden="true" tabindex="-1"></a>                         <span class="at">ruf_holzfaeller =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb79-104"><a href="#cb79-104" aria-hidden="true" tabindex="-1"></a>                         <span class="at">plaudere =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb79-105"><a href="#cb79-105" aria-hidden="true" tabindex="-1"></a>                         <span class="at">geh_hin =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), </span>
<span id="cb79-106"><a href="#cb79-106" aria-hidden="true" tabindex="-1"></a>                         <span class="at">biete_essen =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb79-107"><a href="#cb79-107" aria-hidden="true" tabindex="-1"></a>                         <span class="at">rettung =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb79-108"><a href="#cb79-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-109"><a href="#cb79-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-110"><a href="#cb79-110" aria-hidden="true" tabindex="-1"></a>In der @tbl-little_red_data sehen wir die Daten nbochmal in das Input Layer und das Output Layer aufgespaltet. Die Frage ist, was soll Rotkäppchen tun, wenn die die Eigenschaften des Input Layers beobachtet? Wir wollen jetzt anhand eines neuronalen Netzes die Input Layer dem Output Layer zuordnen.</span>
<span id="cb79-111"><a href="#cb79-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-114"><a href="#cb79-114" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-115"><a href="#cb79-115" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb79-116"><a href="#cb79-116" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-117"><a href="#cb79-117" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-118"><a href="#cb79-118" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-little_red_data</span></span>
<span id="cb79-119"><a href="#cb79-119" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Die beiden Datensätze für das neuronale Netzwerk. Wie lässt sich der Input sinnvoll mit dem Output verbinden? Wir geben dafür drei Hidden Layers vor, die dann die Charaktere Wolf, Goßmutter und den Holzfäller repräsentieren."</span></span>
<span id="cb79-120"><a href="#cb79-120" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-subcap: </span></span>
<span id="cb79-121"><a href="#cb79-121" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Daten des Input Layers."</span></span>
<span id="cb79-122"><a href="#cb79-122" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Daten des Output Layers."</span></span>
<span id="cb79-123"><a href="#cb79-123" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb79-124"><a href="#cb79-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-125"><a href="#cb79-125" aria-hidden="true" tabindex="-1"></a>little_red_tbl <span class="sc">|&gt;</span> </span>
<span id="cb79-126"><a href="#cb79-126" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(grosse_ohren<span class="sc">:</span>gutaussehend) <span class="sc">|&gt;</span> </span>
<span id="cb79-127"><a href="#cb79-127" aria-hidden="true" tabindex="-1"></a>  <span class="fu">t</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-128"><a href="#cb79-128" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="at">align =</span> <span class="st">"c"</span>, <span class="st">"pipe"</span>)</span>
<span id="cb79-129"><a href="#cb79-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-130"><a href="#cb79-130" aria-hidden="true" tabindex="-1"></a>little_red_tbl <span class="sc">|&gt;</span> </span>
<span id="cb79-131"><a href="#cb79-131" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(renn_weg<span class="sc">:</span>rettung) <span class="sc">|&gt;</span> </span>
<span id="cb79-132"><a href="#cb79-132" aria-hidden="true" tabindex="-1"></a>  <span class="fu">t</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-133"><a href="#cb79-133" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="at">align =</span> <span class="st">"c"</span>, <span class="st">"pipe"</span>)</span>
<span id="cb79-134"><a href="#cb79-134" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-135"><a href="#cb79-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-136"><a href="#cb79-136" aria-hidden="true" tabindex="-1"></a>Im Folgenden siehst du einmal den Code für das simple neuronale Netzwerk. Wir haben die Spalten des Input Layer durch das <span class="in">`~`</span> von den Spalten des Output Layers getrennt. Darüber hinaus wollen wir noch drei Hidden Layer Knoten haben. Jeweils einen Knoten für jeden unserer drei Charaktere.</span>
<span id="cb79-137"><a href="#cb79-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-140"><a href="#cb79-140" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-141"><a href="#cb79-141" aria-hidden="true" tabindex="-1"></a>neuralnetwork <span class="ot">&lt;-</span> <span class="fu">neuralnet</span>(renn_weg <span class="sc">+</span> schrei <span class="sc">+</span> ruf_holzfaeller <span class="sc">+</span> plaudere <span class="sc">+</span> </span>
<span id="cb79-142"><a href="#cb79-142" aria-hidden="true" tabindex="-1"></a>                             geh_hin <span class="sc">+</span> biete_essen <span class="sc">+</span> rettung <span class="sc">~</span> </span>
<span id="cb79-143"><a href="#cb79-143" aria-hidden="true" tabindex="-1"></a>                             grosse_ohren <span class="sc">+</span> grosse_augen <span class="sc">+</span> grosse_zaehne <span class="sc">+</span> </span>
<span id="cb79-144"><a href="#cb79-144" aria-hidden="true" tabindex="-1"></a>                             freundlich <span class="sc">+</span> faltig <span class="sc">+</span> gutaussehend,</span>
<span id="cb79-145"><a href="#cb79-145" aria-hidden="true" tabindex="-1"></a>                           <span class="at">data =</span> little_red_tbl, <span class="at">hidden =</span> <span class="dv">3</span>, </span>
<span id="cb79-146"><a href="#cb79-146" aria-hidden="true" tabindex="-1"></a>                           <span class="at">exclude =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">15</span>, <span class="dv">22</span>, <span class="dv">26</span>, <span class="dv">30</span>, <span class="dv">34</span>, <span class="dv">38</span>, <span class="dv">42</span>, <span class="dv">46</span>), </span>
<span id="cb79-147"><a href="#cb79-147" aria-hidden="true" tabindex="-1"></a>                           <span class="at">lifesign =</span> <span class="st">"none"</span>, <span class="at">linear.output =</span> <span class="cn">FALSE</span>)</span>
<span id="cb79-148"><a href="#cb79-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-149"><a href="#cb79-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-150"><a href="#cb79-150" aria-hidden="true" tabindex="-1"></a>In @fig-class-nn-01 sehen wir das neuronale Netzwerk einmal abgebildet. Da wir uns so ein simples Beispiel ausgedacht haben, können wir das Beispiel hier auch einmal visualisieren. Wir sehen hier nochmal auf der linken Seite das Input Layer und auf der rechten Seite das Output Layer. Die schwarzen, dicken Linien stellen die bedeutenden Gewichte dar. Wir sehen also, dass <span class="in">`grosse_ohren`</span>, <span class="in">`grosse_augen`</span> und <span class="in">`grosse_zaehne`</span> mit dem Hidden Layer H3 verbunden sind. Von dem Hidden Layer H3 gehen dann die Linien zu <span class="in">`renn_weg`</span>, <span class="in">`schrei`</span> und <span class="in">`ruf_holzfaeller`</span>. Wir sehen daran, dass das neuronale Netzwerk in H3 den großen, bösen Wolf erkannt hat. Da wir jetzt sehen, dass H1 hauptsächlich <span class="in">`faltig`</span> ist, können wir hier auf die Repräsentation der Großmutter schließen. Ebenso ist H2 <span class="in">`gutaussehend`</span>, so dass wir hierauf die Repräsenrtation des Holzfällers schließen können. Die Zuordnungen des Output Layers passen dementsprechend dann auch.</span>
<span id="cb79-151"><a href="#cb79-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-154"><a href="#cb79-154" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-155"><a href="#cb79-155" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-156"><a href="#cb79-156" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-157"><a href="#cb79-157" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-158"><a href="#cb79-158" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-nn-01</span></span>
<span id="cb79-159"><a href="#cb79-159" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-160"><a href="#cb79-160" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 6</span></span>
<span id="cb79-161"><a href="#cb79-161" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 7</span></span>
<span id="cb79-162"><a href="#cb79-162" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Visualisierung des neuronalen Netzwerkes mit drei vorgebenen Hidden Layers. Die Hidden Layers repräsentieren in diesem Beispiel die Characktere Wolf, Großmutter und den Holzfäller."</span></span>
<span id="cb79-163"><a href="#cb79-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-164"><a href="#cb79-164" aria-hidden="true" tabindex="-1"></a><span class="fu">plotnet</span>(neuralnetwork, <span class="at">bias =</span> <span class="cn">FALSE</span>, <span class="at">pad_x =</span> <span class="fl">0.73</span>)</span>
<span id="cb79-165"><a href="#cb79-165" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-166"><a href="#cb79-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-167"><a href="#cb79-167" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronales Netz mathematischer</span></span>
<span id="cb79-168"><a href="#cb79-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-169"><a href="#cb79-169" aria-hidden="true" tabindex="-1"></a>Das folgende etwas mathematische Beispiel ist von @kubat2017introduction, pp. 65-73, entnommen. Ich habe das Beispiel dann für R adaptiert, so dass wir hier auch R Code zum ausprobieren haben. Bevor wir damit anfangen, hier nochmal auf einfache Weise erklärt, was beim Lernen mit einem neuronalen Netzwerk geschieht.</span>
<span id="cb79-170"><a href="#cb79-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-171"><a href="#cb79-171" aria-hidden="true" tabindex="-1"></a>Eingaben werden als Inputs in das Netz eingegeben. Die Koeffizienten bzw. Gewichte ordnen diese Eingabe einer Reihe von Vermutungen zu, die das Netz am Ende anstellt. Hierbei erfolgt die Zuornung mehr oder minder zufällig. Wir beginnen ja auch mit einem Satz an zufällig ausgewählten Gewichten, die wir dann innerhalb des neuronalen Netzwerks optimieren wollen.</span>
<span id="cb79-172"><a href="#cb79-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-173"><a href="#cb79-173" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-174"><a href="#cb79-174" aria-hidden="true" tabindex="-1"></a>Eingabe * Gewichtung = Vermutung</span>
<span id="cb79-175"><a href="#cb79-175" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-176"><a href="#cb79-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-177"><a href="#cb79-177" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-178"><a href="#cb79-178" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-179"><a href="#cb79-179" aria-hidden="true" tabindex="-1"></a>input * weight = guess</span>
<span id="cb79-180"><a href="#cb79-180" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-181"><a href="#cb79-181" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-182"><a href="#cb79-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-183"><a href="#cb79-183" aria-hidden="true" tabindex="-1"></a>Die gewichtete Eingabe führt zu einer Vermutung darüber, was die Eingabe ist. Das neuronale Netz vergleicht dann seine Vermutung mit einer Wahrheit über die Daten und berechnet daraus einen Fehler. Wir wissen, dass wir zehn kranke und acht gesunde Ferkel in dem Datensatz haben, wie viele kann das neuronale Netzwerk anhand der Gewichte und dem Input richtig zuordnen oder eben falsch zuordnen?</span>
<span id="cb79-184"><a href="#cb79-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-185"><a href="#cb79-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-186"><a href="#cb79-186" aria-hidden="true" tabindex="-1"></a>Wahrheit - Vermutung = Fehler</span>
<span id="cb79-187"><a href="#cb79-187" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-188"><a href="#cb79-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-189"><a href="#cb79-189" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-190"><a href="#cb79-190" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-191"><a href="#cb79-191" aria-hidden="true" tabindex="-1"></a>truth - guess = error</span>
<span id="cb79-192"><a href="#cb79-192" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-193"><a href="#cb79-193" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-194"><a href="#cb79-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-195"><a href="#cb79-195" aria-hidden="true" tabindex="-1"></a>Die Differenz zwischen der Schätzung des neuronalen Netzes und der Wahrheit ist der Fehler. Das Netzwerk misst diesen Fehler und minimiert den Fehler über das Modell, indem es die Gewichte in dem Maße anpasst, wie sie zum Fehler beigetragen haben.</span>
<span id="cb79-196"><a href="#cb79-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-197"><a href="#cb79-197" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-198"><a href="#cb79-198" aria-hidden="true" tabindex="-1"></a>Fehler * Beitrag\; des\; Gewichts\; zum\; Fehler = Anpassung</span>
<span id="cb79-199"><a href="#cb79-199" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-200"><a href="#cb79-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-201"><a href="#cb79-201" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-202"><a href="#cb79-202" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-203"><a href="#cb79-203" aria-hidden="true" tabindex="-1"></a>error * weight's\; contribution\; to\; error = adjustment</span>
<span id="cb79-204"><a href="#cb79-204" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-205"><a href="#cb79-205" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-206"><a href="#cb79-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-207"><a href="#cb79-207" aria-hidden="true" tabindex="-1"></a>Die drei obigen Formeln beschreiben die drei Hauptfunktionen neuronaler Netze: Bewertung der Eingaben, Berechnung des Verlusts und Aktualisierung des Modells, um den dreistufigen Prozess von vorne zu beginnen. Ein neuronales Netz ist eine korrigierende Rückkopplungsschleife, die Gewichte belohnt, die seine korrekten Vermutungen unterstützen, und Gewichte bestraft, die es zu Fehlern verleiten.</span>
<span id="cb79-208"><a href="#cb79-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-209"><a href="#cb79-209" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-210"><a href="#cb79-210" aria-hidden="true" tabindex="-1"></a>Das Buch <span class="co">[</span><span class="ot">An Introduction to Machine Learning</span><span class="co">](https://link.springer.com/book/10.1007/978-3-319-63913-0)</span> kannst du dir an der HS Osnabrück als PDF über die Hochschule runterladen.</span>
<span id="cb79-211"><a href="#cb79-211" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-212"><a href="#cb79-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-213"><a href="#cb79-213" aria-hidden="true" tabindex="-1"></a>Betrachten wir also einmal ein simples Datenbeispiel von vier Beobachtungen mit jeweils einem $x_1$ und einem $x_2$ Wert als Prädiktor. Der Wert den $x_1$ oder $x_2$ annehmen können sind binär. Wir haben also für unsere beiden Prädiktoren nur $0/1$ Werte vorliegen. Unser Label $y$ ist ebenfalls binär. Entweder ist die betreffende Beobachtung erkrankt oder eben nicht. In unserem Beispiel sind die ersten beiden Beobachtungen nicht erkrankt und die letzten beiden Beobachtungen sind erkrankt. Schauen wir uns den Datensatz einmal an.</span>
<span id="cb79-214"><a href="#cb79-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-217"><a href="#cb79-217" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-218"><a href="#cb79-218" aria-hidden="true" tabindex="-1"></a>data_tbl <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb79-219"><a href="#cb79-219" aria-hidden="true" tabindex="-1"></a>                   <span class="at">x_1 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb79-220"><a href="#cb79-220" aria-hidden="true" tabindex="-1"></a>                   <span class="at">x_2 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb79-221"><a href="#cb79-221" aria-hidden="true" tabindex="-1"></a>data_tbl</span>
<span id="cb79-222"><a href="#cb79-222" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-223"><a href="#cb79-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-224"><a href="#cb79-224" aria-hidden="true" tabindex="-1"></a>Faktisch wollen wir jetzt eine Grade durch die Punkte legen, so dass wir die gesunden von den kranken Beobachtungen trennen können. Praktisch machen wir das mit einer linearen Funktion $h(x)$, die uns anhand von $x_1$ und $x_2$ eine Aussagen über den Status von $y$ ermöglicht. Wir erhalten zuerst einen *numerischen* Wert, den wir dann noch mit einer Regel in eine $0/1$ Entscheidung umwandeln müssen.</span>
<span id="cb79-225"><a href="#cb79-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-226"><a href="#cb79-226" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-227"><a href="#cb79-227" aria-hidden="true" tabindex="-1"></a>h(x) \sim w_0 + w_1 \cdot x_1 + w_2 \cdot x_2</span>
<span id="cb79-228"><a href="#cb79-228" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-229"><a href="#cb79-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-230"><a href="#cb79-230" aria-hidden="true" tabindex="-1"></a>Nun können wir die Formel nochmal kompakter schreiben.</span>
<span id="cb79-231"><a href="#cb79-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-232"><a href="#cb79-232" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-233"><a href="#cb79-233" aria-hidden="true" tabindex="-1"></a>h(x) \sim \sum_{i = 0}^{n=2} w_i x_i</span>
<span id="cb79-234"><a href="#cb79-234" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-235"><a href="#cb79-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-236"><a href="#cb79-236" aria-hidden="true" tabindex="-1"></a>Wir drücken im Folgenden damit aus, das wir auch die Gewichte $w_i$ mit den einzelnen $x_i$ multiplizieren und anschließend aufsummieren. Anhand der aufsummierten Zahl aus $h(x)$ können wir dann eine Entscheidung für $0/1$ treffen. In unserem Beispiel entscheiden wir uns dazu, das wir $y=0$ annehmen wenn $h(x) &lt; 0$ ist oder aber $y=1$ annehmen, wenn $h(x) \geq 0$ ist. Wir können das einmal formal aufschreiben.</span>
<span id="cb79-237"><a href="#cb79-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-238"><a href="#cb79-238" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-239"><a href="#cb79-239" aria-hidden="true" tabindex="-1"></a>h(x)= </span>
<span id="cb79-240"><a href="#cb79-240" aria-hidden="true" tabindex="-1"></a>\begin{cases}</span>
<span id="cb79-241"><a href="#cb79-241" aria-hidden="true" tabindex="-1"></a>    1,&amp; \text{wenn } h(x)\geq 0<span class="sc">\\</span></span>
<span id="cb79-242"><a href="#cb79-242" aria-hidden="true" tabindex="-1"></a>    0,              &amp; \text{ansonsten}</span>
<span id="cb79-243"><a href="#cb79-243" aria-hidden="true" tabindex="-1"></a>\end{cases}</span>
<span id="cb79-244"><a href="#cb79-244" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb79-245"><a href="#cb79-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-246"><a href="#cb79-246" aria-hidden="true" tabindex="-1"></a>Nichts anders ist dann auch unser Neuron, was die Entscheidungen trifft. Wir haben vier verschiedene $x_1$ und $x_2$ Kombinationen und gewichten diese beiden $x$ dann noch einem Gewichtsvektor. Wenn wir dann als aufsummiertes Ergebnis eine Zahl größer als $0$ erhalten, dann gibt unser Neuron als Klassifikationsergebnis ein $1$ wieder.</span>
<span id="cb79-247"><a href="#cb79-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-250"><a href="#cb79-250" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-251"><a href="#cb79-251" aria-hidden="true" tabindex="-1"></a>neuron <span class="ot">&lt;-</span> <span class="cf">function</span>(input, weights) {<span class="fu">ifelse</span>(input <span class="sc">%*%</span> weights <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)}</span>
<span id="cb79-252"><a href="#cb79-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-253"><a href="#cb79-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-254"><a href="#cb79-254" aria-hidden="true" tabindex="-1"></a>Wir brauchen also zum einen die Inputmatrix. Die bauen wir uns einmal mit der Funktion <span class="in">`model.matrix()`</span>. Dann haben wir drei Spalten für jedes Gewicht $w$. Dann brauchen wir noch die drei Gewichte $w_0$, $w_1$ und $w_2$. Nichts anders als der Intercept und die Steigung in einem linearen Modell.</span>
<span id="cb79-255"><a href="#cb79-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-258"><a href="#cb79-258" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-259"><a href="#cb79-259" aria-hidden="true" tabindex="-1"></a>input <span class="ot">&lt;-</span> data_tbl <span class="sc">%$%</span></span>
<span id="cb79-260"><a href="#cb79-260" aria-hidden="true" tabindex="-1"></a>  <span class="fu">model.matrix</span>(<span class="sc">~</span> x_1 <span class="sc">+</span> x_2)</span>
<span id="cb79-261"><a href="#cb79-261" aria-hidden="true" tabindex="-1"></a>input</span>
<span id="cb79-262"><a href="#cb79-262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-263"><a href="#cb79-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-264"><a href="#cb79-264" aria-hidden="true" tabindex="-1"></a>Wir wählen *zufällig* drei Gewichte aus, die wir dann in unser Modell geben. Die Gwichte werden dann innerhalb des neuronalen Netzwerks dann optimiert. Die Wahl der passenden Gewichte ist dann noch eine Frage für sich, aber hier haben wir diese drei Werte ausgewählt.</span>
<span id="cb79-265"><a href="#cb79-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-268"><a href="#cb79-268" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-269"><a href="#cb79-269" aria-hidden="true" tabindex="-1"></a>weights <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>)</span>
<span id="cb79-270"><a href="#cb79-270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-271"><a href="#cb79-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-272"><a href="#cb79-272" aria-hidden="true" tabindex="-1"></a>Dann brauchen wir noch ein $\eta$, dass beschreibt, um wie viel wir die Gewichte pro Runde der Optimierung verändern wollen. Wir wählen hier einen Wert von $0.2$. Je kleiner der Wert, desto länger braucht das neuronale Netzwerk um ein Optimum zu finden. Pro Schritt können ja die Gewichte nur wenig geändertw werden. Ist das $\eta$ zu groß dann sind die Änderungen der Gewichte auch groß und es kann sein, dass das neuronale Netzwerk gar keine optimalen Gewichte findet. Die Auflösung ist einfach nicht gering genug.</span>
<span id="cb79-273"><a href="#cb79-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-276"><a href="#cb79-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-277"><a href="#cb79-277" aria-hidden="true" tabindex="-1"></a>eta <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb79-278"><a href="#cb79-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-279"><a href="#cb79-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-280"><a href="#cb79-280" aria-hidden="true" tabindex="-1"></a>Jetzt laufen wir einmal durch vier Epochen. In jeder Epoche werden wir unser Gewicht dann wieder optimieren und dann mit den optimierten Gewichten weiter rechnen. Wir lassen uns aber in jeder Schleife einmal die Gewichte ausgeben.</span>
<span id="cb79-281"><a href="#cb79-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-284"><a href="#cb79-284" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-285"><a href="#cb79-285" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-286"><a href="#cb79-286" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>){</span>
<span id="cb79-287"><a href="#cb79-287" aria-hidden="true" tabindex="-1"></a>  adjust <span class="ot">&lt;-</span> (data_tbl<span class="sc">$</span>y[i] <span class="sc">-</span> <span class="fu">neuron</span>(weights, input[i,])) <span class="sc">*</span> input[i,]</span>
<span id="cb79-288"><a href="#cb79-288" aria-hidden="true" tabindex="-1"></a>  weights <span class="ot">&lt;-</span> weights <span class="sc">+</span> eta <span class="sc">*</span> adjust</span>
<span id="cb79-289"><a href="#cb79-289" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Adjust: "</span>, adjust, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb79-290"><a href="#cb79-290" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Weights: "</span>, weights, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb79-291"><a href="#cb79-291" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb79-292"><a href="#cb79-292" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-293"><a href="#cb79-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-294"><a href="#cb79-294" aria-hidden="true" tabindex="-1"></a>Die Gewichte ändern sich in jedem Schritt um den Wert von $0.2$. Mehr geht auch nicht, denn wir geben mit $\eta$ vor, um wieviel sich die Gewichte erhöhen oder erniedrigen können. Im ersten Schritt reduzieren wir das erste Gewicht um den Wert von $\eta$. Im zweiten Schritt reduzieren wir erneut das erste Gewicht und darüber hinaus auch noch das zweite Gewicht. Wir sind dann schon am Optimum, denn wir erhalten keine weiteren Anpassungen mehr. Vermutlich können wir schon am zweiten Schritt das Outcome perfekt auftrennen.</span>
<span id="cb79-295"><a href="#cb79-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-296"><a href="#cb79-296" aria-hidden="true" tabindex="-1"></a>Schauen wir einmal was passiert, wenn wir unser <span class="in">`input`</span> mit den Gewichten aus unserem simplen Algorithmus multiplizieren.</span>
<span id="cb79-297"><a href="#cb79-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-300"><a href="#cb79-300" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-301"><a href="#cb79-301" aria-hidden="true" tabindex="-1"></a>input <span class="sc">%*%</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.4</span>)</span>
<span id="cb79-302"><a href="#cb79-302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-303"><a href="#cb79-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-304"><a href="#cb79-304" aria-hidden="true" tabindex="-1"></a>Unsere ersten zwei Beobachtungen erhalten einen negativen Wert und unsere letzten beiden Beobachtungen einen positiven Wert. Nach unserer Regeln werden Zahlen kleiner als Null zu $0$ und Zahlen größer als Null zu $1$. Da wir die Regel auch in dem Neuron abgespeichert haben, können wir uns einmal das Outcome mit den Input und den berechnete Gewichten wiedergeben lassen.</span>
<span id="cb79-305"><a href="#cb79-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-308"><a href="#cb79-308" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-309"><a href="#cb79-309" aria-hidden="true" tabindex="-1"></a><span class="fu">neuron</span>(input, <span class="at">weights =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.4</span>))</span>
<span id="cb79-310"><a href="#cb79-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-311"><a href="#cb79-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-312"><a href="#cb79-312" aria-hidden="true" tabindex="-1"></a>Wir erhalten eine perfekte Übereinstimmung von der Vorhersage mit unseren Trainingsdaten. Der Algorithmus ist in der Lage mit der Regel in dem Neuron und den berechneten Gewichten unser Outcome korrekt mit den Trainingsdaten vorherzusagen.</span>
<span id="cb79-313"><a href="#cb79-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-314"><a href="#cb79-314" aria-hidden="true" tabindex="-1"></a><span class="fu">## Daten</span></span>
<span id="cb79-315"><a href="#cb79-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-316"><a href="#cb79-316" aria-hidden="true" tabindex="-1"></a>In Folgenden wollen wir uns aber mal auf einen echten Datensatz konzentrieren. Wir nutzen daher einmal den Gummibärchendatensatz. Als unser Label und daher als unser Outcome nehmen wir das Geschlecht <span class="in">`gender`</span>. Dabei wollen wir dann die weiblichen Studierenden vorhersagen. Im Weiteren nehmen wir nur die Spalte Geschlecht sowie als Prädiktoren die Spalten <span class="in">`most_liked`</span>, <span class="in">`age`</span>, <span class="in">`semester`</span>, und <span class="in">`height`</span>.</span>
<span id="cb79-317"><a href="#cb79-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-320"><a href="#cb79-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-321"><a href="#cb79-321" aria-hidden="true" tabindex="-1"></a>gummi_tbl <span class="ot">&lt;-</span> <span class="fu">read_excel</span>(<span class="st">"data/gummibears.xlsx"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-322"><a href="#cb79-322" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">gender =</span> <span class="fu">as_factor</span>(gender),</span>
<span id="cb79-323"><a href="#cb79-323" aria-hidden="true" tabindex="-1"></a>         <span class="at">most_liked =</span> <span class="fu">as_factor</span>(most_liked)) <span class="sc">|&gt;</span> </span>
<span id="cb79-324"><a href="#cb79-324" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(gender, most_liked, age, semester, height) <span class="sc">|&gt;</span> </span>
<span id="cb79-325"><a href="#cb79-325" aria-hidden="true" tabindex="-1"></a>  <span class="fu">drop_na</span>(gender)</span>
<span id="cb79-326"><a href="#cb79-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-327"><a href="#cb79-327" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-328"><a href="#cb79-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-329"><a href="#cb79-329" aria-hidden="true" tabindex="-1"></a>Wir dürfen keine fehlenden Werte in den Daten haben. Wir können für die Prädiktoren später die fehlenden Werte imputieren. Aber wir können keine Labels imputieren. Daher entfernen wir alle Beobachtungen, die ein <span class="in">`NA`</span> in der Variable <span class="in">`gender`</span> haben. Wir haben dann insgesamt $n = <span class="in">`r nrow(gummi_tbl)`</span>$ Beobachtungen vorliegen. In @tbl-gummi-prepro sehen wir nochmal die Auswahl des Datensatzes in gekürzter Form.</span>
<span id="cb79-330"><a href="#cb79-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-333"><a href="#cb79-333" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-334"><a href="#cb79-334" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb79-335"><a href="#cb79-335" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-336"><a href="#cb79-336" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-337"><a href="#cb79-337" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-gummi-model-compare</span></span>
<span id="cb79-338"><a href="#cb79-338" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: Auszug aus dem Daten zu den Gummibärchendaten.</span></span>
<span id="cb79-339"><a href="#cb79-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-340"><a href="#cb79-340" aria-hidden="true" tabindex="-1"></a>gummi_raw_tbl <span class="ot">&lt;-</span> gummi_tbl <span class="sc">|&gt;</span> </span>
<span id="cb79-341"><a href="#cb79-341" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">gender =</span> <span class="fu">as.character</span>(gender),</span>
<span id="cb79-342"><a href="#cb79-342" aria-hidden="true" tabindex="-1"></a>         <span class="at">most_liked =</span> <span class="fu">as.character</span>(most_liked))</span>
<span id="cb79-343"><a href="#cb79-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-344"><a href="#cb79-344" aria-hidden="true" tabindex="-1"></a><span class="fu">rbind</span>(<span class="fu">head</span>(gummi_raw_tbl),</span>
<span id="cb79-345"><a href="#cb79-345" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rep</span>(<span class="st">"..."</span>, <span class="at">times =</span> <span class="fu">ncol</span>(gummi_raw_tbl)),</span>
<span id="cb79-346"><a href="#cb79-346" aria-hidden="true" tabindex="-1"></a>      <span class="fu">tail</span>(gummi_raw_tbl)) <span class="sc">|&gt;</span> </span>
<span id="cb79-347"><a href="#cb79-347" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="at">align =</span> <span class="st">"c"</span>, <span class="st">"pipe"</span>)</span>
<span id="cb79-348"><a href="#cb79-348" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-349"><a href="#cb79-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-350"><a href="#cb79-350" aria-hidden="true" tabindex="-1"></a>Unsere Fragestellung ist damit, können wir anhand unserer Prädiktoren männliche von weiblichen Studierenden unterscheiden und damit auch klassifizieren? Um die Klassifikation mit Entscheidungsbäumen rechnen zu können brauchen wir wie bei allen anderen Algorithmen auch einen Trainings- und Testdatensatz. Wir splitten dafür unsere Daten in einer 3 zu 4 Verhältnis in einen Traingsdatensatz sowie einen Testdatensatz auf. Der Traingsdatensatz ist dabei immer der größere Datensatz. Da wir aktuell nicht so viele Beobachtungen in dem Gummibärchendatensatz haben, möchte ich mindestens 100 Beobachtungen in den Testdaten. Deshalb kommt mir der 3:4 Split sehr entgegen.</span>
<span id="cb79-351"><a href="#cb79-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-354"><a href="#cb79-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-355"><a href="#cb79-355" aria-hidden="true" tabindex="-1"></a>gummi_data_split <span class="ot">&lt;-</span> <span class="fu">initial_split</span>(gummi_tbl, <span class="at">prop =</span> <span class="dv">3</span><span class="sc">/</span><span class="dv">4</span>)</span>
<span id="cb79-356"><a href="#cb79-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-357"><a href="#cb79-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-358"><a href="#cb79-358" aria-hidden="true" tabindex="-1"></a>Wir speichern uns jetzt den Trainings- und Testdatensatz jeweils separat ab. Die weiteren Modellschritte laufen alle auf dem Traingsdatensatz, wie nutzen dann erst ganz zum Schluss einmal den Testdatensatz um zu schauen, wie gut unsere trainiertes Modell auf den neuen Testdaten funktioniert.</span>
<span id="cb79-359"><a href="#cb79-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-362"><a href="#cb79-362" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-363"><a href="#cb79-363" aria-hidden="true" tabindex="-1"></a>gummi_train_data <span class="ot">&lt;-</span> <span class="fu">training</span>(gummi_data_split)</span>
<span id="cb79-364"><a href="#cb79-364" aria-hidden="true" tabindex="-1"></a>gummi_test_data  <span class="ot">&lt;-</span> <span class="fu">testing</span>(gummi_data_split)</span>
<span id="cb79-365"><a href="#cb79-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-366"><a href="#cb79-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-367"><a href="#cb79-367" aria-hidden="true" tabindex="-1"></a>Nachdem wir die Daten vorbereitet haben, müssen wir noch das Rezept mit den Vorverabreitungsschritten definieren. Wir schreiben, dass wir das Geschlecht <span class="in">`gender`</span> als unser Label haben wollen. Daneben nehmen wir alle anderen Spalten als Prädiktoren mit in unser Modell, das machen wir dann mit dem <span class="in">`.`</span> Symbol. Da wir noch fehlende Werte in unseren Prädiktoren haben, imputieren wir noch die numerischen Variablen mit der Mittelwertsimputation und die nominalen fehlenden Werte mit Entscheidungsbäumen. Dann müssen wir noch alle numerischen Variablen normalisieren und alle nominalen Variablen dummykodieren. Am Ende werde ich nochmal alle Variablen entfernen, sollte die Varianz in einer Variable nahe der Null sein.</span>
<span id="cb79-368"><a href="#cb79-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-371"><a href="#cb79-371" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-372"><a href="#cb79-372" aria-hidden="true" tabindex="-1"></a>gummi_rec <span class="ot">&lt;-</span> <span class="fu">recipe</span>(gender <span class="sc">~</span> ., <span class="at">data =</span> gummi_train_data) <span class="sc">|&gt;</span> </span>
<span id="cb79-373"><a href="#cb79-373" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_mean</span>(<span class="fu">all_numeric_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb79-374"><a href="#cb79-374" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_bag</span>(<span class="fu">all_nominal_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb79-375"><a href="#cb79-375" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_range</span>(<span class="fu">all_numeric_predictors</span>(), <span class="at">min =</span> <span class="dv">0</span>, <span class="at">max =</span> <span class="dv">1</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-376"><a href="#cb79-376" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_dummy</span>(<span class="fu">all_nominal_predictors</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb79-377"><a href="#cb79-377" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_nzv</span>(<span class="fu">all_predictors</span>())</span>
<span id="cb79-378"><a href="#cb79-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-379"><a href="#cb79-379" aria-hidden="true" tabindex="-1"></a>gummi_rec <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span>
<span id="cb79-380"><a href="#cb79-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-381"><a href="#cb79-381" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-382"><a href="#cb79-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-383"><a href="#cb79-383" aria-hidden="true" tabindex="-1"></a>Alles in allem haben wir ein sehr kleines Modell. Wir haben ja nur ein Outcome und vier Prädiktoren. Trotzdem sollte dieser Datensatz reichen um zu erklären wie Keras oder Tensorflow funktionieren. Am Ende muss man sich aber auch ehrlich machen und sagen, dass ein Datensatz mit unter tausend Beobachtungen eigentlich keinen großen Sinn für ein neuronales Netz macht. Deshalb ist das hier eher eine Demonstration des Algorithmus.</span>
<span id="cb79-384"><a href="#cb79-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-385"><a href="#cb79-385" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronale Netze mit `neuralnet`</span></span>
<span id="cb79-386"><a href="#cb79-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-387"><a href="#cb79-387" aria-hidden="true" tabindex="-1"></a>Neuronale Netze mit den R Paketen <span class="in">`{neuralnet}`</span> und dem R Paket <span class="in">`{nnet}`</span> sind mehr oder minder veraltet (eng. *outdated*). Wir können das Paket <span class="in">`{neuralnet}`</span> nicht über die <span class="in">`{parsnip}`</span> Umgebung nutzen. Deshalb hier einmal zu Fuß mit all den Komplikationen, die das so mit sich bringt. Auf der anderen Seite liefert das Paket <span class="in">`{neuralnet}`</span> auch gute Ergebnisse mit wenig rechenlaufzeit. Da musst du dann einmal abwägen, was du in deiner Arbei so brauchst.</span>
<span id="cb79-388"><a href="#cb79-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-389"><a href="#cb79-389" aria-hidden="true" tabindex="-1"></a>Das die Funktion <span class="in">`neuralnet()`</span> nicht mit den Workflow kann, müssen wir uns erstmal wieder den Traingsdatendatz und den Testdatensatz aus unserem Rezept extrahieren. Den Traingsdatensatz können wir uns über die Funktion <span class="in">`juice()`</span> einmal aus dem Rezept ziehen.</span>
<span id="cb79-390"><a href="#cb79-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-393"><a href="#cb79-393" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-394"><a href="#cb79-394" aria-hidden="true" tabindex="-1"></a>gummi_train_tbl <span class="ot">&lt;-</span> gummi_rec <span class="sc">|&gt;</span> </span>
<span id="cb79-395"><a href="#cb79-395" aria-hidden="true" tabindex="-1"></a>  <span class="fu">prep</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-396"><a href="#cb79-396" aria-hidden="true" tabindex="-1"></a>  <span class="fu">juice</span>()</span>
<span id="cb79-397"><a href="#cb79-397" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-398"><a href="#cb79-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-399"><a href="#cb79-399" aria-hidden="true" tabindex="-1"></a>Den Testdatensatz müssen wir mit dem Rezept einmal backen. Dann müssen wir noch die Spalte <span class="in">`gender`</span> in eine numerische Spalte umwandeln. Sonst klappt das später nicht mit der Prädiktion und der Konfusionsmatrix.</span>
<span id="cb79-400"><a href="#cb79-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-403"><a href="#cb79-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-404"><a href="#cb79-404" aria-hidden="true" tabindex="-1"></a>gummi_test_tbl <span class="ot">&lt;-</span> gummi_rec <span class="sc">|&gt;</span> </span>
<span id="cb79-405"><a href="#cb79-405" aria-hidden="true" tabindex="-1"></a>  <span class="fu">prep</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-406"><a href="#cb79-406" aria-hidden="true" tabindex="-1"></a>  <span class="fu">bake</span>(gummi_test_data) <span class="sc">|&gt;</span> </span>
<span id="cb79-407"><a href="#cb79-407" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">gender =</span> <span class="fu">as_factor</span>(<span class="fu">ifelse</span>(gender <span class="sc">==</span> <span class="st">"m"</span>, <span class="dv">0</span>, <span class="dv">1</span>)))</span>
<span id="cb79-408"><a href="#cb79-408" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-409"><a href="#cb79-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-410"><a href="#cb79-410" aria-hidden="true" tabindex="-1"></a>Dann können wir auch schon die Funktion <span class="in">`neuralnet`</span> auf unsere Daten anwenden. Wir wollen fünfmal über die Traingsdaten iterieren (<span class="in">`rep = 5`</span>). Später heißt dieses Iterieren dann auch <span class="in">`epoch`</span>. Dann müssen wir noch den Threshold für den Fehler festlegen, der gerade noch so akzeptabel ist und wo das Wachstum endet. Je kleiner, desto länger dauer der Prozess. Mit einem <span class="in">`threshold = 0.2`</span> sind wir aber schon sehr weit oben, sonst ist der Wert bei $0.01$. Hier musst ein wenig selber mit den Parametern spielen. Eine Tuningmöglichkeit oder eine Kreuzvalidierung musst du dir dann selber programmieren. Wir nehmen dann fünf Hiddenlayers mit jeweils fünf Knoten pro Hiddenlayer.</span>
<span id="cb79-411"><a href="#cb79-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-414"><a href="#cb79-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-415"><a href="#cb79-415" aria-hidden="true" tabindex="-1"></a>neuralnet_fit <span class="ot">&lt;-</span> <span class="fu">neuralnet</span>(gender <span class="sc">~</span>., <span class="at">data =</span> gummi_train_tbl, <span class="at">rep =</span> <span class="dv">5</span>, <span class="at">threshold =</span> <span class="fl">0.2</span>,</span>
<span id="cb79-416"><a href="#cb79-416" aria-hidden="true" tabindex="-1"></a>                           <span class="at">hidden =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">5</span>), <span class="at">lifesign =</span> <span class="st">"minimal"</span>)</span>
<span id="cb79-417"><a href="#cb79-417" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-418"><a href="#cb79-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-419"><a href="#cb79-419" aria-hidden="true" tabindex="-1"></a>Wenn wir das Modell haben, dann können wir uns hier ganz einfach mal das beste neuronale Netzwerk anschauen. Also die Wiederholung mit dem kleinsten Fehler. In Abbildung @fig-class-nn-02 sehen wir das Netzwerk einmal dargestellt. Die blauen Knoten stellen die Biasknoten dar. Die Zahlen an den Kanten stellen dann die Gewichte dar, die von dem jeweiligen Knoten weitergegeben werden. Die Interpretation des Netzwerks ist so schwer, es ist eben nur eine visuelle Darstellung. Da so eine Abbildung etwas schwer zu interpretieren ist, erlaubt ein neurales Interpretationsdiagramm mehr Einblicke. Die schwarzen Kanten haben einen höheren Einfluss als die grauen Kanten. Die exakte Interpretation der Knoten und der Kanten ist aber dennoch schwierig.</span>
<span id="cb79-420"><a href="#cb79-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-423"><a href="#cb79-423" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-424"><a href="#cb79-424" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-425"><a href="#cb79-425" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-426"><a href="#cb79-426" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-427"><a href="#cb79-427" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-nn-02</span></span>
<span id="cb79-428"><a href="#cb79-428" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-429"><a href="#cb79-429" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 7</span></span>
<span id="cb79-430"><a href="#cb79-430" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 8</span></span>
<span id="cb79-431"><a href="#cb79-431" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Abbildung des neuronalen Netzwerks mit dem kleinsten Fehler."</span></span>
<span id="cb79-432"><a href="#cb79-432" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap: </span></span>
<span id="cb79-433"><a href="#cb79-433" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Neuronales Netzwerk mit den Gewichten und dem Bias als numerische Representation."</span></span>
<span id="cb79-434"><a href="#cb79-434" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Neurales Interpretationsdiagramm für ein neurales Netzwerk."</span></span>
<span id="cb79-435"><a href="#cb79-435" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-nrow: 1</span></span>
<span id="cb79-436"><a href="#cb79-436" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb79-437"><a href="#cb79-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-438"><a href="#cb79-438" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(neuralnet_fit, <span class="at">rep =</span> <span class="st">"best"</span>)</span>
<span id="cb79-439"><a href="#cb79-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-440"><a href="#cb79-440" aria-hidden="true" tabindex="-1"></a><span class="fu">plotnet</span>(neuralnet_fit, <span class="at">rep =</span> <span class="st">"best"</span>, <span class="at">bias =</span> <span class="cn">FALSE</span>, <span class="at">pad_x =</span> <span class="fl">0.59</span>)</span>
<span id="cb79-441"><a href="#cb79-441" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-442"><a href="#cb79-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-443"><a href="#cb79-443" aria-hidden="true" tabindex="-1"></a>Am Ende machen wir das Ganze ja nicht um etwas *interpretieren* zu können, sondern um eine Vorhersage zu treffen. Das machen wir mit der Funktion <span class="in">`predict()`</span>. Jetzt wird es wieder nervig. Wir müssen usn merken, dass unser Faktor zwei Level hat mit <span class="in">`0`</span> und <span class="in">`1`</span> wobei die <span class="in">`m = 0`</span> und <span class="in">`w = 1`</span> ist. Als wäre das nicht schon nervig genug, haben wir dann in der Ausgabe von <span class="in">`predict()`</span> nur eine Matrix mit zwei Spalten. Wir brauchen die zweite Spalte, da wir das Geschlecht <span class="in">`w`</span> vorhersagen wollen.</span>
<span id="cb79-444"><a href="#cb79-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-447"><a href="#cb79-447" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-448"><a href="#cb79-448" aria-hidden="true" tabindex="-1"></a>neuralnet_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(neuralnet_fit, gummi_test_tbl) <span class="sc">|&gt;</span> </span>
<span id="cb79-449"><a href="#cb79-449" aria-hidden="true" tabindex="-1"></a>  <span class="fu">round</span>(<span class="dv">2</span>)</span>
<span id="cb79-450"><a href="#cb79-450" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-451"><a href="#cb79-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-452"><a href="#cb79-452" aria-hidden="true" tabindex="-1"></a>Kurzer Check, ob wir auch alles richtig gemacht haben.</span>
<span id="cb79-453"><a href="#cb79-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-456"><a href="#cb79-456" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-457"><a href="#cb79-457" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(neuralnet_pred[,<span class="dv">1</span>])</span>
<span id="cb79-458"><a href="#cb79-458" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(neuralnet_pred[,<span class="dv">2</span>])</span>
<span id="cb79-459"><a href="#cb79-459" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-460"><a href="#cb79-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-461"><a href="#cb79-461" aria-hidden="true" tabindex="-1"></a>Und wir stellen fest, dass hier irgendwas mit unserer Wahrscheinlichkeit für die Klassenzugehörigkeit nicht stimmt. Wir haben negative Werte und Werte über Eins. Das macht für eine Wahrscheinlichkeit keinen Sinn.</span>
<span id="cb79-462"><a href="#cb79-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-463"><a href="#cb79-463" aria-hidden="true" tabindex="-1"></a>::: {.callout-important appearance="simple"}</span>
<span id="cb79-464"><a href="#cb79-464" aria-hidden="true" tabindex="-1"></a><span class="fu">## Stopp!</span></span>
<span id="cb79-465"><a href="#cb79-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-466"><a href="#cb79-466" aria-hidden="true" tabindex="-1"></a>Jetzt müssen wir hier erstmal anhalten, denn wir erhalten sinnlose Wahrscheinlichkeiten zurück. Ich würde hier erstmal das Modell überprüfen und die Daten anpassen. Jedenfalls geht es so nicht weiter...</span>
<span id="cb79-467"><a href="#cb79-467" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-468"><a href="#cb79-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-469"><a href="#cb79-469" aria-hidden="true" tabindex="-1"></a>Ich zeige aber noch wie du dir die Konfusionsmatrix berechnest. Da musst du dich wieder strecken um alles in die Funktion <span class="in">`conf_mat()`</span> richtig rein zu kriegen. Aber Vorsicht, erst wenn du die Wahrscheinlichkeiten hingekriegt hast, dann kannst du mit der Konfusionsmatrix weitermachen.</span>
<span id="cb79-470"><a href="#cb79-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-473"><a href="#cb79-473" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-474"><a href="#cb79-474" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: nn-bug</span></span>
<span id="cb79-475"><a href="#cb79-475" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-476"><a href="#cb79-476" aria-hidden="true" tabindex="-1"></a>neuralnet_cm <span class="ot">&lt;-</span> <span class="fu">conf_mat</span>(<span class="at">data =</span> <span class="fu">data.frame</span>(<span class="at">.pred_class =</span> <span class="fu">as.factor</span>(<span class="fu">round</span>(neuralnet_pred[,<span class="dv">2</span>])),</span>
<span id="cb79-477"><a href="#cb79-477" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">gender =</span> <span class="fu">as.factor</span>(<span class="fu">pull</span>(gummi_test_tbl, gender))), </span>
<span id="cb79-478"><a href="#cb79-478" aria-hidden="true" tabindex="-1"></a>                         gender, .pred_class)</span>
<span id="cb79-479"><a href="#cb79-479" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-480"><a href="#cb79-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-481"><a href="#cb79-481" aria-hidden="true" tabindex="-1"></a>Dann können wir uns die Konfusionsmatrix auch einmal wiedergeben lassen. Ich wäre hier sehr vorsichtig, was die Werte angeht. Wir haben gerade komische Wahrscheinlichkeiten wiedergegeben bekommen. Daher würde ich der Sache hier nicht trauen und nochmal an der Funktion <span class="in">`neuralnet()`</span> mit anderen Parametern herumprobieren. Man sieht, es hat auch einen Grund warum manche Funktionen nicht in der <span class="in">`parsnip`</span> Umgebung implementiert sind.</span>
<span id="cb79-482"><a href="#cb79-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-485"><a href="#cb79-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-486"><a href="#cb79-486" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-487"><a href="#cb79-487" aria-hidden="true" tabindex="-1"></a>neuralnet_cm <span class="sc">|&gt;</span> </span>
<span id="cb79-488"><a href="#cb79-488" aria-hidden="true" tabindex="-1"></a>  summary <span class="sc">|&gt;</span> </span>
<span id="cb79-489"><a href="#cb79-489" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate_if</span>(is.numeric, round, <span class="dv">2</span>)</span>
<span id="cb79-490"><a href="#cb79-490" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-491"><a href="#cb79-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-492"><a href="#cb79-492" aria-hidden="true" tabindex="-1"></a>Hier ist also wirklich Vorsicht geboten, wenn wir uns die Ergebnisse anschauen. Die Ergebnisse sind zwar nicht so schlecht, aber wir vertrauen da nicht dem Algorithmus, wenn wir ungültige Wahrscheinlichkeiten erhalten.</span>
<span id="cb79-493"><a href="#cb79-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-494"><a href="#cb79-494" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronale Netze mit `nnet`</span></span>
<span id="cb79-495"><a href="#cb79-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-496"><a href="#cb79-496" aria-hidden="true" tabindex="-1"></a>Wir können aber das R Paket <span class="in">`{nnet}`</span> mit unserer bekannten Rezeptumgebung nutzen und uns damit das Leben einfacher machen. Das macht auch in diesem Fall sehr viel mehr Sinn, da wir ja nur komische Wahrscheinlichkeiten der Klassenzugehörigkeit aus der Funktion <span class="in">`neuralnet()`</span> wiederbekommen. Also das ganze einmal ohne wildes Installieren von Tensorflow / Keras. Ein simples neurales Netzwerk in R mit der Engine aus <span class="in">`nnet`</span>.</span>
<span id="cb79-497"><a href="#cb79-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-498"><a href="#cb79-498" aria-hidden="true" tabindex="-1"></a>In unserem Beispiel lassen wir einhundert Replikationen laufen (<span class="in">`epoch = 100`</span>) und wählen auch hier mal fünf Hidden Layers (<span class="in">`hidden_units = 5`</span>). Dann wollen wir natürlich eine Klassifikation rechnen.</span>
<span id="cb79-499"><a href="#cb79-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-502"><a href="#cb79-502" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-503"><a href="#cb79-503" aria-hidden="true" tabindex="-1"></a>nnet_mod <span class="ot">&lt;-</span> <span class="fu">mlp</span>(<span class="at">epochs =</span> <span class="dv">100</span>, <span class="at">hidden_units =</span> <span class="dv">5</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-504"><a href="#cb79-504" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"nnet"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-505"><a href="#cb79-505" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>)</span>
<span id="cb79-506"><a href="#cb79-506" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-507"><a href="#cb79-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-508"><a href="#cb79-508" aria-hidden="true" tabindex="-1"></a>Wir bringen wieder unser Modell mit dem Rezept des Gummibärchendatensatzes zusammen und können dann den Workflow abspeicherb.</span>
<span id="cb79-509"><a href="#cb79-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-512"><a href="#cb79-512" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-513"><a href="#cb79-513" aria-hidden="true" tabindex="-1"></a>nnet_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-514"><a href="#cb79-514" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(nnet_mod) <span class="sc">|&gt;</span> </span>
<span id="cb79-515"><a href="#cb79-515" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span>
<span id="cb79-516"><a href="#cb79-516" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-517"><a href="#cb79-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-518"><a href="#cb79-518" aria-hidden="true" tabindex="-1"></a>Wie immer starten wir dann den Workflow mit der Funktion <span class="in">`fit()`</span> und erhalten das <span class="in">`nnet`</span> Modell zurück.</span>
<span id="cb79-519"><a href="#cb79-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-522"><a href="#cb79-522" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-523"><a href="#cb79-523" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-524"><a href="#cb79-524" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-525"><a href="#cb79-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-526"><a href="#cb79-526" aria-hidden="true" tabindex="-1"></a>nnet_fit <span class="ot">&lt;-</span> nnet_wflow <span class="sc">|&gt;</span> </span>
<span id="cb79-527"><a href="#cb79-527" aria-hidden="true" tabindex="-1"></a>  parsnip<span class="sc">::</span><span class="fu">fit</span>(gummi_train_data)</span>
<span id="cb79-528"><a href="#cb79-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-529"><a href="#cb79-529" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-530"><a href="#cb79-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-531"><a href="#cb79-531" aria-hidden="true" tabindex="-1"></a>Jetzt müssen wir nur noch mit der Funktion <span class="in">`augment`</span> uns die Vorhersagen mit dem Testdatensatz wiedergeben lassen.</span>
<span id="cb79-532"><a href="#cb79-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-535"><a href="#cb79-535" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-536"><a href="#cb79-536" aria-hidden="true" tabindex="-1"></a>nnet_aug <span class="ot">&lt;-</span> <span class="fu">augment</span>(nnet_fit, gummi_test_data ) </span>
<span id="cb79-537"><a href="#cb79-537" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-538"><a href="#cb79-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-539"><a href="#cb79-539" aria-hidden="true" tabindex="-1"></a>Da wir hier etwas vorsichtig geworden sind, nochmal schnell schauen, ob unsere Wahrscheinlichkeiten der Klassenzugehörigkeit auch wirklich eine Wahrscheinlichkeit ist.</span>
<span id="cb79-540"><a href="#cb79-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-543"><a href="#cb79-543" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-544"><a href="#cb79-544" aria-hidden="true" tabindex="-1"></a><span class="fu">pluck</span>(nnet_aug, <span class="st">".pred_w"</span>) <span class="sc">|&gt;</span> <span class="fu">range</span>()</span>
<span id="cb79-545"><a href="#cb79-545" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-546"><a href="#cb79-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-547"><a href="#cb79-547" aria-hidden="true" tabindex="-1"></a>Ja, das passt soweit und wir können uns dann die Konfusionsmatrix berechnen lassen. Die Ergebnisse sind jetzt nicht so berauschend, aber auf der anderen Seite richtiger als in der Funktion <span class="in">`neuralnet()`</span>.</span>
<span id="cb79-548"><a href="#cb79-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-551"><a href="#cb79-551" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-552"><a href="#cb79-552" aria-hidden="true" tabindex="-1"></a>nnet_cm <span class="ot">&lt;-</span> nnet_aug <span class="sc">|&gt;</span> </span>
<span id="cb79-553"><a href="#cb79-553" aria-hidden="true" tabindex="-1"></a>  <span class="fu">conf_mat</span>(gender, .pred_class)</span>
<span id="cb79-554"><a href="#cb79-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-555"><a href="#cb79-555" aria-hidden="true" tabindex="-1"></a>nnet_cm</span>
<span id="cb79-556"><a href="#cb79-556" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-557"><a href="#cb79-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-558"><a href="#cb79-558" aria-hidden="true" tabindex="-1"></a>Dann schauen wir uns nochmal die ganzen anderen Gütekriterien aus der Konfusionsmatrix einmal an.</span>
<span id="cb79-559"><a href="#cb79-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-562"><a href="#cb79-562" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-563"><a href="#cb79-563" aria-hidden="true" tabindex="-1"></a>nnet_cm <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span>
<span id="cb79-564"><a href="#cb79-564" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-565"><a href="#cb79-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-566"><a href="#cb79-566" aria-hidden="true" tabindex="-1"></a>Die Ergebnisse sind höchstens okay. Die Accuracy ist nicht sehr hoch und auch der Rest der Werte ist eher mittelmäßig. Das Ganze sehen wir dann in @fig-class-nnet-01 auch nochmal entsprechend in der ROC Kurve visualisiert. Die ROC Kurve sieht nur mittelmäßig aus. Wir müssten hier auf jeden Fall nochmal über Kreuzvalidierung und Tuning nachdenken. Ohne Kreuzvalidierung und Tuning würde ich das Modell nicht anwenden.</span>
<span id="cb79-567"><a href="#cb79-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-570"><a href="#cb79-570" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-571"><a href="#cb79-571" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-572"><a href="#cb79-572" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-573"><a href="#cb79-573" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-574"><a href="#cb79-574" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-nnet-01</span></span>
<span id="cb79-575"><a href="#cb79-575" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-576"><a href="#cb79-576" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 5</span></span>
<span id="cb79-577"><a href="#cb79-577" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 5</span></span>
<span id="cb79-578"><a href="#cb79-578" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "ROC Kurve für den `nnet` Algorithmus."</span></span>
<span id="cb79-579"><a href="#cb79-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-580"><a href="#cb79-580" aria-hidden="true" tabindex="-1"></a>nnet_aug <span class="sc">|&gt;</span> </span>
<span id="cb79-581"><a href="#cb79-581" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-582"><a href="#cb79-582" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span>
<span id="cb79-583"><a href="#cb79-583" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-584"><a href="#cb79-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-585"><a href="#cb79-585" aria-hidden="true" tabindex="-1"></a><span class="fu">## Neuronale Netze mit Keras / Tensorflow</span></span>
<span id="cb79-586"><a href="#cb79-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-587"><a href="#cb79-587" aria-hidden="true" tabindex="-1"></a>Jetzt kommen wir zum dicksten Brett. Was wir hier machen ist eigentlich nur ein schwacher Abglanz was Tensorflow eigentlich kann. Über den Algorithmus werden ganze Bücher geschrieben und die Anwendung auf einem Laptop oder Standrechner ist eigentlich dem Algorithmus nicht würdig. Wir werden hier auch nicht alles aus dem Algorithmus raus holen. Das geht auch gar nicht. Wenn du dich tiefer mit der Materie beschäftigen willst, dann ist dies hier ein guter Startpunkt. Wenn du Probleme hast Tensorflow zum Laufen zu kriegen, dann kannst du auch für die einfache Anwendung <span class="in">`nnet`</span> nutzen. Mit ein wenig Tuning sollten da auch gute Ergebnisse bei herauskommen.</span>
<span id="cb79-588"><a href="#cb79-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-589"><a href="#cb79-589" aria-hidden="true" tabindex="-1"></a>::: column-margin</span>
<span id="cb79-590"><a href="#cb79-590" aria-hidden="true" tabindex="-1"></a>Wenn du richtig Tensorflow mit R nutzen willst, dann gibt es hier noch das umfangreiche Tutorium für <span class="co">[</span><span class="ot">Tensorflow with R</span><span class="co">](https://colorado.rstudio.com/rsc/churn/modeling/tensorflow-w-r.nb.html)</span>. Insbesondere die Nutzung von <span class="in">`lime`</span> um die Black Box des neuronalen Netzwerks zu erklären wird hier nochmal gezeigt.</span>
<span id="cb79-591"><a href="#cb79-591" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-592"><a href="#cb79-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-593"><a href="#cb79-593" aria-hidden="true" tabindex="-1"></a>Die Funktion <span class="in">`mlp()`</span> erlaubt uns als Engine <span class="in">`keras`</span> zu verweden und damit ein neurales Netzwerk mit dem Tensorflow Algorithmus zu rechnen. Mehr brauchen wir an dieser Stelle erstaml nicht tun. Wir werden hier erstmal keine Tuning Parameter angeben. Später im Kapitel werden wir dann noch ein Tuning für den Algorithmus rechnen.</span>
<span id="cb79-594"><a href="#cb79-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-597"><a href="#cb79-597" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-598"><a href="#cb79-598" aria-hidden="true" tabindex="-1"></a>keras_mod <span class="ot">&lt;-</span> <span class="fu">mlp</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-599"><a href="#cb79-599" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"keras"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-600"><a href="#cb79-600" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>)</span>
<span id="cb79-601"><a href="#cb79-601" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-602"><a href="#cb79-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-603"><a href="#cb79-603" aria-hidden="true" tabindex="-1"></a>Jetzt bringen wir noch das Rezept des Gummibärchendatensatzes mit dem Modell in einem Workflow zusammen.</span>
<span id="cb79-604"><a href="#cb79-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-607"><a href="#cb79-607" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-608"><a href="#cb79-608" aria-hidden="true" tabindex="-1"></a>keras_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-609"><a href="#cb79-609" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(keras_mod) <span class="sc">|&gt;</span> </span>
<span id="cb79-610"><a href="#cb79-610" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span>
<span id="cb79-611"><a href="#cb79-611" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-612"><a href="#cb79-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-613"><a href="#cb79-613" aria-hidden="true" tabindex="-1"></a>Jetzt können mit mit der Funktion <span class="in">`fit()`</span> das Modell rechnen. Wenn du Keras und Tensorflow nicht installiert hast, dann wird jetzt meist eine automatische Installation starten. Oder aber du hast dir vorher schon Tensorflow und Keras installiert. Schaue dazu gerne einmal den <span class="co">[</span><span class="ot">Quick start um Tensorflow zu installieren an</span><span class="co">](https://tensorflow.rstudio.com/install/)</span>.</span>
<span id="cb79-614"><a href="#cb79-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-615"><a href="#cb79-615" aria-hidden="true" tabindex="-1"></a><span class="in">```{r keras-small-fit}</span></span>
<span id="cb79-616"><a href="#cb79-616" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb79-617"><a href="#cb79-617" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb79-618"><a href="#cb79-618" aria-hidden="true" tabindex="-1"></a><span class="in">#| cache: true</span></span>
<span id="cb79-619"><a href="#cb79-619" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb79-620"><a href="#cb79-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-621"><a href="#cb79-621" aria-hidden="true" tabindex="-1"></a><span class="in">keras_fit &lt;- keras_wflow |&gt; </span></span>
<span id="cb79-622"><a href="#cb79-622" aria-hidden="true" tabindex="-1"></a><span class="in">  parsnip::fit(gummi_train_data)</span></span>
<span id="cb79-623"><a href="#cb79-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-624"><a href="#cb79-624" aria-hidden="true" tabindex="-1"></a><span class="in">keras_aug &lt;- augment(keras_fit, gummi_test_data) </span></span>
<span id="cb79-625"><a href="#cb79-625" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-626"><a href="#cb79-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-629"><a href="#cb79-629" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-630"><a href="#cb79-630" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-631"><a href="#cb79-631" aria-hidden="true" tabindex="-1"></a>keras_fit <span class="ot">&lt;-</span> keras_wflow <span class="sc">|&gt;</span> </span>
<span id="cb79-632"><a href="#cb79-632" aria-hidden="true" tabindex="-1"></a>  parsnip<span class="sc">::</span><span class="fu">fit</span>(gummi_train_data)</span>
<span id="cb79-633"><a href="#cb79-633" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-634"><a href="#cb79-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-635"><a href="#cb79-635" aria-hidden="true" tabindex="-1"></a>Wenn der Algorithmus durchgelaufen ist, was schon ein paar Sekunden dauern kann, dann können wir danach das Modell nutzen um unser Geschlecht vorherzusagen.</span>
<span id="cb79-636"><a href="#cb79-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-639"><a href="#cb79-639" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-640"><a href="#cb79-640" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-641"><a href="#cb79-641" aria-hidden="true" tabindex="-1"></a>keras_aug <span class="ot">&lt;-</span> <span class="fu">augment</span>(keras_fit, gummi_test_data) </span>
<span id="cb79-642"><a href="#cb79-642" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-643"><a href="#cb79-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-644"><a href="#cb79-644" aria-hidden="true" tabindex="-1"></a>Wir lassen uns dann wieder die Konfusionsmatrix wiedergeben. Wir sehen, dass wir sehr mies dran sind. Wir haben eine nahezu zufällige Einteilung der Geschlechter durch die Vorhersage.</span>
<span id="cb79-645"><a href="#cb79-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-648"><a href="#cb79-648" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-649"><a href="#cb79-649" aria-hidden="true" tabindex="-1"></a>keras_cm <span class="ot">&lt;-</span> keras_aug <span class="sc">|&gt;</span> </span>
<span id="cb79-650"><a href="#cb79-650" aria-hidden="true" tabindex="-1"></a>  <span class="fu">conf_mat</span>(gender, .pred_class)</span>
<span id="cb79-651"><a href="#cb79-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-652"><a href="#cb79-652" aria-hidden="true" tabindex="-1"></a>keras_cm</span>
<span id="cb79-653"><a href="#cb79-653" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-654"><a href="#cb79-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-655"><a href="#cb79-655" aria-hidden="true" tabindex="-1"></a>Was schon in der Konfusionsmatrix ziemlich mies aussah, wird natürlich auch so in der Zusammenfassung wiedergegeben.</span>
<span id="cb79-656"><a href="#cb79-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-659"><a href="#cb79-659" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-660"><a href="#cb79-660" aria-hidden="true" tabindex="-1"></a>keras_cm <span class="sc">|&gt;</span> <span class="fu">summary</span>()</span>
<span id="cb79-661"><a href="#cb79-661" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-662"><a href="#cb79-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-663"><a href="#cb79-663" aria-hidden="true" tabindex="-1"></a>Was sehen wir? Wir sehen, dass unsere Accuracy mit unter 50% schon mehr schlecht ist. Die Zuordnung der Geschlechter wird vom Algorithmus rein zufällig durchgeführt. Wir können daher nicht von einem guten Algorithmus sprechen. In @fig-class-keras-01 sehen wir die gewollt schlechte ROC Kurve aus einem <span class="in">`keras`</span> Algorithmus ohne Tuning. Warum war die nochmal gewollt schlecht? Ich will hier einmal zeigen, dass ein neuronales Netz aus dem Tensorflow Algorithmus meistens ohne ein Tuning sehr schlecht ist. Das kann sich aber durch ein Tuning sehr schnell drehen.</span>
<span id="cb79-664"><a href="#cb79-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-667"><a href="#cb79-667" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-668"><a href="#cb79-668" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-669"><a href="#cb79-669" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-670"><a href="#cb79-670" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-671"><a href="#cb79-671" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-keras-01</span></span>
<span id="cb79-672"><a href="#cb79-672" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-673"><a href="#cb79-673" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 5</span></span>
<span id="cb79-674"><a href="#cb79-674" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 5</span></span>
<span id="cb79-675"><a href="#cb79-675" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "ROC Kurve für den `keras` Algorithmus."</span></span>
<span id="cb79-676"><a href="#cb79-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-677"><a href="#cb79-677" aria-hidden="true" tabindex="-1"></a>keras_aug <span class="sc">|&gt;</span> </span>
<span id="cb79-678"><a href="#cb79-678" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-679"><a href="#cb79-679" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span>
<span id="cb79-680"><a href="#cb79-680" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-681"><a href="#cb79-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-682"><a href="#cb79-682" aria-hidden="true" tabindex="-1"></a>::: callout-note</span>
<span id="cb79-683"><a href="#cb79-683" aria-hidden="true" tabindex="-1"></a><span class="fu">## Kann ich auch eine Kreuzvalidierung für Keras / Tensorflow durchführen?</span></span>
<span id="cb79-684"><a href="#cb79-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-685"><a href="#cb79-685" aria-hidden="true" tabindex="-1"></a>Ja, kannst du. Wenn du *nur* eine Kreuzvalidierung durchführen willst, findest du alles im @sec-knn für den $k$-NN Algorithmus. Du musst dort nur den Workflow ändern und schon kannst du alles auch auf Keras / Tensorflow Algorithmus anwenden.</span>
<span id="cb79-686"><a href="#cb79-686" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb79-687"><a href="#cb79-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-688"><a href="#cb79-688" aria-hidden="true" tabindex="-1"></a><span class="fu">## Tuning</span></span>
<span id="cb79-689"><a href="#cb79-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-690"><a href="#cb79-690" aria-hidden="true" tabindex="-1"></a>Was heißt Tuning? Wie bei einem Auto können wir an verschiedenen Stellschrauben bei einem mathematischen Algorithmus schrauben. Welche Schrauben und Teile das sind, hängt dann wieder vom Algorithmus ab. Im Falle des xgboost Algorithmus können wir an folgenden Parametern drehen und jeweils schauen, was dann mit unserer Vorhersage passiert. Insgesamt hat der <span class="co">[</span><span class="ot">keras Algorithmus fünf Tuningparameter</span><span class="co">](https://parsnip.tidymodels.org/reference/details_mlp_keras.html)</span>, wir wählen jetzt für uns hier drei aus. Ich nehme hier auch nur drei Parameter, da sich dann drei Parameter noch sehr gut visuell darstellen lassen. In der Anwendung wäre dann natürlich besser alle Parameter zu tunen, aber das dauert dann auch lange.</span>
<span id="cb79-691"><a href="#cb79-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-692"><a href="#cb79-692" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`hidden_units`</span>, Anzahl der Ebenen (eng. *layer*) in dem neuronalen Netzwerk. Wie viele Ebenen soll unser Netzwerk haben? Oder auch wie *deep* soll das Netzwerk gebaut werden?</span>
<span id="cb79-693"><a href="#cb79-693" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`penalty`</span>, ein Wert für die Regulierung des neuronalen Netzwerk.</span>
<span id="cb79-694"><a href="#cb79-694" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`epochs`</span>, bezieht sich auf einen Zyklus durch die Layer für den gesamten Trainingsdatensatz. Wie oft rechnen wir den Trainingsdatensatz und trainieren unser Netzwerk?</span>
<span id="cb79-695"><a href="#cb79-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-696"><a href="#cb79-696" aria-hidden="true" tabindex="-1"></a>Nun ist es so, dass wir natürlich nicht händisch alle möglichen Kombinationen von der Anzahl der ausgewählten Variablen pro Baum, der kleinsten Knotengröße und der Anzahl der Bäume berechnen wollen. Das sind ziemlich viele Kombinationen und wir kommen dann vermutlich schnell durcheinander. Deshalb gibt es die Funktion <span class="in">`tune()`</span> aus dem R Paket <span class="in">`{tune}`</span>, die uns einen Prozess anbietet, das Tuning automatisiert durchzuführen.</span>
<span id="cb79-697"><a href="#cb79-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-698"><a href="#cb79-698" aria-hidden="true" tabindex="-1"></a>Da ich nicht ewig warten wollte, habe ich noch das parallele Rechnern aktiviert, in dem ich mir die Anzahl an Rechenkernen minus eins wiedergeben habe lassen.</span>
<span id="cb79-699"><a href="#cb79-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-702"><a href="#cb79-702" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-703"><a href="#cb79-703" aria-hidden="true" tabindex="-1"></a>cores <span class="ot">&lt;-</span> parallel<span class="sc">::</span><span class="fu">detectCores</span>() <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb79-704"><a href="#cb79-704" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-705"><a href="#cb79-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-706"><a href="#cb79-706" aria-hidden="true" tabindex="-1"></a>Als erstes müssen wir uns ein Objekt bauen, das aussieht wie ein ganz normales Modell in der Klassifikation. Aber wir ergänzen jetzt noch hinter jeder zu tunenden Option noch die Funktion <span class="in">`tune()`</span>. Das sind die Parameter des Algorithmus, die wir später tunen wollen.</span>
<span id="cb79-707"><a href="#cb79-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-710"><a href="#cb79-710" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-711"><a href="#cb79-711" aria-hidden="true" tabindex="-1"></a>tune_spec <span class="ot">&lt;-</span> <span class="fu">mlp</span>(<span class="at">hidden_units =</span> <span class="fu">tune</span>(),</span>
<span id="cb79-712"><a href="#cb79-712" aria-hidden="true" tabindex="-1"></a>                 <span class="at">penalty =</span> <span class="fu">tune</span>(), </span>
<span id="cb79-713"><a href="#cb79-713" aria-hidden="true" tabindex="-1"></a>                 <span class="at">epochs =</span> <span class="fu">tune</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb79-714"><a href="#cb79-714" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"keras"</span>, <span class="at">num.threads =</span> cores) <span class="sc">|&gt;</span> </span>
<span id="cb79-715"><a href="#cb79-715" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>) </span>
<span id="cb79-716"><a href="#cb79-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-717"><a href="#cb79-717" aria-hidden="true" tabindex="-1"></a>tune_spec</span>
<span id="cb79-718"><a href="#cb79-718" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-719"><a href="#cb79-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-720"><a href="#cb79-720" aria-hidden="true" tabindex="-1"></a>Jetzt bauen wir uns den Workflow indem wir statt unserem Modell, die Tuninganweisung in den Workflow reinnehmen. Echt simpel und straightforward. Das Rezept bleibt ja das Gleiche.</span>
<span id="cb79-721"><a href="#cb79-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-724"><a href="#cb79-724" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-725"><a href="#cb79-725" aria-hidden="true" tabindex="-1"></a>gummi_tune_wflow <span class="ot">&lt;-</span> <span class="fu">workflow</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-726"><a href="#cb79-726" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_model</span>(tune_spec) <span class="sc">|&gt;</span> </span>
<span id="cb79-727"><a href="#cb79-727" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_recipe</span>(gummi_rec)</span>
<span id="cb79-728"><a href="#cb79-728" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-729"><a href="#cb79-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-730"><a href="#cb79-730" aria-hidden="true" tabindex="-1"></a>Jetzt müssen wir noch alle Kombinationen aus den drei Parametern <span class="in">`hidden_units`</span>, <span class="in">`penalty`</span> und <span class="in">`epochs`</span> ermitteln. Das macht die Funktion <span class="in">`grid_regular()`</span>. Es gibt da noch andere Funktionen in dem R Paket <span class="in">`{tune}`</span>, aber ich konzentriere mich hier auf die einfachste. Jetzt müssen wir noch die Anzahl an Kombinationen festlegen. Ich möchte für jeden Parameter fünf Werte tunen. Daher nutze ich hier die Option <span class="in">`levels = 5`</span> auch damit hier die Ausführung nicht so lange läuft. Fange am besten mit <span class="in">`levels = 5`</span> an und schaue, wie lange das zusammen mit der Kreuzvalidierung dann dauert. Dann kannst du die Levels noch hochschrauben. Beachte aber, dass mehr Level nur mehr *Zwischenschritte* bedeutet. Jede Option hat eine Spannweite `range`, die du dann anpassen musst, wenn du *höhere* Werte haben willst. Mehr Level würden nur mehr Zwischenschritte bedeuten.</span>
<span id="cb79-731"><a href="#cb79-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-734"><a href="#cb79-734" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-735"><a href="#cb79-735" aria-hidden="true" tabindex="-1"></a>gummi_grid <span class="ot">&lt;-</span> <span class="fu">grid_regular</span>(<span class="fu">hidden_units</span>(<span class="at">range =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">100</span>)),</span>
<span id="cb79-736"><a href="#cb79-736" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">penalty</span>(),</span>
<span id="cb79-737"><a href="#cb79-737" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">epochs</span>(<span class="at">range =</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">200</span>)),</span>
<span id="cb79-738"><a href="#cb79-738" aria-hidden="true" tabindex="-1"></a>                           <span class="at">levels =</span> <span class="dv">5</span>)</span>
<span id="cb79-739"><a href="#cb79-739" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-740"><a href="#cb79-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-741"><a href="#cb79-741" aria-hidden="true" tabindex="-1"></a>Das Tuning nur auf dem Trainingsdatensatz durchzuführen ist nicht so eine gute Idee. Deshalb nutzen wir hier auch die Kreuzvalidierung. Eigentlich ist eine 10-fache Kreuzvalidierung mit $v=10$ besser. Das dauert mir dann aber hier im Skript viel zu lange. Deshalb habe ich hier nur $v=5$ gewählt. Wenn du das Tuning rechnest, nimmst du natürlich eine 10-fach Kreuzvalidierung.</span>
<span id="cb79-742"><a href="#cb79-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-745"><a href="#cb79-745" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-746"><a href="#cb79-746" aria-hidden="true" tabindex="-1"></a>gummi_folds <span class="ot">&lt;-</span> <span class="fu">vfold_cv</span>(gummi_train_data, <span class="at">v =</span> <span class="dv">5</span>)</span>
<span id="cb79-747"><a href="#cb79-747" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-748"><a href="#cb79-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-749"><a href="#cb79-749" aria-hidden="true" tabindex="-1"></a>Nun bringen wir den Workflow zusammen mit dem Tuninggrid und unseren Sets der Kreuzvaidierung. Daher pipen wir den Workflow in die Funktion <span class="in">`tune_grid()`</span>. Als Optionen brauchen wir die Kreuzvaldierungsdatensätze und das Tuninggrid. Wenn du <span class="in">`control_grid(verbose = TRUE)`</span> wählst, dann erhälst du eine Ausgabe wie weit das Tuning gerade ist. **Achtung!**, das Tuning dauert seine Zeit. Im Falle des keras Algorithmus dauert das Tuning **extrem lange**, aber immer noch nur ein paar Stunden. Wenn du dann alle fünf Parameter des keras Algorithmustunen wollen würdest, dann würde die Berechnung Tage dauern. Deshalb ist ein Großerechner mit mehreren Kernen unabdingbar für die Nutzung von *deep learning* Du kannst das Ergebnis des simpleren Tunings auch in der Datei <span class="in">`gummi_xgboost_tune_res.rds`</span> finden.</span>
<span id="cb79-750"><a href="#cb79-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-753"><a href="#cb79-753" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-754"><a href="#cb79-754" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-755"><a href="#cb79-755" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="ot">&lt;-</span> gummi_tune_wflow <span class="sc">|&gt;</span> </span>
<span id="cb79-756"><a href="#cb79-756" aria-hidden="true" tabindex="-1"></a>   <span class="fu">tune_grid</span>(<span class="at">resamples =</span> gummi_folds,</span>
<span id="cb79-757"><a href="#cb79-757" aria-hidden="true" tabindex="-1"></a>             <span class="at">grid =</span> gummi_grid,</span>
<span id="cb79-758"><a href="#cb79-758" aria-hidden="true" tabindex="-1"></a>             <span class="at">control =</span> <span class="fu">control_grid</span>(<span class="at">verbose =</span> <span class="cn">FALSE</span>))</span>
<span id="cb79-759"><a href="#cb79-759" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-760"><a href="#cb79-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-763"><a href="#cb79-763" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-764"><a href="#cb79-764" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb79-765"><a href="#cb79-765" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb79-766"><a href="#cb79-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-767"><a href="#cb79-767" aria-hidden="true" tabindex="-1"></a><span class="do">## write_rds(gummi_tune_res, "data/gummi_keras_tune_res.rds")</span></span>
<span id="cb79-768"><a href="#cb79-768" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-769"><a href="#cb79-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-770"><a href="#cb79-770" aria-hidden="true" tabindex="-1"></a>Damit du nicht das Tuning durchlaufen lassen musst, habe ich das Tuning in die Datei <span class="in">`gummi_xgboost_tune_res.rds`</span> abgespeichert und du kannst dann über die Funktion <span class="in">`read_rds()`</span> wieder einlesen. Dann kannst du den R Code hier wieder weiter ausführen.</span>
<span id="cb79-771"><a href="#cb79-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-774"><a href="#cb79-774" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-775"><a href="#cb79-775" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb79-776"><a href="#cb79-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-777"><a href="#cb79-777" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="ot">&lt;-</span> <span class="fu">read_rds</span>(<span class="st">"data/gummi_keras_tune_res.rds"</span>)</span>
<span id="cb79-778"><a href="#cb79-778" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-779"><a href="#cb79-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-780"><a href="#cb79-780" aria-hidden="true" tabindex="-1"></a>Nachdem das Tuning durchgelaufen ist, können wir uns über die Funktion <span class="in">`collect_metrics()`</span>, die Ergebnisse des Tunings für jede Kombination der drei Parameter <span class="in">`hidden_units`</span>, <span class="in">`penalty`</span> und <span class="in">`epochs`</span> wiedergeben lassen. Diese Ausgabe ist super unübersichtlich. Ich habe mich ja am Anfange des Abschnitts auch für drei Tuningparameter entschieden, da sich dann diese drei Parameter noch gut visualisieren lassen. Deshalb einmal die Abbildung der mittleren Accuarcy und der mittleren AUC-Werte über alle Kreuzvalidierungen.</span>
<span id="cb79-781"><a href="#cb79-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-784"><a href="#cb79-784" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-785"><a href="#cb79-785" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-786"><a href="#cb79-786" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-787"><a href="#cb79-787" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-788"><a href="#cb79-788" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-keras-02</span></span>
<span id="cb79-789"><a href="#cb79-789" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-790"><a href="#cb79-790" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 5</span></span>
<span id="cb79-791"><a href="#cb79-791" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 6</span></span>
<span id="cb79-792"><a href="#cb79-792" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Tuning Kurven für den `keras` Algorithmus."</span></span>
<span id="cb79-793"><a href="#cb79-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-794"><a href="#cb79-794" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb79-795"><a href="#cb79-795" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_metrics</span>() <span class="sc">|&gt;</span></span>
<span id="cb79-796"><a href="#cb79-796" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">hidden_units =</span> <span class="fu">as_factor</span>(hidden_units),</span>
<span id="cb79-797"><a href="#cb79-797" aria-hidden="true" tabindex="-1"></a>         <span class="at">penalty =</span> <span class="fu">as_factor</span>(penalty)) <span class="sc">|&gt;</span></span>
<span id="cb79-798"><a href="#cb79-798" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(epochs, mean, <span class="at">color =</span> hidden_units, <span class="at">linetype =</span> penalty)) <span class="sc">+</span></span>
<span id="cb79-799"><a href="#cb79-799" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb79-800"><a href="#cb79-800" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb79-801"><a href="#cb79-801" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb79-802"><a href="#cb79-802" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> .metric, <span class="at">scales =</span> <span class="st">"free"</span>, <span class="at">nrow =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb79-803"><a href="#cb79-803" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>(<span class="at">labels =</span> scales<span class="sc">::</span><span class="fu">label_number</span>()) <span class="sc">+</span></span>
<span id="cb79-804"><a href="#cb79-804" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_okabeito</span>()</span>
<span id="cb79-805"><a href="#cb79-805" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-806"><a href="#cb79-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-807"><a href="#cb79-807" aria-hidden="true" tabindex="-1"></a>Damit wir nicht händisch uns die beste Kombination raussuchen müssen, können wir die Funktion <span class="in">`show_best()`</span> nutzen.</span>
<span id="cb79-808"><a href="#cb79-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-811"><a href="#cb79-811" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-812"><a href="#cb79-812" aria-hidden="true" tabindex="-1"></a>gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb79-813"><a href="#cb79-813" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show_best</span>()</span>
<span id="cb79-814"><a href="#cb79-814" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-815"><a href="#cb79-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-816"><a href="#cb79-816" aria-hidden="true" tabindex="-1"></a>Das war die Funktion <span class="in">`show_best()`</span> aber wir können uns auch die gleich die besten Parameter nach der Accuracy raus ziehen. Das Rausziehen der besten Parameter macht für uns die Funktion <span class="in">`select_best()`</span>.</span>
<span id="cb79-817"><a href="#cb79-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-820"><a href="#cb79-820" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-821"><a href="#cb79-821" aria-hidden="true" tabindex="-1"></a>best_keras <span class="ot">&lt;-</span> gummi_tune_res <span class="sc">|&gt;</span></span>
<span id="cb79-822"><a href="#cb79-822" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select_best</span>()</span>
<span id="cb79-823"><a href="#cb79-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-824"><a href="#cb79-824" aria-hidden="true" tabindex="-1"></a>best_keras</span>
<span id="cb79-825"><a href="#cb79-825" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-826"><a href="#cb79-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-827"><a href="#cb79-827" aria-hidden="true" tabindex="-1"></a>Wir sehen, dass wir <span class="in">`hidden_units = 75`</span> wählen sollten. Dann müssen wir als Penalty <span class="in">`penalty = 0.0000000001`</span> nutzen. Die Anzahl an Durchläufen pro Training ist dann <span class="in">`epochs = 200`</span>. Müssen wir jetzt die Zahlen wieder in ein Modell eingeben? Nein, müssen wir nicht. Mit der Funktion <span class="in">`finalize_workflow()`</span> können wir dann die besten Parameter aus unserem Tuning gleich mit dem Workflow kombinieren. Dann haben wir unseren finalen, getunten Workflow. Du siehst dann auch in der Ausgabe, dass die neuen Parameter in dem keras Algorithmus übernommen wurden</span>
<span id="cb79-828"><a href="#cb79-828" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-831"><a href="#cb79-831" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-832"><a href="#cb79-832" aria-hidden="true" tabindex="-1"></a>final_gummi_wf <span class="ot">&lt;-</span> gummi_tune_wflow <span class="sc">|&gt;</span> </span>
<span id="cb79-833"><a href="#cb79-833" aria-hidden="true" tabindex="-1"></a>  <span class="fu">finalize_workflow</span>(best_keras)</span>
<span id="cb79-834"><a href="#cb79-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-835"><a href="#cb79-835" aria-hidden="true" tabindex="-1"></a>final_gummi_wf </span>
<span id="cb79-836"><a href="#cb79-836" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-837"><a href="#cb79-837" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-838"><a href="#cb79-838" aria-hidden="true" tabindex="-1"></a>Jetzt bleibt uns nur noch der letzte Fit übrig. Wir wollen unseren finalen, getunten Workflow auf die Testdaten anwenden. Dafür gibt es dann auch die passende Funktion. Das macht für uns die Funktion <span class="in">`last_fit()`</span>, die sich dann die Informationen für die Trainings- und Testdaten aus unserem Datensplit von ganz am Anfang extrahiert.</span>
<span id="cb79-839"><a href="#cb79-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-840"><a href="#cb79-840" aria-hidden="true" tabindex="-1"></a><span class="in">```{r keras-large-fit}</span></span>
<span id="cb79-841"><a href="#cb79-841" aria-hidden="true" tabindex="-1"></a><span class="in">#| cache: true</span></span>
<span id="cb79-842"><a href="#cb79-842" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb79-843"><a href="#cb79-843" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb79-844"><a href="#cb79-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-845"><a href="#cb79-845" aria-hidden="true" tabindex="-1"></a><span class="in">final_fit &lt;- final_gummi_wf |&gt;</span></span>
<span id="cb79-846"><a href="#cb79-846" aria-hidden="true" tabindex="-1"></a><span class="in">  last_fit(gummi_data_split) </span></span>
<span id="cb79-847"><a href="#cb79-847" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-848"><a href="#cb79-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-849"><a href="#cb79-849" aria-hidden="true" tabindex="-1"></a>Da wir immer noch eine Kreuzvaldierung rechnen, müssen wir dann natürlich wieder alle Informationen über alle Kreuzvaldierungsdatensätze einsammeln. Dann erhalten wir unsere beiden Gütekriterien für die Klassifikation des Geschlechts unser Studierenden nach dem keras Algorithmus. Die Zahlen sind schon gut für echte Daten. Eine Accuracy von 81% bedeutet das wir über acht von zehn Studierenden richtig klassifizieren. Die AUC ist auch schon fast hervorragend, wir bringen kaum Label durcheinander.</span>
<span id="cb79-850"><a href="#cb79-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-853"><a href="#cb79-853" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-854"><a href="#cb79-854" aria-hidden="true" tabindex="-1"></a>final_fit <span class="sc">|&gt;</span></span>
<span id="cb79-855"><a href="#cb79-855" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_metrics</span>()</span>
<span id="cb79-856"><a href="#cb79-856" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-857"><a href="#cb79-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-858"><a href="#cb79-858" aria-hidden="true" tabindex="-1"></a>Dann bleibt uns nur noch die ROC Kurve zu visualisieren. Da wir wieder etwas faul sind, nutzen wir die Funktion <span class="in">`autoplot()`</span>. Als Alternative geht natürlich auch das <span class="co">[</span><span class="ot">R Paket `{pROC}`</span><span class="co">](https://web.expasy.org/pROC/screenshots.html)</span>, was eine Menge mehr Funktionen und Möglichkeiten bietet.</span>
<span id="cb79-859"><a href="#cb79-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-862"><a href="#cb79-862" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb79-863"><a href="#cb79-863" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb79-864"><a href="#cb79-864" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb79-865"><a href="#cb79-865" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb79-866"><a href="#cb79-866" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-class-keras-03</span></span>
<span id="cb79-867"><a href="#cb79-867" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb79-868"><a href="#cb79-868" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 5</span></span>
<span id="cb79-869"><a href="#cb79-869" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 5</span></span>
<span id="cb79-870"><a href="#cb79-870" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "ROC Kurve für den `keras` Algorithmus nach der Kreuvalidierung und dem Tuning."</span></span>
<span id="cb79-871"><a href="#cb79-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-872"><a href="#cb79-872" aria-hidden="true" tabindex="-1"></a>final_fit <span class="sc">|&gt;</span></span>
<span id="cb79-873"><a href="#cb79-873" aria-hidden="true" tabindex="-1"></a>  <span class="fu">collect_predictions</span>() <span class="sc">|&gt;</span> </span>
<span id="cb79-874"><a href="#cb79-874" aria-hidden="true" tabindex="-1"></a>  <span class="fu">roc_curve</span>(gender, .pred_w, <span class="at">event_level =</span> <span class="st">"second"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb79-875"><a href="#cb79-875" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autoplot</span>()</span>
<span id="cb79-876"><a href="#cb79-876" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb79-877"><a href="#cb79-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-878"><a href="#cb79-878" aria-hidden="true" tabindex="-1"></a>Da wir eine ROC Kurve hier vorliegen haben, die sehr weit weg von der Diagonalen ist, haben wir sehr viele richtig vorhergesagte Studierende in unseren Testdaten. Unser Modell funktioniert um das Geschlecht von Studierenden anhand unserer Gummibärchendaten vorherzusagen. Besonders bei den neuronalen Netzwerken sieht man, wenn du die ROC Kurven vor und nach dem Tuning vergleichst, wie wichtig das Tuning ist. Dabei haben wir hier nur die abgespeckte Variante genutzt, da mein Rechner nicht länger laufen sollte.</span>
<span id="cb79-879"><a href="#cb79-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-880"><a href="#cb79-880" aria-hidden="true" tabindex="-1"></a><span class="fu">## Referenzen {.unnumbered}</span></span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Bio Data Science wurde von <a href="https://www.hs-osnabrueck.de/prof-dr-jochen-kruppa/">Jochen Kruppa-Scheetz</a> geschrieben.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/jkruppa/jkruppa.github.io/edit/master/classification-neural-networks.qmd" class="toc-action"><i class="bi bi-github"></i>Seite editieren</a></li><li><a href="https://github.com/jkruppa/jkruppa.github.io/issues/new" class="toc-action"><i class="bi empty"></i>Problem melden</a></li><li><a href="https://github.com/jkruppa/jkruppa.github.io/blob/master/classification-neural-networks.qmd" class="toc-action"><i class="bi empty"></i>Quellcode anzeigen</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Dieses Openbook wurde mit <a href="https://quarto.org/">Quarto</a> erstellt.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>