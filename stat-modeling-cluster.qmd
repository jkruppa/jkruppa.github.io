```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra)
```

# Clusteranalysen {#sec-cluster-analysis}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

> *"Cluster together like stars!" --- Henry Miller*

In diesem Kapitel wollen wir uns

Teilweise haben wir Überlagerungen mit dem Kapitel @sec-outlier

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, conflicted, 
               ggdendro, broom, cluster)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

Woher

[Palmer Penguins](https://allisonhorst.github.io/palmerpenguins/index.html)

```{r}
drymatter_tbl <- read_excel("data/meta/drymatter_iron_studies.xlsx") 
```

Schauen

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-meta-drymatter
#| tbl-cap: "Daten zu den Weizenerträgen nach der Gabe von einer Eisendosis mit $10\\mu mol$. In allen Studien wurde die gleiche Dosis auf die $n$ Pflanzen gegeben."

drymatter_tbl %>% 
  kable(align = "lrrr", "pipe")
```

Ein weiterer

```{r}
sunflower_tbl <- read_excel("data/meta/infected_sunflower_studies.xlsx") 
```

Auch

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-meta-sunflower
#| tbl-cap: "Daten zu den mit Mehltau infizierten Sonnenblumensamen nach der Behandlung mit MoldEx."

sunflower_tbl %>% 
  kable(align = "lrr", "pipe")
```

Häufig

## Heatmap

## Dendrogramm

```{r}
car <- select(mtcars, mpg, disp)
h.cluster <- car %>% dist(., method = "euclidean") %>% hclust(., method = "ward.D")
ggdendrogram(h.cluster)
```

```{r}
p.cluster <- car %>% kmeans(., 2)
p.cluster$cluster <- as.factor(p.cluster$cluster)

ggplot(car, aes(mpg, disp, label = rownames(car))) + 
  scale_fill_discrete(name = "Cluster") + xlim(9,35) +
  geom_label(aes(fill = p.cluster$cluster), colour = "white", 
  fontface = "bold", size=2)
```

```{r}
multi.clust <- data.frame(k = 1:6) %>% group_by(k) %>% do(clust = kmeans(car, .$k))
sumsq.clust <- multi.clust %>% group_by(k) %>% do(glance(.$clust[[1]]))

ggplot(sumsq.clust, aes(k, tot.withinss)) + geom_line() + geom_point()
```

```{r}
multi.clust <- data.frame(k = 1:6) %>% group_by(k) %>% do(clust = kmeans(car, .$k))
multi.k <- multi.clust %>% group_by(k) %>% do(augment(.$clust[[1]], car))

ggplot(multi.k, aes(mpg, disp)) + geom_point(aes(color = .cluster)) + 
  facet_wrap(~k)
```

Um das Ergebnis der Gruppenfindung zu beurteilen, eignet sich ein Silhouettenplot. Ein Silhouettenplot zeigt für jede Beobachtung i die Silhouettenbreite $s_i$, welche definiert ist als normierte Differenz der kleinsten Distanz zu den Beobachtungen außerhalb der eigenen Gruppe und dem Mittelwert der Distanzen innerhalb einer Gruppe. Die Silhouettenbreite $s_i$ kann jeden Wert im Intervall \[-1, 1\] annehmen und wird folgendermaßen interpretiert. - $s_i = 1$ Die Beobachtung ist dem "richtigen" Cluster zugeordnet. - $s_i = 0$ Die Beobachtung hätte ebenso gut einer anderen Gruppe zugeordnet werden können. - $s_i = -1$ Die Beobachtung ist schlecht zugeordnet. Es kann darüber hinaus die durchschnittliche Silhouettenbreite über alle Beobachtungen berechnet werden, womit sich die Gruppenbildung als Ganzes beurteilen lässt. Die durchschnittliche Silhouettenbreite wird analog interpretiert.

```{r}

data(ruspini)
pr4 <- pam(ruspini, 4)

si2 <- silhouette(pr4$clustering, dist(ruspini, "canberra"))
sil.data <- data.frame(cluster = factor(si2[, 1]), sil_width = si2[, 3])

ggplot(sil.data, aes(x = row.names(sil.data), y = sil_width, fill = cluster)) +
  geom_bar(stat = "identity", width = 0.5) + coord_flip() + labs(x = "") +
  scale_x_discrete(limits = row.names(sil.data[order(sil.data$cluster, 
  sil.data$sil_width), ])) 
```

## k-means Clusteranalyse

## Hauptkomponentenanalyse

## Referenzen {.unnumbered}
