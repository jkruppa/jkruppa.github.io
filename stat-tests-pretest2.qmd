```{r echo = FALSE}
#| message: false
#| warning: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc, quantreg,
               multcomp, emmeans, ggpubr, multcompView, nlme)
```

# Der Pre-Test oder Vortest {#sec-pretest}

*Letzte Änderung am `r format(fs::file_info("stat-tests-pretest2.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

> *"I struggle with some demons; They were middle class and tame." --- Leonard Cohen, You Want It Darker*

text

## Allgemeiner Hintergrund

text

#### Flowchart {.unnumbered .unlisted}

text

```{mermaid}
%%| label: fig-mermaid-pretest-01
%%| fig-width: 6
%%| fig-cap: "Flowchart für die Entscheidung welches statistische Modell gerechnet werden kann: `lm()`, lineare Regression, `gls()`, generalized least squares Regression, `rq()`, Quantilesregression. Die Funktionen finden sich teilweise in eigenen R Paketen. Bei einem nicht-normalverteilten Outcome mit Varianzheterogenität über die Gruppen müssen wir nochmal gemeinsam in die Daten schauen."
flowchart TD
    A("Normalverteiltes Outcome
       in jeder Versuchsgruppe"):::factor --- B(((ja))) --> B1 
    A("Normalverteiltes Outcome
       in jeder Versuchsgruppe"):::factor --- F(((nein))) --> B2
    subgraph B1["Mittelwertsvergleiche"]
    C("Varianzhomogenität
       über alle Gruppen"):::factor --- D((("ja"))) --> E("lm()"):::factor
    C("Varianzhomogenität
       über alle Gruppen"):::factor --- J(((nein))) --> K("gls()"):::factor 
    end
    subgraph B2["Medianvergleiche, OR oder RR"]
    G("Varianzhomogenität
       über alle Gruppen"):::factor --- H(((ja))) --> I("rq()"):::factor  
    G("Varianzhomogenität
       über alle Gruppen"):::factor --- L(((nein))) 
    end
    classDef factor fill:#56B4E9,stroke:#333,stroke-width:0.75px
```

Du findest die vorgeschlagenen Funktionen dann in den entsprechenden Kapiteln zur ANOVA und den Posthoc-Tests. Du kannst dir dann dort den Code zusammensuchen. Je nach deiner Datenlage musst du dann nochmal etwas an dem R Code programmieren. Beachte, dass die Funktionen sich teilweise in eigenen R Paketen finden lassen. So ist die Funktion `gls()` im R Paket `{nlme}` und die Funktion `rq()` im R Paket `{quantreg}` zu finden. Du kannst auch bei Varianzheterogenität das R Paket `{sandwich}` nutzen und einen entsprechend angepassten Varianzschätzer. Mehr findest du dazu bei den Posthoc-Test in dem Abschnitt zu dem [Gruppenvergleich unter Varianzheterogenität](#sec-posthoc-var-heterogen) oder gleich im ersten Zerforschenbeispiel zum einfaktoriellen Barplot.

::: {.callout-tip collapse="true"}
## Exkurs: Robuste Schätzung von Standardfehlern, Konfidenzintervallen und p-Werten

Wenn du noch etwas weiter gehen möchtest, dann kannst du dir noch die Hilfeseite von dem R Paket `{performance}` [Robust Estimation of Standard Errors, Confidence Intervals, and p-values](https://easystats.github.io/parameters/articles/model_parameters_robust.html?q=Heteroskedasticity#robust-covariance-matrix-estimation-from-model-parameters) anschauen. Die Idee ist hier, dass wir die Varianz/Kovarianz robuster daher mit der Berücksichtigung von Varianzheterogenität (eng. *heteroskedasticity*) schätzen.
:::

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, olsrr,
               broom, car, performance, 
               see, scales, readxl, nlme,
               conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
```

An der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.

## Daten

## Visuelle Überprüfung

### Normalverteilung

### Varianzhomogenität

## Statistische Überprüfung

### Normalverteilung

::: panel-tabset
## Theoretisch

## `shapiro.test()`

## `check_normality()`
:::

### Varianzhomogenität

::: panel-tabset
## Theoretisch

## `leveneTest()`

## `bartlett.test()`

## `check_homogeneity()`

Wir können auch die Funktion `check_homogeneity()` aus dem Paket `{performance}` nutzen. Wir erhalten hier auch gleich eine Entscheidung in englischer Sprache ausgegeben. Die Funktion `check_homogeneity()` nutzt den Bartlett-Test. Wir können in Funktion auch andere Methoden mit `method = c("bartlett", "fligner", "levene", "auto")` wählen.

Wir sehen, dass sich die Implementierung des Bartlett-Tests in `check_homogeneity()` nicht von der Funktion `bartlett.test()` unterscheidet, aber die Entscheidung gegen die Varianzhomogenität zu einem Signifikanzniveau von 5% gefällt wird. Nicht immer hilft einem der Entscheidungtext einer Funktion.
:::

## Referenzen {.unnumbered}
