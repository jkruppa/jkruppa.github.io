```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra)
```

# Poisson Regression {#sec-poisson}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

## Annahmen an die Daten

[Unser gemessenes Outcome $y$ folgt einer Poissonverteilung.]{.aside}

Im folgenden Kapitel zu der multiplen Poisson linearen Regression gehen wir davon aus, dass die Daten in der vorliegenden Form *ideal* sind. Das heißt wir haben weder fehlende Werte vorliegen, noch haben wir mögliche Ausreißer in den Daten. Auch wollen wir keine Variablen selektieren. Wir nehmen alles was wir haben mit ins Modell. Sollte eine oder mehre Bedingungen nicht zutreffen, dann schaue dir einfach die folgenden Kapitel an.

-   Wenn du fehlende Werte in deinen Daten vorliegen hast, dann schaue bitte nochmal in das @sec-missing zu Imputation von fehlenden Werten.
-   Wenn du denkst, dass du Ausreißer oder auffälige Werte in deinen Daten hast, dann schaue doch bitte nochmal in das @sec-outlier zu Ausreißer in den Daten.
-   Wenn du denkst, dass du zu viele Variablen in deinem Modell hast, dann hilft dir das @sec-variable-selection bei der Variablenselektion.

Daher sieht unser Modell wie folgt aus. Wir haben ein $y$ und $p$-mal $x$. Wobei $p$ für die Anzahl an Variablen auf der rechten Seite des Modells steht. Im Weiteren folgt unser $y$ einer Poissonverteilung. Das ist hier sehr wichtig, denn wir wollen ja eine multiple Poisson lineare Regression rechnen.

$$
y \sim x_1 + x_2 + ... + x_p 
$$

Wir können in dem Modell auch Faktoren $f$ haben, aber es geht hier nicht um einen Gruppenvergleich. Das ist ganz wichtig. Wenn du einen Gruppenvergleich rechnen willst, dann musst du in @sec-posthoc nochmal nachlesen.

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, conflicted, broom,
               parameters, performance, MASS, pscl)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

::: column-margin
Die Daten zu den langnasigen Hechten stammt von [Salvatore S. Mangiafico - An R Companion for the Handbook of Biological Statistics](https://rcompanion.org/rcompanion/e_05.html).
:::

Im folgenden schauen wir uns ein Datenbeispiel mit Hechten an. Es handelt sich um langnasige Hechte in nordamerikanischen Flüssen. Wir haben uns insgesamt $n = 68$ Flüsse einmal angesehen und dort die Anzahl an Hechten gezählt. Im Weiteren haben wir dann noch andere Flussparameter erhoben und fragen uns nun, welche dieser Parameter einen Einfluss auf die Anzahl an Hechten in den Flussarmen haben. In @sec-example-longnose findest du nochmal mehr Informationen zu den Daten.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-pois-longnose
#| tbl-cap: Auszug aus dem Daten zu den kranken Ferkeln.
#| column: page

longnose_tbl <- read_csv("data/longnose.csv") 

rbind(head(longnose_tbl, n = 4),
      rep("...", times = ncol(longnose_tbl)),
      tail(longnose_tbl, n = 4)) %>% 
  kable(align = "c", "pipe")
```

Im Folgenden werden wir die Daten nur für das Fitten eines Modells verwenden. In den anderen oben genannten Kapiteln nutzen wir die Daten dann anders.

## Fit des Modells

In diesem Abschnitt wollen wir verschiedene Modelle für Zähldaten schätzen. Die Poissonverteilung hat keinen eignen Parameter für die Streung wie die Normalverteilung. Die Poissonverteilung ist mit $\mathcal{Pois}(\lambda)$ definiert und hat somit die Eigenschaft das die Varianz eins zu eins mit dem Mittelwert $\lambda$ der Poissonverteilung ansteigt. Es kann aber sein, dass wir in den Daten nicht diesen ein zu eins Zusammenhang von Mittelwert und Varianz vrliegen haben. Häufig ist die Varianz viel größer und steigt schneller an. Wenn die Varianz in Wirklichkeit sehr viel größer ist, dann würden wir die Varianz in unseren Modell unterschätzen.

-   Ein klassisches Poissonmodell `glm(..., familiy = poisson)` mit der Annahme keiner Overdisperison.
-   Ein Quasi-Poissonmodell `glm(..., family = quasipoisson)` mit der Möglichkeit der Berücksichtigung einer Overdispersion.
-   Ein negative Binomialmodell `glm.nb(...)` ebenfalls mit der Berücksichtigung einer Overdispersion.

Beginnen wollen wir aber mit einer klassischen Poissonregression ohne die Annahme von einer Overdispersion in den Daten. Wir nutzen dafür die Funktion `glm()` und spezifizieren die Verteilungsfamilie als `poisson`. Wir nehmen wieder alle Variablen in das Modell auf der rechten Seite des `~`. Auf der linken Seite des `~` kommt dann unser Outcome `longnose` was die Anzahl an Hechten erhält.

```{r}
poisson_fit <- glm(longnose ~ area + do2 + maxdepth + no3 + so4 + temp,
                    longnose_tbl, family = poisson)
```

Wir schauen uns die Ausgabe des Modells einmal mit der `summary()` Funktion an, da wir hier einmal händisch schauen wollen, ob eine Overdispersion vorliegt. Sonst könnten wir auch die Funktion `model_parameters()` nehmen. Die nutzen wir später für die Interpretation des Modells, hier wollen wir erstmal sehen, ob alles geklappt hat.

```{r}
poisson_fit %>% summary
```

Wir schauen in die Summary-Ausgabe des Poissonmodells und sehen, dass dort steht, dass `Dispersion parameter for poisson family taken to be 1`. Wir modellieren also einen eins zu eins Zusammenhang von Mittelwert und Varianz. Wenn dieser Zusammenhang nicht in unseren Daten existiert, dann haben wir eine Overdispersion vorliegen.

Wir können die Overdispersion mit abschätzen indem wir die `Residual deviance` durch die Freiheitsgrade der `Residual deviance` teilen. Daher erhalten wir eine Overdispersion von $\cfrac{1590.04}{61} \approx 26.1$. Damit haben wir eine eindeutige Overdispersion vorliegen. Damit steigt die Varianz in einem Verhältnis von ca. 1 zu 26. Wir können auch die Funktion `check_overdispersion()` aus dem R Paket `performance` nutzen um die Overdispersion zu berechnen. Die Funktion kann das schneller und ist auch in der Abfolge einer Analyse besser geeignet.

```{r}
poisson_fit %>% check_overdispersion()
```

Wenn wir Overdispersion vorliegen haben und damit die Varianz zu niedrig schätzen, dann erhalten wir viel mehr signifikante Ergebnisse als es in den Daten zu erwarten wäre. Schauen wir uns nochmal die Parameter der Poissonverteilung und die $p$-Werte einmal an.

```{r}
#| message: false

poisson_fit %>% model_parameters()
```

In der Spalte `p` finden wir die $p$-Werte für alle Variablen. Wir sehen, dass fast alle Variablen signifikant sind und das wir eine sehr niedrige Varianz in der Spalte `SE` sehen. Das heißt unser geschätzer Fehler ist sehr gering. Das ahnten wir ja schon, immerhin haben wir eine Overdisperson vorliegen. Das Modell ist somit falsch. Wir müssen uns ein neues Modell suchen, was Overdispersion berückscihtigen und modellieren kann.

Die Quasi-Poisson Verteilung hat einen zusätzlichen, unabhänigen Parameter um die Varianz der Verteilung zu schätzen. Daher können wir die Overdispersion mit einer Quasi-Poisson Verteilung berückscihtigen. Wir können eine Quasi-Poisson Verteilung auch mit der Funktion `glm()` schätzen nur müssen wir als Verteilungsfamilie `quasipoisson` angeben.

```{r}
quasipoisson_fit <- glm(longnose ~ area + do2 + maxdepth + no3 + so4 + temp,
                        data = longnose_tbl, family = quasipoisson)
```

```{r}
quasipoisson_fit %>% summary
```

```{r}
negativebinomial_fit <- glm.nb(longnose ~ area + do2 + maxdepth + no3 + so4 + temp,
                               data = longnose_tbl)


```

```{r}
negativebinomial_fit %>% summary
```

## Performance des Modells

## Interpretation des Modells

```{r}

poisson_fit %>% summary

## ?berschlagsrechnung f?r die Dispersion
## (aus dem glm summary): Residual deviance: 1590.04  on 61  degrees of freedom
1590.04/61

quasipoisson_fit <- glm(longnose ~ area + do2 + maxdepth + no3 + so4 + temp,
                        longnose_tbl, family = quasipoisson)

quasipoisson_fit %>% summary

negativebinomial_fit <- glm.nb(longnose ~ area + do2 + maxdepth + no3 + so4 + temp,
                           longnose_tbl)

negativebinomial_fit %>% summary


## wir machen mit den quasifit weiter

quasipoisson_fit %>% tidy(conf.int = TRUE, exponentiate = TRUE)

## How much is the fish?
sample_size <- 10000
longnose_small_tbl <- tibble(grp = rep(c(0, 1), each = sample_size),
         resp = 15 + 10 * grp + rnorm(2 * sample_size, 0, 1)) %>%
  mutate(resp_count = round(resp),
         grp = factor(grp, labels = c("ctrl", "trt")))

ggplot(longnose_small_tbl, aes(x = grp, y = resp, fill = grp)) +
  geom_boxplot()

glm(resp_count ~ grp, data = longnose_small_tbl, family = gaussian)

glm(resp_count ~ grp, data = longnose_small_tbl, family = poisson) %>%
  tidy(exponentiate = TRUE)

quasipoisson_fit <- glm(longnose ~ temp,
                        longnose_tbl, family = quasipoisson)
quasipoisson_fit %>% tidy(conf.int = TRUE, exponentiate = TRUE)


gaussian_fit <- glm(longnose ~ temp,
                        longnose_tbl, family = gaussian)
gaussian_fit %>% tidy(conf.int = TRUE, exponentiate = TRUE)

hist(longnose_tbl$longnose)

summary(longnose_tbl$longnose)

```

## Overdispersion

## Zeroinflation
