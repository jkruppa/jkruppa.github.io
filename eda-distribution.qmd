# Verteilung von Daten

```{r}
#| warning: false
#| echo: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, see, conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("summarise", "dplyr")
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

::: column-margin
Wir besuchen gerne die R Shiny App [The distribution zoo](https://ben18785.shinyapps.io/distribution-zoo/) um mehr über die verschiedenen Verteilungen und deren Parameter zu erfahren.
:::

In diesem Kapitel wollen wir uns mit Verteilungen beschäftigen. @dormann2013parametrische liefert eine weitreichende Übersicht über verschiedene Verteilungen. Wir wollen uns in diesem Kapitel mit folgenden Verteilungen beginnen.

-   der **Normalverteilung**, die Glockenkurve oder auch **Gaussian** im englischen Sprachgebrauch genannt, die kontinuierliche Zahlen repräsentiert
-   der **Poissonverteilung**, die diskrete Zähldaten repräsentiert.

Wir wollen uns jetzt die verschiedenen Verteilungen einmal in der Anwendung anschauen. Dabei lassen wir viel Mathematik recht und links liegen. Du kannst bei @dormann2013parametrische mehr zu dem Thema statistische Verteilungen anlesen.

In diesem Kapitel geht es erstmal um das Grundverständnis, das Daten einer Verteilung folgen. Oder noch konkreter, dass unser Outcome $y$ einer Verteilung folgt. Wir müssen später unseren Alogrithmen sagen, welcher Verteilung $y$ entspringt, sonst können wir keine *korrekte* Analyse unser Daten rechnen.

::: column-margin
![](images/angel_01.png){fig-align="center" width="50%"}

Wir halten den mathematischen Teil zu den Verteilungen sehr kurz oder überspringen den Teil ganz. Wir brauchen die Idee der Verteilungen, weil wir später den Methoden sagen müssen wie unser Outcome $y$ verteilt ist. Nur dann können wir die Daten richtig auswerten.
:::

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
pacman::p_load(tidyverse, magrittr, see, readxl)
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten für Verteilungen

Damit wir uns auch eine Verteilung anschauen können bruachen wir *viele* Beobachtungen. Wir haben das ja schon bei den Histogrammen gesehen, wenn wir ein aussagekräftiges Histogramm erstellen wollen, dann brauchen wir viele Beobachtungen. Daher nehmen wir für dieses Kapitel einmal den Gummibärchendatensatz und schauen uns dort die Variablen `gender`, `height`, `count_bears` und `count_color` einmal genauer an. Wie immer nutzen wir die Funktion `select()` um die Spalten zu selektieren. Wir müssen jetzt nochmal alle fehlenden Werte mit der Funktion `na.omit()` entfernen, dass macht uns die Sache etwas leichter. Abschließend verwandeln wir das Geschlecht `gender` noch in einen Faktor.

```{r}
#| message: false

gummi_tbl <- read_excel("data/gummibears.xlsx")  %>%
  select(gender, height, count_bears, count_color) %>% 
  na.omit() %>% 
  mutate(gender = as_factor(gender))
```

Wir erhalten das Objekt `gummi_tbl` mit dem Datensatz in @tbl-data-dist-gummi nochmal dargestellt.

```{r}
#| message: false
#| echo: false
#| tbl-cap: Auszug aus den selektierten Daten zu den Gummibärchendaten.
#| label: tbl-data-dist-gummi

gummi_print_tbl <- gummi_tbl %>% 
  mutate(gender =  as.character(gender))
rbind(head(gummi_print_tbl),
      rep("...", times = ncol(gummi_print_tbl)),
      tail(gummi_print_tbl)) %>% 
  kable(align = "c", "pipe")
```

Wir nutzen jetzt die Daten einmal um uns die Normalverteilung und die Poissonverteilung am Beispiel näher anzuschauen.

## Die Normalverteilung {#sec-normal}

[Wir sprechen in der Statistik auch von Verteilungs*familien*. Daher schreiben wir in R auch `family = gaussian`, wenn wir sagen wollen, dass unsere Daten einer Normalverteilung entstammen.]{.aside}

Wenn wir von de Normalverteilung sprechen, dann schreiben wir ein $\mathcal{N}$ Symbol - also ein großes N mit Serifen. Die Normalverteilung sieht aus wie eine Glocke, deshalb wird die Normalverteilung auch Glockenkurve genannt. Im englischen Sprachgebrauch und auch in R nutzen wir dagegen die Bezeichnung nach dem "Endecker" der Normalverteilung, Carl Friedrich Gauß (1777 - 1985). Wir nennen daher die Normalverteilung auch Gaussian-Verteilung.

Eine Normalverteilung wird ruch zwei Verteilungs*parameter* definiert. Wir brauchen zum einen den Mittelwert $\bar{y}$, der den höchsten Punkt unserer Glockenkurve beschreibt. Zum anderen brauchen wir auch die Standardabweichung $s^2_y$, die die Ausbreitung oder Breite der Glockenkurve bestimmt. Wir beschreiben eine Normalverteilung wie folgt.

$$
\mathcal{N}(\bar{y}, s^2_y)
$$

Je nach $\bar{y}$ und $s^2_y$ können wir verschiedenste Normalverteilungen vorliegen haben. Eine Sammlung von Normalverteilungen nennen wir auch Familie (eng. *family*).

[Wir haben Varianzhomogenität vorliegen, wenn $s^2_{1} = s^2_{2} = s^2_{3} = 2$. Wir haben Varianzheterogenität vorliegen, wenn \$s\^2\_{1} \neq s\^2\_{2} \neq s\^2\_{3} \$]{.aside}

In @fig-normal-02 sehen wir verschiedene Normalverteilungen mit unterschiedlichen Mittelwerten. In @fig-normal-02-1 sehen wir eine Varianzhomogenität vorliegen, da die Varianzen in allen drei Normalverteilungen gleich sind. Wir können auch schreiben, dass $s^2_{1} = s^2_{2} = s^2_{3} = 2$. In @fig-normal-02-2 haben wir Varianzheterogenität vorliegen, da die Varianzen der Normalverteilungen ungleich sind. Wir können hier dann schreiben, dass $s^2_{1} = 6 \neq s^2_{2} = 1 \neq s^2_{3} = 3$ sind. Häufig gehen statistische Verfahren davon aus, dass wir Varianzhomogenität über die Gruppen und daher auch die Normalverteilungen vorliegen haben. Konkret, wenn wir die Sprungweiten in\[cm\] von Hunde- und Katzenflöhen mit einander vergleichen wollen, dann gehen wir erstmal davon aus, dass die Mittelwerte verschieden sind, aber die Varianzen gleich sind.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-normal-02
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramm verschiedener Normalverteilungen mit unterschiedlichen Mittelwerten."
#| fig-subcap: 
#|   - "Drei Normalverteilungen mit Varianzhomogenität."
#|   - "Drei Normalverteilungen unter Varianzheterogenität."
#| layout-nrow: 1
#| column: page


set.seed(20220789)
norm_tbl <- tibble(n1 = rnorm(10000, 10, 2),
                   n2 = rnorm(10000, 20, 2),
                   n3 = rnorm(10000, 0, 2)) %>% 
  gather()

ggplot(data = norm_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(position = position_identity(), alpha = 0.75, color = "black") +
  labs(x = "", y = "Anzahl") +
  xlim(-15, 30) +
  theme(legend.position = "none") +
  scale_fill_okabeito() +
  annotate("text", 0, 3200, label = expression(paste("N(0,2)")),
           color = cbbPalette[4]) +
  annotate("text", 10, 3200, label = expression(paste("N(10,2)")),
           color = cbbPalette[2]) +
  annotate("text", 20, 3200, label = expression(paste("N(20,2)")),
           color = cbbPalette[3]) 

set.seed(20220789)
norm_tbl <- tibble(n1 = rnorm(10000, 10, 1),
                   n2 = rnorm(10000, 20, 3),
                   n3 = rnorm(10000, 0, 6)) %>% 
  gather()

ggplot(data = norm_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(binwidth = 1, position = position_identity(), alpha = 0.75, color = "black") +
  labs(x = "", y = "Anzahl") +
  xlim(-15, 30) +
  theme(legend.position = "none") +
  scale_fill_okabeito() +
  annotate("text", 0, 900, label = expression(paste("N(0,6)")),
           color = cbbPalette[4]) +
  annotate("text", 10, 4100, label = expression(paste("N(10,1)")),
           color = cbbPalette[2]) +
  annotate("text", 20, 1500, label = expression(paste("N(20,3)")),
           color = cbbPalette[3]) 
```

[In einer Normalverteilung liegen 68% der Werte innerhalb $\bar{y}\pm 1 \cdot s_y$ und 95% der Werte innerhalb $\bar{y}\pm 2 \cdot s_y$]{.aside}

Wenn wir eine Normalverteilung vorliegen haben, dann liegen 68% der Werte plus/minus einer Standardabweichung vom Mittelwert. Ebenso liegen 95% der Werte plus/minus zwei Standabweichungen vom Mittelwert. Über 99% der Werte befinden sich innerhalb von drei Standardabweichungen vom Mittelwert. Diese Eigenschaft einer Normalverteilung können wir später noch nutzen um abzuschätzen, ob wir einen relevanten Gruppenunterschied vorliegen haben oder aber ob unsere Daten *unnatürlich* breit streuen.

Schauen wir uns die Normalverteilung einmal am Beispiel unserer Gummibärchendaten und der Körpergröße der Studierenden an. Wir färben das Histogramm nach dem Geschlecht ein. In @fig-normal-01 sehen wir das Ergebnis einmal als Histogramm und einmal als Densityplot dargestellt.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-normal-01
#| fig-cap: "Darstellung der Körpergröße in [cm] für die Geschlechter getrennt."
#| fig-subcap: 
#|   - "Histogramm."
#|   - "Densityplot."
#| layout-nrow: 1
#| column: page

ggplot(data = gummi_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "Anzahl", fill = "Geschlecht") +
  scale_x_continuous(breaks = seq(150, 200, by = 5)) +
  scale_fill_okabeito() 

ggplot(data = gummi_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 205, by = 5), limits = c(145, 205)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

```

Wir können die Funktion `rnorm()` nutzen um uns zufällige Zahlen aus der Normalverteilung ziehen zu lassen. Dazu müssen wir mit `n =` spezifizieren wie viele Beobachtungen wir wollen und den Mittelwert `mean =` und die gewünschte Standardabweichung mit `sd =` angeben. Im Folgenden einmal ein Beispiel für die Nutzung der Funktion `rnorm()` mit zehn Werten.

```{r}
rnorm(n = 10, mean = 5, sd = 2) %>% round(2)
```

Du kannst ja mal den Mittelwert und die Standardabweichung der zehn Zahlen ausrechnen. Da wir es hier mit einer Stichprobe mit zehn Beobachtungen zu tun haben, wird der Mittelwert $\bar{y}$ und die Standardabweichung $s_y$ sich von den vorher definierten Mittelwert $\mu_y = 5$ und Standardabweichung $\sigma_y = 2$ der Grundgesamtheit unterscheiden.

Wir können auch aus unseren Gummibärchendaten für die Körpergröße in \[cm\] jeweils den Mittelwert und die Standardabweichung getrennt für die Geschlechter berechnen und dann die theoretische Normalverteilung zeichenen. In @fig-normal-03-2 und @fig-normal-03-4 sehen wir die Verteilung der theoretischen Werte, wenn wir die Mittelwerte und die Standardabweichung aus den Verteilungen in @fig-normal-03-1 schätzen.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-normal-03
#| fig-cap: "Darstellung der Körpergröße in [cm] für die Geschlechter getrennt. Auf der linken Seite die beobachteten Werte und auf der rechten Seite die theoretischen Werte. Einmal dargestellt als Histogramm und einmal als Densityplot."
#| fig-subcap: 
#|   - "Verteilung der beobachteten Werte."
#|   - "Verteilung der theoretischen Werte."
#| layout-nrow: 2
#| column: page

stat_tbl <- gummi_tbl %>% 
  group_by(gender) %>% 
  summarise(mean = mean(height),
            sd = sd(height),
            n = n())

gummi_theo_tbl <- tibble(height = c(with(filter(stat_tbl, gender == "m"), rnorm(n, mean, sd)),
                                    with(filter(stat_tbl, gender == "w"), rnorm(n, mean, sd))),
                         gender = rep(c("m", "w"), c(134, 168	)))


ggplot(data = gummi_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "Anzahl", fill = "Geschlecht") +
  scale_x_continuous(breaks = seq(150, 200, by = 5)) +
  scale_fill_okabeito() +
  scale_y_continuous(breaks = seq(0, 25, 5), limits = c(0, 25))

ggplot(data = gummi_theo_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_histogram(position = "dodge", color = "black") +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_y_continuous(breaks = seq(0, 25, 5), limits = c(0, 25))

ggplot(data = gummi_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 205, by = 5), limits = c(145, 205)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

ggplot(data = gummi_theo_tbl, aes(x = height, fill = gender)) +
  theme_bw() +
  geom_density(alpha = 0.75) +
  labs(x = "", y = "", fill = "Geschlecht") +
  scale_fill_okabeito() +
  scale_x_continuous(breaks = seq(145, 205, by = 5), limits = c(145, 205)) +
  scale_y_continuous(breaks = seq(0, 0.06, 0.01), limits = c(0, 0.06))

```

## Die Standardnormalverteilung

Es gibt viele Normalverteilungen. Aber es gibt eine besondere Normalverteilung, so dass diese Verteilung einen eigenen Namen hat. Wir sprechen von der Standardnormalverteilung, wenn der Mittelwert gleich Null ist und die Standardabweichung gleich Eins. Du siehst hier nochmal die Standardnormalverteilung ausgeschrieben.

$$
\mathcal{N}(0, 1)
$$

Folgende Eigenschaften sind der Standardnormalverteilung gegeben. Die Standardnormalverteilung hat eine Fläche von $A = 1$ unter der Kurve. Darüber hinaus liegen 95% der Werte zwischen -2 und 2. Die einzelnen Werte einer Standardnormalverteilung nennen wir $z$-Werte. Wenn wir eine beliebige Normalverteilung in eine Standardnormalverteilung überführen wollen so machen wir die Umwandlung mit der $z$-Transformation.

## Die Poissonverteilung {#sec-poisson}

Eine weitere wichtige Verteilung ist die Poissonverteilung. Die Poissonverteilung ist eine diskrete Verteilung. Daher kommen nur ganze Zahlen vor. Damit bildet die Poissonverteilung die Zähldaten ab. Wenn wir also etwas Zählen, dann ist diese Variable mit den gezählten Ergebnissen poissonverteilt. Im Folgenden sehen wir die Poissonverteilung einmal dargestellt.

$$
\mathcal{Pois}(\lambda)
$$

Im Gegensatz zur Normalverteilung hat die Poissonverteilung nur einen Parameter. Den Lageparameter $\lambda$ ausgedrückt durch den griechischen Buchstaben Lambda. Eine Poissonverteilung mit $\mathcal{Pois}(4)$ hat den höchsten Punkt bei vier. Nun hat die Poissonverteilung hat mehrere Besonderheiten. Da die Poissonverteilung keinen Streuungsparameter hat, steigt mit dem $\lambda$ auch die Streuung. Daher haben Poissonverteilungen mit einem großen $\lambda$ auch eine große Streuung. Du kannst das in @fig-pois-00 beobachten.

Darüber hinaus kann eine Poissonverteilung nicht negativ werden. Es kann keine kleinere Zahl als die Null geben. Durch die diskreten Zahlen haben wir auch immer mal Lücken zwischen den Balken der Poissonverteilung. Das passiert besonders, wenn wir eine kleine Anzahl an Beobachtungen haben. Abschließend konvergiert die Poissonverteilung bei großen $\lambda$ hin zu einer Normalverteilung.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-pois-00
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramm verschiedener Poissonverteilungen."

set.seed(20220789)
pois_tbl <- tibble(lambda1 = rpois(1000, 6),
              lambda2 = rpois(1000, 10),
              lambda3 = rpois(1000, 1)) %>% 
  gather()

ggplot(data = pois_tbl, aes(x = value, fill = key)) +
  theme_bw() +
  geom_histogram(binwidth = 1, position = position_dodge(0.95), color = "black") +
  labs(x = "", y = "Anzahl") +
  theme(legend.position = "none") +
  scale_x_continuous(breaks = 0:25, limits = c(0,NA)) +
  scale_fill_okabeito() +
  annotate("text", 4, 250, label = expression(paste("Pois(", lambda, " = 1)")),
           color = cbbPalette[4]) +
  annotate("text", 6, 180, label = expression(paste("Pois(", lambda, " = 6)")),
           color = cbbPalette[2]) +
  annotate("text", 10, 150, label = expression(paste("Pois(", lambda, " = 10)")),
           color = cbbPalette[3]) 
```

Schauen wir uns nun einmal die Poissonverteilung im Beispiel an. In @fig-pois-01 sehen wir die Histogramme der Anzahl an Gummibärchen in einer Tüte und die Anzahl an Farben in einer Tüte. Da wir es hier mit Zähldaten zu tun haben, könnte es sich um eine Poissonverteilung handeln. Wie müssen uns nun die Frage stellen, ob die Gummibärchen in einer Tüte und die Anzahl an Farben in einer Tüte *wirklich* eine zufällige Realistierung sind. Daher eine zufällige Stichprobe der Grundgesamtheit. Wir können diese Annahme überprüfen in dem wir die theoretischen Werte für die beiden Poissonverteilung mit $\mathcal{Pois}(10)$ und $\mathcal{Pois}(5)$ genieren.

```{r}
#| message: false
#| echo: false
#| label: fig-pois-01
#| fig-align: center
#| fig-height: 5
#| fig-width: 5
#| fig-cap: "Histogramme der Anzahl an Gummibärchen und die Anzahl an Farben in einer Tüte. Es gibt nicht mehr als sechs Farben."
#| fig-subcap: 
#|   - "Anzahl an Bärchen"
#|   - "Anzahl an Farben"
#| layout-nrow: 1
#| column: page

ggplot(data = gummi_tbl, aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[2]) +
  labs(x = "", y = "Anzahl") 

ggplot(data = gummi_tbl, aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[3]) +
  labs(x = "", y = "Anzahl") 


```

Wir können die Funktion `rpois()` nutzen um uns zufällige Zahlen aus der Poissonverteilung ziehen zu lassen. Dazu müssen wir mit `n =` spezifizieren wie viele Beobachtungen wir wollen und den Mittelwert `lambda =` angeben. Im Folgenden einmal ein Beispiel für die Nutzung der Funktion `rpois()` mit zehn Werten.

```{r}
rpois(n = 10, lambda = 5)
```

[Es gibt neben der Poissonverteilung auch die negative Binomialverteilung sowie die Quasi-Poissonverteilung, die es erlauben einen Streuungsparameter für die Poissonverteilung zu schätzen.]{.aside}

Wir können nun auch aus unseren Gummibärchendaten für die Anzahl an Bärchen in einer Tüte sowie die Anzahl an Farben in einer Tüte die theoretische Poissonverteilung berechnen. In @fig-pois-03 sehen wir die Verteilung der beobachteten Werte für Anzahl an Bärchen in einer Tüte sowie die Anzahl an Farben in einer Tüte und deren theoretischen Verteilung nach dem geschätzen $\lambda = 10$ und $\lambda = 5$. Wir sehen ganz klar, dass die beide Variablen *keine* Zufallsrealisierung sind. Zum einen haben wir das auch nicht erwartet, es gibt nicht mehr als sechs Farben und zum anderen ist zu vermuten, dass Haribo technisch in den Auswahlprozess eingreift. Wir haben auf jeden Fall eine sehr viel kleinere Streuung als bei einer *klassischen* Poissonverteilung anzunehmen wäre.

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| label: fig-pois-03
#| fig-cap: "Darstellung Anzahl an Bärchen und Anzahl an Farben. Es gibt nicht mehr als sechs Farben. Auf der linken Seite die beobachteten Werte und auf der rechten Seite die theoretischen Werte."
#| fig-subcap: 
#|   - "Verteilung der beobachteten Anzahl an Bärchen."
#|   - "Verteilung der theoretischen Anzahl an Bärchen."
#|   - "Verteilung der beobachteten Anzahl an Farben."
#|   - "Verteilung der theoretischen Anzahl an Farben."
#| layout-nrow: 2
#| column: page


stat_color_tbl <- gummi_tbl %>% 
  summarise(mean = mean(count_color),
            n = n())

stat_bears_tbl <- gummi_tbl %>% 
  summarise(mean = mean(count_bears),
            n = n())

ggplot(data = gummi_tbl, aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[5]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(1, 20, by = 1), limits = c(1, 20)) +
  scale_y_continuous(breaks = seq(0, 150, 10), limits = c(0, 150))

set.seed(20220831)
ggplot(data = tibble(count_bears = rpois(stat_bears_tbl$n, stat_bears_tbl$mean)), 
       aes(x = count_bears)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[6]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(1, 20, by = 1), limits = c(1, 20)) +
  scale_y_continuous(breaks = seq(0, 150, 10), limits = c(0, 150))

ggplot(data = gummi_tbl, aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[7]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(0, 11, by = 1), limits = c(0, 11)) +
  scale_y_continuous(breaks = seq(0, 160, 10), limits = c(0, 160))

set.seed(20220831)
ggplot(data = tibble(count_color = rpois(stat_color_tbl$n, stat_color_tbl$mean)), 
       aes(x = count_color)) +
  theme_bw() +
  geom_bar(position = "dodge", color = "black", fill = cbbPalette[8]) +
  labs(x = "", y = "Anzahl") +
  scale_x_continuous(breaks = seq(0, 11, by = 1), limits = c(0, 11)) +
  scale_y_continuous(breaks = seq(0, 160, 10), limits = c(0, 160))

```

## Weitere Verteilungen

![](images/caution.png){fig-align="center" width="50%"}

::: column-margin
Wir besuchen gerne die R Shiny App [The distribution zoo](https://ben18785.shinyapps.io/distribution-zoo/) um mehr über die verschiedenen Verteilungen und deren Parameter zu erfahren.
:::

In der nächsten Zeit werden noch weitere gängige Verteilungen ergänzt. Bis dahin können die [Basic Probability Distributions in R](https://rstudio-pubs-static.s3.amazonaws.com/100906_8e3a32dd11c14b839468db756cee7400.html) nochmal extern nachgeschaut werden.

Im Weiteren liefert @dormann2013parametrische eine weitreichende Übersicht über verschiedene Verteilungen.

## Referenzen {.unnumbered}
