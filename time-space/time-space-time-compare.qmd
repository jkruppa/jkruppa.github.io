Unsere Dronenüberflugdaten sind etwas besondere Daten, wenn wir uns Zeitreihen anschauen. Wir haben zwar auch einen zeitlichen Verlauf auf der $x$-Achse, aber der Zeitrahmen ist mit unter einem Jahr zu klein um einen zyklischen Verlauf zu beobachten. Wir wollen hier auch etwas anderes erreichen. Uns interessieren die einzelnen Beobachtungen nicht, wir wollen die angepasste Graden durch die Punktewolken vergleichen. In der @fig-time-csh-2 siehst du nochmal die angepassten Kurven ohne die einzelnen Messpunkte. Eigentlich rechnen wir hier einen Gruppenvergleich über die Zeit. Spannende Sache, die wollen wir uns dann mal genauer ansehen. Wir werden hier aber keinen statistischen Test rechnen, sondern nur ausrechnen in wie weit sich die beiden Parzellen numerisch im Ertrag unterscheiden.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-time-csh-2
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Die Graserträge für die beiden Parzellen Uelzen und Wiese von Mai bis Ende September. Wir sind an der Fläche zwischen den beiden Graden interessiert."

p_csh <- csh_tbl %>% 
  ggplot() +
  theme_bw() +
  scale_color_okabeito() +
  stat_smooth(aes(day, g_tm_plot, color = parzelle), 
              se = FALSE, n = 100) # <1>
p_csh
```

1.  Setze hier `n = 1000` um wirklich eine gute Abdeckung später für die Berechung der Fläche zu haben.

Gibt es also einen Unterschied zwischen den beiden Parzellen $Uelzen$ und $Wiese$ im Bezug auf den Ertrag? Dafür müssen wir die Differenz der Graden an jedem Punkt berechnen. Oder anders formuliert, wir wollen die Fläche zwischen den beiden Kurven berechnen. Um die Fläche zu berechnen, brauchen wir die Koordinaten, die die Kurven beschreiben. Dafür können wir die Funktion `ggpülot_build()` nutzen, die uns dann die @fig-time-csh-2 in seine Einzelteile zerlegt. Insbesondere brauchen wir die Koordinaten für die beiden Kurven.

```{r}
#| message: false
#| echo: true
#| warning: false
p_csh_str <- ggplot_build(p_csh)
```

Tja, und dann geht es schon los. Der folgende Code beschreibt die Extraktion der Informationen zu den einzelnen Kurven. Am Ende wollen wir für jedes $x$ die beiden $y$-Werte für Uelzen und die Wiese haben. Dann können wir immer die Differenz zwischen dem beiden $y$-Werten `y_2` für Uelzen und `y_5` für die Wiese berechnen. Ja, die Indizes sind etwas irre, aber das kommt dann von dem Zusammenbauen der Daten.

```{r}
#| message: false
#| echo: true
#| warning: false
ribbon_tbl <- p_csh_str %>% 
  pluck("data", 1) %>% 
  as_tibble() %>% 
  select(x, y, group) %>% 
  mutate(group = factor(group, labels = c("Uelzen", "Wiese"))) %>% 
  split(.$group) %>% 
  bind_cols() %>% 
  clean_names() %>% 
  select(x = x_1, Uelzen = y_2, Wiese = y_5) %>%  # <1>
  mutate(x = as_date(x, origin = lubridate::origin)) # <2>
```

1.  Die `y_2` Werte sind die Werte aus Uelzen und die `y_5` Werte von der Wiese.
2.  Die `x`-Werte sind noch das Datum in numerischer Form aus `ggplot()`. Hier wieder zurück ins `yyyy-mm-dd` Format.

Im Folgenden sehen wir dann die `g_tm_plot`-Werte auf den beiden Kurven für jedes Datum getrennt nach Uelzen und Wiese. Es ist nur ein Ausschnitt aus den Daten und du kontrollierst über `n = 100` bei der Funktion `geom_smooth()` wie viele $x$-Werte gebildet werden. Wenn du genauere Werte haben willst, also mit weniger Lücken zwischen den einzelnen $x$-Werten, dann musst du $n$ weiter erhöhen.

```{r}
head(ribbon_tbl)
```

Jetzt können wir einmal die Fläche, die wir berechnet haben abbilden. In der @fig-time-csh-3 siehst du einmal auf der linken Seite nur die beiden Graden mit der berechneten Fläche. Auf der rechten Seite nochmal die Anbildung mit allen Beobachtungen zusammen.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-time-csh-3
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| fig-cap: "Die Graserträge für die beiden Parzellen Uelzen und Wiese von Mai bis Ende September. Wir sind an der Fläche zwischen den beiden Graden interessiert. Je nachdem wie viele $x$-Punkte für die geglättete Kurven verwendet wird, wird die Berechnung der Fläche genauer."
#| fig-subcap: 
#|   - "Ohne einzelne Messwerte."
#|   - "Mit einzelnen Messwerten."
#| layout-nrow: 1
#| column: page

p_csh + 
  geom_ribbon(data = ribbon_tbl, aes(x = x, ymin = Wiese, ymax = Uelzen),
                    fill = "grey", alpha = 0.4) +
  ylim(10, 120)

p_csh + 
  geom_ribbon(data = ribbon_tbl, aes(x = x, ymin = Wiese, ymax = Uelzen),
                    fill = "grey", alpha = 0.4) +
  geom_point(aes(day, g_tm_plot, color = parzelle)) +
  ylim(10, 120)

```

Und dann können wir uns auch die Fläche als Differenz der $y$-Werte für Uelzen und die Wiese berechnen lassen. Wir schauen uns dann gleich nochmal den Effekt von `n` in `stat_smooth()` an, dann siehst du die Auswirkungen. Hier sei noch gesagt, dass du im Zweifel mit `filter()` die Abbildung in kleinere Teile zerhaken kannst. Aktuell wird ja die Fläche durch das umgedrehte Vorzeichen der Fläche am Anfang etwas reduziert. Aber das sind dann schon Kleinigkeiten. Wir haben also eine Differenz an Ertrag von $441.03 g_{tm}$ zwischen der Parzelle in Uelzen und der Wiese. Du kannst hier keinen statistischen Test rechnen, da wir ja dann nur einen Wert vorliegen haben. Es kann ja nur eine Fläche zwischen den beiden Kurven entstehen.

```{r}
ribbon_tbl %>% 
  mutate(diff = Uelzen - Wiese) %>% 
  pull(diff) %>% 
  sum()
```

Hier in der folgenden @fig-time-csh-4 nochmal die *Dichte* der $x$-Werte, die dann natürlich auch die Differenz mit bedingen. Wie du siehst sind da einiges an Lücken in den Kurven. Wenn wir oben `n = 1000` in der Funktion `stat_smooth()` gesetzt hätten, dann hätten wir hier fast eine Linie aus Punkten ohne Lücken. Da musst du dann etwas mit den Werten spielen. Ich möchte ja hier eine effiziente Darstellung, die auch schnell durchläuft. Da opfere ich dann die Genauigkeit - man kann ja leider nicht alles haben.

```{r}
#| message: false
#| echo: true
#| warning: false
#| label: fig-time-csh-4
#| fig-align: center
#| fig-height: 5
#| fig-width: 6
#| fig-cap: "Darstellung der Dichte der $x$-Werte aus der Funktion `stat_smooth()` mit `n = 100`. Es sind klare Lücken zu erkennen, die wir dann durch ein größeres `n = 1000` schließen könnten."
ribbon_tbl %>% 
  pivot_longer(cols = Uelzen:Wiese,
               values_to = "g_tm",
               names_to = "parzelle") %>% 
  ggplot(aes(x, g_tm, color = parzelle)) +
  theme_bw() +
  scale_color_okabeito() +
  geom_point()
```

Damit habe ich hier einmal gezeigt, wie du zwei Kurven deskriptiv miteinander vergleichst und die Differenz als Fläche zwischen den Kurven berechnest. Die Prozedur lässt sich einfach auch auf mehr Kurven erweitern, wenn du als mehr als zwei Parzellen vorliegen hättest. Wie immer, wenn es hier mehr Bedarf gibt, dann würde ich mir die Sachlage nochmal tiefer anschauen.
