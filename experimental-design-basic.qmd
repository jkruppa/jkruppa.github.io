```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc,
               grid, agricolae, patchwork, desplot, modelr)
```

# Einfache Designs {#sec-experimental-design-basic}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: column-margin
Ein Teil der Beispiele basiert auf [DSFAIR von P. Schmidt](https://schmidtpaul.github.io/DSFAIR/DesigningExperiments.html) und wurde von mir angepasst und vereinfacht. Hier findet sich auch weiterführende Literatur und weitere Beispiele.

Im Weiteren schauen wir uns auch das R Paket `agricolae` mit Beispielen von [Experimental Designs with agricolae](https://myaseen208.com/agricolae/articles/ExperimentalDesign.html) genauer einmal an.
:::

In diesem Kapitel wollen wir uns mit der Erstellung von einfachen experimentellen Designs beschäftigen. Dementsprechend schauen wir uns nur die drei folgenden Designs hier in diesem Kapitel an.

-   [Complete randomized design (CRD)](#sec-crd)
-   [Randomized complete block design (RCBD)](#sec-rcbd)
-   [Latin square design (LSD)](#sec-lsd)

Dabei werden wir verschiedene Wege gehen. Leider geht es hier wirklich nicht mehr ohne eine Idee der Programmierung in R. Sonst kannst du leider dem Kapitel nicht folgen. Bitte schau auch nochmal in das vorherige Kapitel zur [Versuchsplanung in R](#sec-experimental-design-r). Wir schauen uns jetzt einmal die einfache Umsetzung händsich an, dann einmal in dem R Paket `agricolae` und abschließend in dem R Paket `dae`. Nicht immer ist alles möglcih, mal ist es dann händisch zu kompliziert oder aber eines der Pakete bietet das experimentelle Design nicht an.

In dem nachfolgenden Kapitel zu den fortgeschrittenen Designs findest du dann noch mehr experimentelle Designs und wie du diese Designs in R generieren kannst. Dieses Kapitel sollte aber ausreichen um einfache Projekte im Rahmen einer Abschlussarbeit oder einem Studienprojekt zu planen.

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
set.seed(2034)
pacman::p_load(tidyverse, magrittr, dae, agricolae,
               conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("set_names", "magrittr")
cbbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Complete randomized design (CRD) {#sec-crd}

Das komplett randomisierte Design ist sicherlich das einfachste Design. Aber auch das praktischste, wenn du ein gar nicht so komplexes Experiment hast. Im PRinzip hast du nur eine Behandlung mit unterschiedlichen Gruppen. Oder allgemeiner gesprochen, du hast einen Faktor $f_1$, der deine Behandlungen beinhaltet. Du kannst viele Behandlungen haben, die dann als Level des Faktors dargestellt werden. Wir gehen jetzt das *complete randomized design* einmal an einem Beispiel durch. Hier einmal für eine Behandlung `trt` mit vier Leveln oder auch Gruppen `ctrl`, `A`, `B` und `C` sowie als Outcome das Trockengewicht `drymatter`. Das Outcome müssen wir gar nicht weiter beachten, es dient nur als Gedankenstütze.

Wir haben also folgendes Modell, was wir dann in einem Design abbilden wollen.

$$
drymatter \sim \overbrace{trt}^{f_1} 
$$

Jetzt ist nur noch die Frage, wie oft wollen wir jede Behandlung wiederholen (eng. *replicate*). Wir entscheiden uns dafür jeweils 4 Pflanzen pro Behandlungsgruppe zu verwenden. Damit haben wir vier Wiederholungen für vier Behandlungsgruppen und somit insgesamt zwanzig Pflanzen oder auch Beobachtungen.

::: {.callout-caution collapse="true"}
## Randomisierung kurz und schmerzlos

Wenn du für deine zwanzig Pflanzen nur ein Randomisierungmuster brauchst, dann empfehle ich dir die Folgende schnelle Art und Weise. Du nimmst die Zahlen von 1 bis 20 und mischt die Zahlen einmal mit der Funktion `sample()` durch. Dann erstellst du dir als dein Grid für deine Pflanzen mit einer $4 \times 5$-Matrix und pflanzt nach diesem Grid die Pflanzen ein. Das war es dann und du bist durch.

```{r}
1:20 %>% 
  sample() %>% 
  matrix(nrow = 4, ncol = 5,
         dimnames = list(str_c("Reihe", 1:4, sep = "-"),
                         str_c("Spalte", 1:5, sep = "-")))
```
:::

### ... mit `expand_grid()`

Warum kompliziert, wenn es auch einfach geht. Wir nutzen hier einmal die Funktion `expand_grid()` um uns das *complete randomized design* zu erstellen. Die Randomisierung kommt dann über das `sample()` und der Pflanzenidentifikationsnummer `pid`. Das geht super einfach und wir brauchen auch gar keine anderen höheren Funktionen von komplexeren R Paketen. Die Spalte `trt_rep` wird uns später helfen die Beobachtung dann in dem Grid der Pflanzenposition auf dem Tisch wiederzufinden.

```{r}
crd_long_tbl <- expand_grid(trt = 1:4, rep = 1:4) %>% 
  mutate(trt = factor(trt, labels = c("ctrl", "A", "B", "C")),
         rep = factor(rep, labels = as.roman(1:4)),
         trt_rep = str_c(trt, ".", rep),
         pid = sample(1:n())) %>%  ## Randomsierung über alles
  select(pid, everything())
crd_long_tbl
```

Dann kannst du dir die Datei mit der Funktion `write_xlsx()` aus dem R Paket `writexl` raus schreiben und dann entsprechend mit deinen Messwerten für das Trockengewicht ergänzen.

```{r}
#| eval: false
#| message: false
#| warning: false
crd_long_tbl %>% 
  write_xlsx("template_sheet.xlsx")
```

Für die Visualisierung fehlt uns jetzt noch die Positionsangaben auf dem Feld. Daher bauen wir uns einmal ein Grid der Reihen `rows` und der Spalten `cols`. Das Grid können wir dann mit den nach den Pflanzen-ID's sortieren Design zusammenbringen. Damit haben wir dann eigentlich schon fast alles zusammen.

```{r}
crd_plot_tbl <- crd_long_tbl %>% 
  arrange(pid) %>% 
  bind_cols(expand_grid(row = 1:4, col = 1:4))
crd_plot_tbl
```

Jetzt können wir uns einmal das Grid der Pflanzungen in der @fig-exp-basic-1 einmal anschauen. Wir nutzen hier die Möglichkeiten des R Pakets `desplot`. Hier wird es dann nochmal klarer wo die Pflanzen eigentlich hin sollen. Du kannst dir dann den Tisch so einteilen, dass eben oben links die vierte Wiederholung der Behandlung `B` steht. Dann steht rechts daneben die zweite Wiederholung der Behandlung `C`. Nach der Ernte bestimmst du dann das Trockengewicht und trägst es in die Exceltabelle ein.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-1
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Schema der Pflanzungen nach den Behandlungen für das *complete randomized design*."

ggdesplot(data = crd_plot_tbl, 
          form = trt ~ col + row,
          text = trt_rep, cex = 1, show.key = FALSE, 
          shorten = "no", flip = TRUE,
          main = "Pflanzschema für ein complete randomized design")
```

Das war jetzt die schnelle Variante mit `expand_grid()` und der anschließenden Visualisierung mit einem Plan für die Positionen der jeweiligen Beobachtungen.

### ... mit `agricolae`

Als Alternative bietet sich dann auch das R Paket `agricolae` an, obwohl ich für so einfaches Design nicht `agricolae` empfehlen kann. Wir haben nämlich so ein paar gewünschte Eigenschaften und damit musst du etwas programmieren um gut mit dem Paket umgehen zu können. Wir nutzen hier die Funktion `design.crd()` um uns das Design eines *complete randomized design* zu erstellen. Die Funktion benötigt einen Vektor mit den Namen der Behandlungslevel. Also in unserem Fall eben `ctrl`, `A`, `B` und `C`. Dann noch einen Vektor `r` mit den Wiederholungen pro Behandlungslevel. Hier ist Funktion `design.crd()` etwas besser, denn wir können hier auch unbalancierte Designs abbilden. Der Nachteil ist, dass wir faktisch danach keine andere Funktion mehr aus den anderen Paketen nutzen können. Deshalb ist es sinniger, balanciert zu planen und dann eben die Pflanzen später zu entfernen.

Hier einmal die simple Anwendung der Funktion zum erstellen eines *complete randomized design* mit vier Behandlungen und fünf Wiederholungen pro Behandlung.

```{r}
crd_obj <- design.crd(trt = c("ctrl", "A", "B", "C"), 
                      r = c(5, 5, 5, 5))
```

Jetzt kommt leider der etwas aufwenidigere Teil. Das Paket `agricolae` ist schon etwas älter und damit auch teilweise nicht mehr so kompatibel und auf dem Stand der Zeit. Wir bauen uns daher jetzt noch ein paar Sachen zurecht. Am Ende wollen wie ein sauberes `tibble` mit anständigen Namen und einer Variable `trt_rep`, die uns sagt welche Behandlung und Wiederholung wir vorliegen haben.

```{r}
crd_book_tbl <- crd_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "r", "trt")) %>% 
  mutate(trt_rep = str_c(trt, ".", r))
crd_book_tbl
```

Schön ist was anderes, da hast du recht, aber wir können uns dann auch noch das Pflanzgrid einmal als Abbildung wiedergeben lassen. Da die Ausgabe der Funktion `design.crd()` schon permutiert ist, müssen wir hier nur die Informationen zu den Zeilen und Spalten ergänzen. Im Prinzip kannst du entscheiden, wie du die Wiederholungen `cols` oder Behandlungen `rows` anordnest. Du kannst am Ende aber auch einfach den ausgedruckten Zettel drehen.

```{r}
crd_plot_tbl <- crd_book_tbl %>%
  bind_cols(expand_grid(rows = 1:4,
                        cols = 1:5))
```

In der @fig-exp-basic-2 siehst du dann einmal das Schema für die Pflanzungen eines *complete randomized design*. Das Schema unterscheidet sich so nicht von dem Eigenbau mit `expand_grid()`. Da bist du frei zu entscheiden was du nutzen möchtest.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-2
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Schema der Pflanzungen nach den Behandlungen für das *complete randomized design*."

ggdesplot(trt ~ rows + cols, flip = TRUE,
          text = trt_rep, cex = 1, shorten = "no",
          data = crd_plot_tbl,
          main = "Pflanzschema für ein complete randomized design", 
          show.key = FALSE) 
```

Damit wären wir auch schon durch. Wir haben in R im Prinzip die beiden Möglichkeiten das *complete randomized design* selber oder mit dem R Paket `agricolae` zu erstellen.

## Randomized complete block design (RCBD) {#sec-rcbd}

Jetzt kommen wir zum vermutlich meist genutzten Design, dem *randomized complete block design*. Hier haben wir neben dem Faktor Behandlung `trt` auch noch einen zusätzlichen Faktor `block`. Wir haben dann für jede Behandlung/Block-Kombination einen Messwert. Wenn du am Feld stehst, ist es aber meistens so, dass wir nicht *eine* Pflanze pro Block haben, sondern 20 oder mehr Pflanzen. Wir mitteln aber den Wert für das Trockengewicht über alle 20 Pflanzen pro Block und haben dann wieder einen Messwert für jede Behandlung/Block-Kombination. Das ist manchmal etwas verwirrend.

Wir haben also folgendes Modell vorliegen, wir habend den Faktor Behandlung `trt` sowie den Faktor Block `block`. Für jede der Behandlung/Block-Kombination erhalten wir dann einen Wert. Wir schauen uns gleich vier Behandlungen und vier Blöcke an.

$$
drymatter \sim \overbrace{trt}^{f_1} + \underbrace{block}_{f_2} 
$$

Wir randomiseren unsere Behandlungen *in* den Blöcken. Somit sind unsere Behandlungen in den Blöcken genestet.

$$
\overbrace{\mbox{Behandlungen}}^{f_1} \xrightarrow[]{nested} \underbrace{\mbox{Blöcke}}_{f_2} 
$$

Damit gilt dann auch, dass jeder Block alle Behandlungslevel enthält und die Behandlungen innerhalb eines Blockes randomsiert werden. Unsere Randomisierungseinheit ist also der Block.

$$
\underbrace{\mbox{Blöcke}}_{f_2} \xrightarrow[]{beinhaltet\; alle} \overbrace{\mbox{Behandlungen}}^{f_1}
$$

Theoretisch könnten wir auch pro Block mehrere *einzelne* Pflanzen messen, dann sind wir aber im Subsampling drin. Wenn du mehr zum Design erfahren möchtest, dann schau einfach mal bei [Abschnitt zum *subsampling*](#sec-subsampling) im nächsten Kapitel rein.

::: column-margin
Hier einmal der Link zu der Auswertung zum [Subsampling](https://schmidtpaul.github.io/DSFAIR/subsampling_Piepho1997.html) bei DSFAIR.
:::

### ... mit `expand_grid()`

Das praktische an `expand_grid()` ist, dass du nochmal eine Vorstellugn über den Aufbau des Experiments erhälst. Wir nehmen als erstes den Block `block` und ergänzen dann die Behandlungen `trt`. Damit erschaffen wir uns erst die vier Blöcke und dann pro Block die vier Behandlungen. Dann müssen wir noch unsere Daten etwas mutieren und schöner machen. Wir ergänzen noch einen Identifikator `trt_block` damit wir auch unsere Positionen für die Pflanzungen später in den Abbildungen wieder finden. Am Ende gruppieren wir die Daten nochmal pro Block damit wir dann innerhalb der Blöcke unsere Behandlungslevel über die Funktion `sample()` randomsisiern können.

```{r}
rcbd_long_tbl <- expand_grid(block = 1:4, 
                             trt = 1:4) %>% 
  mutate(trt = factor(trt, labels = c("ctrl", "A", "B", "C")),
         block = factor(block, labels = as.roman(1:4)),
         trt_block = str_c(trt, ".", block),
         pid = 1:n()) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) ## Randomisierung pro Block
```

```{r}
rcbd_plot_tbl <- rcbd_long_tbl %>% 
  bind_cols(expand_grid(rows = 1:4, cols = 1:4))

```

Die dicken, schwarzen Linien stellen die Grenzen der Blöcke dar. Im realen Leben kann eine farbige Kachel in der Abbildung ein ganzes Feld sein und die Blockgrenzen sind dann eben Feldwege. Die Abbildung stellt ja auch nur eine schematische Darstellung der Pflanzungen dar.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-3
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "Schema der Pflanzungen nach den Behandlungen für das randomized complete block design. Beachte die schwarzen Linien als Grenzen für die Blöcke. Im realen Leben können das Gänge zwischen Tischen sein oder Feldwege."

ggdesplot(data = rcbd_plot_tbl, 
          form = trt ~ rows + cols,
          out1 = block,
          main = "Pflanzschema für ein randomized complete block design", 
          text = trt_block, cex = 1, show.key = FALSE, shorten = "no")
```

```{r}
#| eval: false
#| message: false
#| warning: false
rcbd_wide_tbl %>% 
  write_xlsx("template_sheet.xlsx")
```

### ... mit `agricolae`

```{r}
rcbd_obj <- design.rcbd(trt = c("ctrl", "A", "B", "C"), r = 5)
```

```{r}
rcbd_book_tbl <- rcbd_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "block", "trt"))
rcbd_book_tbl
```

```{r}
rcbd_plot_tbl <- rcbd_book_tbl %>%
  mutate(rows = as.numeric(block)) %>% 
  group_by(rows) %>% 
  mutate(cols = 1:n())
```

```{r}
rcbd_obj %>% 
  pluck("sketch") %>% 
  t()
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-4
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "foo."
desplot(trt ~ rows + cols, flip = TRUE,
        text = trt, cex = 1, shorten = "no",
        out1 = block,
        data = rcbd_plot_tbl,
        main = "randomized complete block design", 
        show.key = T, key.cex = 0.5)
```

## Latin square design (LSD) {#sec-lsd}

### ... mit `agricolae`

```{r}
lsd_obj <- design.lsd(trt = c("ctrl", "A", "B", "C", "D"), 
                      seed = 42)
```

```{r}
lsd_book_tbl <- lsd_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "rows", "cols", "trt")) %>% 
  mutate(rows = as.numeric(rows),
         cols = as.numeric(cols))
lsd_book_tbl
```

```{r}
lsd_obj %>% 
  pluck("sketch") %>% 
  t()
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-5
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "foo."
desplot(trt ~ rows + cols, flip = TRUE,
        out1 = rows, out1.gpar = list(col="black", lwd=3),
        out2 = cols, out2.gpar = list(col="black", lwd=3),
        text = trt, cex = 1, shorten = "no",
        data = lsd_book_tbl,
        main = "Latin square design (LSD)", 
        show.key = FALSE, key.cex = 0.5)
```

### ... mit `dae`

```{r}
lsd_sys <- cbind(fac.gen(list(rows = 5, cols = 5)),
                 trt = factor(designLatinSqrSys(5), labels = LETTERS[1:5]))
```

```{r}
lsd_lay <- designRandomize(allocated = lsd_sys["trt"],
                            recipient = lsd_sys[c("rows", "cols")],
                            seed = 141)
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-basic-6
#| fig-align: center
#| fig-height: 4
#| fig-width: 5
#| fig-cap: "foo."
designGGPlot(lsd_lay, labels = "trt", cellalpha = 0.75,
             row.factors = "rows", column.factors = "cols",
             blockdefinition = cbind(1, 1),
             blocklinecolour = "black")
```
