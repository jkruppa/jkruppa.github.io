```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc)
```

# Generalized Estimating Equations (GEE) {#sec-gee}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

Verallgemeinerte Schätzgleichungen (eng. *Generalized Estimating Equations*, abk. *GEE*) sind eine Methode zur Modellierung von Längsschnitt- oder Clusterdaten (eng. *longitudinal* bzw. *clustered*). Ich nutrze nur die Abkürzung GEE im weiteren Text, sonst wird mir das hier zu lang. Unter dem deutschen Begriff sind die GEE's eigentlich nicht bekannt. Jedenfalls nicht bei Anwendern. Die GEE's werden in der Regel bei nicht-normalen Daten wie binären oder Zähldaten verwendet. Damit siehst du auch schon, warum wir eigentlich nicht so oft GEE's in der Anwendung finden. Wir haben in den Agrarwissenschaften meist ein normalverteiltes Outcome $y$ und so nutzen wir dann häufig eben lineare gemischte Modelle. Damit ist das GEE auch eine Alternative für das lineare gemischte Modell. In *beiden* Modellklassen lassen sich normalverteilte, binäre und auch Zähldaten auswerten. Es ist eher eine Frage, was wir für eine Aussage über die Daten treffen wollen. Wollen wir eine beobachtungsbezogene Aussage (eng. *subject-specific*) treffen, dann nutzen wir lineare gemischte Modelle. Wollen wir eine populationsbezogene Aussage (eng. *population average*) treffen, dann nutzen wir das GEE.

## Annahmen an die Daten

Im folgenden Kapitel zu den Generalized Estimating Equations (GEE) gehen wir davon aus, dass die Daten in der vorliegenden Form *ideal* sind. Das heißt wir haben weder fehlende Werte vorliegen, noch haben wir mögliche Ausreißer in den Daten. Auch wollen wir keine Variablen selektieren. Wir nehmen alles was wir haben mit ins Modell. Sollte eine oder mehre Bedingungen nicht zutreffen, dann schaue dir einfach die folgenden Kapitel an.

-   Wenn du fehlende Werte in deinen Daten vorliegen hast, dann schaue bitte nochmal in das @sec-missing zu Imputation von fehlenden Werten.
-   Wenn du denkst, dass du Ausreißer oder auffälige Werte in deinen Daten hast, dann schaue doch bitte nochmal in das @sec-outlier zu Ausreißer in den Daten.
-   Wenn du denkst, dass du zu viele Variablen in deinem Modell hast, dann hilft dir das @sec-variable-selection bei der Variablenselektion.

::: column-margin
[Getting Started with Generalized Estimating Equations](https://data.library.virginia.edu/getting-started-with-generalized-estimating-equations/)

[Generalized Estimating Equations (GEE)](https://rlbarter.github.io/Practical-Statistics/2017/05/10/generalized-estimating-equations-gee/)
:::

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, conflicted, broom,
               parameters, performance, geepack, gee,
               geesmv, multcomp, emmeans, scales)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("extract", "magrittr")
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Daten

Eventuell das Kuhbeispiel?

Nach Schweine ID sortieren

```{r}
pig_gain_tbl <- read_excel("data/pig_feed_data.xlsx") %>% 
  mutate(weight_gain = round(weight_gain, 2)) %>% 
  arrange(pig_id)

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-gee-pigs
#| tbl-cap: Auszug aus dem Daten zu den kranken Ferkeln.
#| column: page


rbind(head(pig_gain_tbl, n = 3),
      rep("...", times = ncol(pig_gain_tbl)),
      tail(pig_gain_tbl, n = 3)) %>% 
  kable(align = "c", "pipe")
```

```{r}
#| message: false
#| warning: false

milk_tbl <- read_csv2("data/milk_feeding.csv") %>% 
  rename(cow_id = id_cow) %>% 
  arrange(cow_id)

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-gee-milk
#| tbl-cap: Auszug aus dem Daten zu den kranken Ferkeln.
#| column: page


rbind(head(milk_tbl, n = 3),
      rep("...", times = ncol(milk_tbl)),
      tail(milk_tbl, n = 3)) %>% 
  kable(align = "c", "pipe")
```

## Theoretischer Hintergrund

GEE schätzt die durchschnittlichen Auswirkungen auf die Population (eng. *population average*). Betrachten wir dabei die folgenden zwei Szenarien nach @allison2009fixed:

-   *Szenario 1:* Du bist ein Arzt. Du möchtest wissen, um wie viel ein Cholesterinmedikament die Wahrscheinlichkeit eines Herzinfarkts bei deinem Patienten senkt.
-   *Szenario 2:* Du bist ein staatlicher Gesundheitsbeamter. Du möchtest wissen, wie sich die Zahl der Menschen, die an einem Herzinfarkt sterben, verändern würde, wenn alle Menschen in der Risikogruppe das Cholesterinmedikament einnehmen würden.

Im ersten Szenario wollen wir die subjektspezifischen (eng. *subject-specific*) Chancen wissen. Im zweiten Fall sind wir an der Vorhersage für die gesamte Bevölkerung interessiert. GEE kann uns Schätzungen für das zweite, aber nicht für das erste Szenario liefern.

-   **independence**, daher sind die Beobachtungen im Zeitverlauf sind unabhängig.
-   **exchangeable**, daher haben alle Beobachtungen im Zeitverlauf die gleiche Korrelation $\rho_{const.}$.
-   **ar1**, die Korrelation $\rho$ nimmt als Potenz der Anzahl $p$ der Zeitpunkte, die zwischen zwei Beobachtungen liegen, ab. Daher rechnen wir mit $\rho, \rho^2, \rho^3,..., \rho^p$ über die Zeitpunkte.
-   **unstructured**, daher kann die Korrelation zwischen allen Zeitpunkten unterschiedlich sein.

## Modellieren mit `gee()`

```{r}
#| message: false
#| warning: false

gee_fit <- gee(weight_gain ~ treatment + treatment * time,
               data = pig_gain_tbl, 
               id = pig_id, 
               family = gaussian,
               corstr = "exchangeable")

pluck(gee_fit, "working.correlation") %>% 
  round(3)

gee_fit %>% model_parameters()
```

## Modellieren mit `geeglm()`

```{r}
#| message: false
#| warning: false

geeglm_fit <- geeglm(weight_gain ~ treatment + treatment * time,
                     data = pig_gain_tbl, 
                     id = pig_id, 
                     family = gaussian,
                     corstr = "exchangeable")

geeglm_fit %>% model_parameters()
```

## Multipler Vergleich mit `emmeans`

```{r}
#| message: false
#| warning: false

res_gee <- geeglm_fit %>% 
  emmeans(~ treatment) 

res_gee_cld <- res_gee %>% 
  cld(adjust = "bonferroni", Letters = letters) %>% 
  tidy() %>% 
  select(treatment, estimate, conf.low, conf.high, .group) %>% 
  mutate(across(where(is.numeric), round, 2))

res_gee_cld 

```

```{r}
#| message: false
#| warning: false

res_gee_tbl <- res_gee %>% 
  contrast(method = "pairwise") %>% 
  tidy(conf.int = TRUE) %>% 
  mutate(p.value = pvalue(adj.p.value),
         across(where(is.numeric), round, 2)) %>% 
  select(contrast, estimate, p.value,
         conf.low, conf.high) 

res_gee_tbl
```

## Multipler Vergleich mit `multcomp` und `geesmv`

::: column-margin
[geesmv: Modified Variance Estimators for Generalized Estimating Equations](https://rdrr.io/cran/geesmv/man/geesmv.html)
:::

```{r}
#| message: false
#| warning: false

geeglm_fit <- geeglm(weight_gain ~ 0 + treatment + treatment * time,
                     data = pig_gain_tbl, 
                     id = pig_id, 
                     family = gaussian,
                     corstr = "exchangeable")
```

```{r}
#| message: false
#| warning: false

beta_tbl <- coef(geeglm_fit) %>% 
  enframe
```

```{r}
#| message: false
#| warning: false

gee_lz_vcov <- GEE.var.lz(weight_gain ~ 0 + treatment + treatment * time,
                          data = as.data.frame(pig_gain_tbl), 
                          id = "pig_id",
                          family = gaussian,
                          corstr = "independence") 

vbeta_tbl <- gee_lz_vcov$cov.beta %>% 
  enframe
```

```{r}
#| message: false
#| warning: false

coef_tbl <- left_join(beta_tbl, vbeta_tbl, by = "name") %>% 
  filter(str_detect(name, "time", negate = TRUE)) %>% 
  set_names(c("parameter", "beta", "vbeta"))

```

```{r}
#| message: false
#| warning: false

contrMat_n <- setNames(rep(1, length(coef_tbl$parameter)),
                       coef_tbl$parameter) %>% 
  contrMat(type = "Tukey")

contrMat_n 
```

```{r}
#| message: false
#| warning: false

mult_gee <- glht(parm(coef = coef_tbl$beta, 
                      vcov = diag(coef_tbl$vbeta)), 
                 linfct = contrMat_n)
mult_gee$df <- geeglm_fit$df.residual
```

```{r}
#| message: false
#| warning: false

mult_gee %>% 
  tidy(conf.int = TRUE) %>% 
  select(contrast, estimate, conf.low, conf.high, adj.p.value)
```
