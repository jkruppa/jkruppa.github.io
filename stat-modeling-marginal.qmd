```{r echo = FALSE}
#| message: false
#| warning: false
pacman::p_load(tidyverse, readxl, knitr, kableExtra, performance, parameters,
               latex2exp, see, patchwork, mfp, multcomp, emmeans, janitor, effectsize,
               broom, ggmosaic, tinytable, ggrepel, tidyplots, glue, ggtext, marginaleffects,
               mgcv, conflicted)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::filter)
cb_pal <- c("#000000", "#E69F00", "#56B4E9", 
            "#009E73", "#F0E442", "#F5C710", 
            "#0072B2", "#D55E00", "#CC79A7")
cbbPalette <- cb_pal
theme_marginal <- function() {
  theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          plot.background = element_rect(fill = "white", color = NA),
          plot.title = element_text(size = 16, face = "bold"),
          plot.subtitle = element_text(size = 12, face = "italic"),
          plot.caption = element_text(face = "italic"),
          axis.title = element_text(face = "bold"),
          axis.text = element_text(size = 12),
          strip.text = element_text(face = "bold"),
          strip.background = element_rect(fill = "grey80", color = NA))
}
set.seed(20250703)
modell_square_tbl <- tibble(x = rnorm(20, 5, 5),
                          y = 1.5 + 0.75 * -x^2 + rnorm(length(x), 0, 5))
modell_line_tbl <- tibble(x = rnorm(20, 2, 1),
                            y = 1.5 + 0.75 * x + rnorm(length(x), 0, 0.5))
set.seed(20250708)
enzyme_tbl <- tibble(x = rep(c(-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 7.5), each = 10),
                     y = x^3 + -8*x^2 + 10*x + 10 + rnorm(length(x), 0, 10)) |> 
  group_by(x) |> 
  sample_n(size = sample(c(3:5), 1)) |> 
  ungroup() |> 
  mutate_if(is.numeric, round, 2)
enzyme_tbl |> 
  mutate(g1 = case_when(x < 2 ~ "niedrig",
                        x < 5 ~ "mittel",
                        x < 8 ~ "hoch")) |> 
  mutate(g2 = c(rep(c("Prokaryot", "Eukaryot"), times = c(8, 8)),
                rep(c("Prokaryot", "Eukaryot"), times = c(8, 7)),
                rep(c("Prokaryot", "Eukaryot"), times = c(5, 7)))) |> 
  set_names(c("ph", "activity", "grp", "type")) |> 
  writexl::write_xlsx("data/enzyme_kinetic.xlsx")
```

```{r}
#| echo: false
#| message: false
#| warning: false
source("images/R/stat-modeling-marginal.R")
```

# Marginal effect models {#sec-marginal}

*Letzte Änderung am `r format(fs::file_info("stat-modeling-marginal.qmd")$modification_time, '%d. %B %Y um %H:%M:%S')`*

> *"Life is difficult." --- Morgan Scott Peck, The Road Less Traveled*

![](images/caution.png){fig-align="center" width="100%"}

::: {.callout-caution appearance="simple"}
## Stand des Kapitels: Konstruktion (seit 07.2025)

Dieses Kapitel wird in den nächsten Wochen geschrieben und ist damit meine aktuelle Großbaustelle. Ich plane zum Beginn des WiSe 2025/26 eine fertige Version des Kapitels erstellt zu haben. Während das Kapitel entsteht, funktioniert so manches dann nicht so wie es soll. Bitte daher hier dann abwarten.
:::

Lange habe ich gebraucht um mich dazu durchzuringen das Kapitel zu den *Marginal effect models* (deu. *marginale Effektmodelle*, ungebräuchlich) zu schreiben. Ich werde hier bei dem englischen Begriff bleiben, den deutschen Begriff habe ich eher selten gehört und daher sind es für mich *Marginal effect models*. Insbesondere da der Begriff "marginal" auch sehr an gering oder minderwertig erinnert. Damit haben aber die *Marginal effect models* nicht im geringsten zu tun. Die Modelle sind sehr mächtig und können uns helfen wichtige Fragen an unsere Daten zu beantworten. Insbesondere die Dualität der beiden Pakete `{emmeans}` für experimentelle Daten und `{marginaleffects}` für beobachtete Daten ist spannend und möchte ich hier nochmal genauer betrachten. Neben diesen beiden Ecksteinen gibt es noch andere Pakete und ich werde auch hier einmal in die Pakete reinschauen. Anfangen kann ich aber nicht ohne @heiss2022 mit seinem Blogpost [Marginalia: A guide to figuring out what the heck marginal effects, marginal slopes, average marginal effects, marginal effects at the mean, and all these other marginal things are](https://www.andrewheiss.com/blog/2022/05/20/marginalia/) zu erwähnen. Vieles entlehnt sich direkt oder indirekt an seine Ausführungen. Wie immer habe ich etwas angepasst, wenn ich der Meinung war, dass es noch besser zu verstehen ist. Fangen wir also an *Marginal effect models* zu zerforschen. Beginnen wollen wir aber mit einem allgemeinen Hintergrund bevor wir uns dann nochmal tiefer mit den *Marginal effect models* beschäftigen.

## Allgemeiner Hintergrund

> *"Statistics is all about lines, and lines have slopes, or derivatives. These slopes represent the marginal changes in an outcome. As you move an independent/explanatory variable, what happens to the dependent/outcome variable?" --- @heiss2022*

Wenn wir von *Marginal effect models* sprechen, dann können wir uns im Prinzip zwei Aspekte anschauen. Wir können über die Steigung einer Funktion einer Geraden sprechen oder aber über die vorhergesagten $y$-Werte auf der Geraden für beliebige $x$-Werte. Damit sind wir dann bei den beiden Aspekten Steigung und Vorhersage. Wenn wir uns in der Welt der linearen Modelle bewegen, dann ist die Steigung eigentlich kein Problem und die Vorhersage auch nicht so komplex. Spannender wird das Zusammenspiel eines nichtlinearen Modells und eben den *Marginal effect models*. Hier kommt dann die eigentliche Kraft der *Marginal effect models* zu trage. In den folgenden beiden Abbildungen habe ich dir einmal eine nichtlinere Funktion dargestellt. Wir schauen uns hier den Zusammenhang zwischen der standardisierten Enzymeaktivität und dem standardisierten pH-Wert an. Wir haben die Enzymeaktivität zu festen pH-Werten wiederholt gemessen. Auf der linken Seite betrachten wir die Steigung der Geraden an drei Punkten und auf der rechten Seite sehen wir einmal die Vorhersage für drei pH-Werte auf der Geraden.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "Modellierung des nichtlinearen Zusammenhangs zwischen der standardisierten Enzymeaktivität und dem standardisierten pH-Wert. Der pH-Wert ist kontinuierlich. **(A)** Berechnung der Steigung (eng. *slope*) für ausgewählte pH Werte anhand der Modellierung. **(B)** Berechnete Vorhersagewerte (eng. *prediction*) der standardisierten Enzymeaktivität für ausgewählte pH-Werte anhand der Modellierung. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-intro-01

p1_intro_00_1 + p2_intro_00_2 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Betrachten wir also einmal die Antworten, die die Steigung und die Vorhersage liefert. Dabei haben wir hier in diesem Fall ein kontinuierliches $X$ vorliegen und machen uns die Sachlage auch einfacher indem wir ein kontinuierliches $Y$ mit der standardisierten Enzymeaktivität vorliegen haben.

Welche Antwort liefert die Steigung?

:   *Wenn sich* $X$ *ändert, wie ändert sich dann* $Y$ *an dem Wert von* $X$*?* Hierbei muss sich $X$ nicht um eine Einheit verändern, wie wir es gerne im linearen Zusammenhang sagen, sondern wir wollen die Steigung direkt im Punkt von $(X|Y)$ haben.

Welche Antowort liefert die Vorhersage?

:   *Welche Werte für* $Y$ *sagt das Modell für* $X$ *vorraus?* Wir müssen hier die beobachteten Werte von $Y$, die in unserem Beispiel für einen pH-Wert wiederholt vorkommen, von dem einen vorhergesagten $Y$ Wert aus dem Modell für ein gegebenes $X$ unterscheiden.

Dann können wir auch schon die Steigung und die Vorhersage einmal interpretieren. In dem linken Tab findest du einmal die Interpretation der Steigung sowie die Ausgabe der Funktion `slopes()` aus dem R Paket `{marginaleffects}`. In dem rechten Tab dann die Ergebnisse der Vorhersage und die Ausgabe der Funktion `predictions()`. Mehr zu den beiden Funktionen dann weiter unten in der Anwendung. Ich berechne hier die Steigung und bestimme die vorhergesagten Werte für drei ausgewählte pH-Werte.

::: panel-tabset
## Interpretation Steigung

| pH | Steigung | Interpretation |
|----|----|----|
| -1 | 29 | *Bei einem standardisierten pH-Wert von -1 steigt die Enzymeaktivität um 29U an.* |
| 2 | -10 | *Bei einem standardisierten pH-Wert von 2 sinkt die Enzymeaktivität um 10U.* |
| 6 | 22 | *Bei einem standardisierten pH-Wert von 6 steigt die Enzymeaktivität um 22U an.* |

: Interpretation der Steigung der Enzymeaktivität an drei ausgewählten pH-Werten. {#tbl-intro-inter-slope}

Wir können uns dann die Steigung auch direkt mit der Funktion `slopes()` bestimmen lassen und erhalten dann die folgenden Informationen. Hier ahben wir dann auch die p-Werte sowie einen entsprechenden Fehler.

```{r}
#| message: false
#| echo: false
#| warning: false
enzyme_tbl <- read_excel("data/enzyme_kinetic.xlsx")
poly_fit <- lm(activity ~ poly(ph, 3), data = enzyme_tbl)
slopes(poly_fit, newdata = datagrid(ph = c(-1, 2, 6)))
```

## Interpretation Vorhersage

| pH  | Vorhersage (y) | Interpretation |
|-----|----------------|----------------|
| -1  | -9             |                |
| 2   | 6              |                |
| 6   | -2             |                |

: test {#tbl-intro-inter-vorhersage}

```{r}
#| message: false
#| echo: false
#| warning: false
enzyme_tbl <- read_excel("data/enzyme_kinetic.xlsx")
poly_fit <- lm(activity ~ poly(ph, 3), data = enzyme_tbl)
predictions(poly_fit, newdata = datagrid(ph = c(-1, 2, 6)))
```
:::

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "Modellierung des Zusammenhangs zwischen der standardisierten Enzymeaktivität und den gruppierten pH-Werten nach niedrigen, mittleren und hohen pH-Werten. Der pH-Wert ist kategorial. **(A)** Einfaktorielle Vorhersage der Gruppenmittelwerte der Enzymeaktivität. **(B)** Zweifaktorielle Vorhersage der Gruppenmittelwerte der Enzymeaktivität aufgetrennt nach der Gruppe der Eukaryoten und Prokaryoten. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-intro-04

p3_intro_00_3 + p4_intro_00_4 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))

```

::: panel-tabset
## Vorhersage 1-faktoriell

| pH      | Mittelwert | Interpretation |
|---------|------------|----------------|
| niedrig | 3.2        |                |
| mittel  | 2.59       |                |
| hoch    | -5.6       |                |

: test {#tbl-intro-inter-slope}

```{r}
#| message: false
#| echo: false
#| warning: false
enzyme_tbl <- read_excel("data/enzyme_kinetic.xlsx")  |> 
  mutate(grp = factor(grp, levels = c("niedrig", "mittel", "hoch"))) 
enzyme_fit <-  lm(activity ~ grp, data = enzyme_tbl)
avg_predictions(enzyme_fit, by = c("grp"), vcov = "HAC")
```

## Vorhersage 2-faktoriell

| pH      | Gruppe    | Mittelwert | Interpretation |
|---------|-----------|------------|----------------|
| niedrig | Eukaryot  | 12.43      |                |
| niedrig | Prokaryot | -4.19      |                |
| mittel  | Eukaryot  | -4.73      |                |
| mittel  | Prokaryot | 9.91       |                |
| hoch    | Eukaryot  | -5.14      |                |
| hoch    | Prokaryot | -6.37      |                |

: test {#tbl-intro-inter-vorhersage}

```{r}
#| message: false
#| echo: false
#| warning: false
enzyme_tbl <- read_excel("data/enzyme_kinetic.xlsx") |> 
  mutate(grp = factor(grp, levels = c("niedrig", "mittel", "hoch"))) 
enzyme_fit <- lm(activity ~ grp * type, data = enzyme_tbl)
avg_predictions(enzyme_fit, by = c("grp", "type"), vcov = "HAC")
```
:::

## Theoretischer Hintergrund

> *"What he says?" --- Asterix Sieg über Caesar*

Soweit so gut. Wenn du verstanden hast, was die *Marginal effect models* können, dann kannst du auch bei den Daten und deren Auswertung weitermachen. Hier geht es dann etwas tiefer und ich gehe nochmal auf einzelen Aspekte etwas ausführtlicher ein. Wenn wir dabei mit dem Verstehen und Zerforschen vorankommen wollen, dann können wir @heiss2022 und @heiss2024 mit der Veröffentlichung [Model to meaning --- How to Interpret Statistical Models With marginaleffects for R and Python](https://marginaleffects.com/) nicht ignorieren. Ich nutze jetzt eine etwas allgemeinere Erklärung der *Marginal effect models* und konzentriere mich erstmal auf ein normalverteiltes $x$ sowie ein normalverteiltes $y$. Daher haben wir hier in unserem $x$ keine Gruppen vorliegen sondern einen klassischen Scatterplot mit Punkten als Beobachtungen. Wir können die *Marginal effect models* auch auf beliebige kategorielle $x$ wie eben Behandlungsgruppen sowie jedes beliebige $y$ anwenden, aber hier fangen wir einmal einfach an.

Welche Frage wollen wir mit *Marginal effect models* beantworten?

:   Wenn sich das $x$ um einen Wert oder eine Einheit erhöht, um wieviele Einheiten verändert sich dann der Wert von $y$?

In der folgenden Abbildung siehst du einmal zwei Scatterplots. In dem linken Scatterplot haben wir einen linearen Zusammenhang zwischen unseren $x$-Werten und den $y$-Werten. Wir können sagen, dass wenn sich $x$ um einen Wert erhöht, dann erhöht sich auch $y$ um einen konstanten Wert. Dieser konstante Wert um den sich die $y$-Werte mit ansteigenden $x$ erhöhen, nennen wir auch die Steigung $\beta_1$. In einem linearen Zusammenhang ist die Frage damit mit der Steigung der Geraden eigentlich beantwortet. Steigt $x$ um einen Wert, dann steigt $y$ um den Wert der Steigung $\beta_1$ der Geraden. Diesen konstanten Zusammenhang haben wir aber nicht bei einem quadratischen Zusammenhang wie in der rechten Abbildung. Wir können hier nicht sagen, dass wenn sich $x$ um einen Wert erhöht, sich auch $y$ um einen konstanten Wert ändert. Hier hängt es von dem betrachteten $x$-Wert ab.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "Scatterplot der kontinuierlichen x-Werte und kontinuierlichen y-Werte. In einem Modell wird die Abhängigkeit von y und x modellieren. **(A)** Linearer Zusammenhang. **(B)** Quadratischer Zusammenhang. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-intro-05

p1_intro_00 + p2_intro_00 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Schauen wir mal in ein Zahlenbeispiel und lassen die Beobachtungen weg. Beginnen wir einmal mit dem linearen Zusammenhang der Funktion $f(x) = 2x-1$. Ich habe die Gerade einmal in der folgenden Abbildung eingezeichnet. Wenn usn jetzt die Steigung an jedem beliebigen Punkt von $x$ interessiert, dann bilden wir die erste Abbleitung $f'(x) = 2$. Erhöht sich also der Wert von $x$ um 1 dann steigt der Wert von $y$ um 2 an. Wir sehen aber auch, dass für jedes beliebige Punktepaar wir eine Steigung von 2 vorliegen haben.

```{r}
#| message: false
#| echo: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "Gerade des Modells für einen linearen Zusammenhang. In einem Modell wird die Abhängigkeit von y und x modellieren. **(A)** Lineares Modell mit Gleichung. **(B)** Steigung an der Geraden für ausgewählte Punktepaare. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-intro-06

p1_intro_01 + p2_intro_01 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Spanndender wird die Sachlage in einem quadratischen Zusammenhang in der folgenden Abbildung. Oder allgemeiner gesprochen, wenn wir keinen linearen Zusammenhang vorliegen haben. Wir haben hier den Zusammenhgang $f(x) = -0.5x^2+5x$ vorliegen. Damit haben wir dann eine erste Ableitung von $f'(x) = x+5$. Wie du siehst, ändert sich auch die Steigung in Abhänigkeit von $x$. Wenn wir $x$-Werte links betrachten, dann liegt hier eher eine positive Steigung vor. Wenn wir nach rechts laufen, dann sehen wir immer stärkere negative Steigungen. Und hier kommen dann die *Marginal effect models* ins Spiel. Wir können allgemein gesprochen uns mit den *Marginal effect models* für jedes $x$ die Steigung wiedergeben lassen.

```{r}
#| message: false
#| echo: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "Gerade des Modells für einen quadratischen Zusammenhang. In einem Modell wird die Abhängigkeit von y und x modellieren. **(A)** Quadratisches Modell mit Gleichung. **(B)** Steigung an der Geraden für ausgewählte Punktepaare. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-intro-07


p1_intro_02 + p2_intro_02 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

Aber moment, denkst du jetzt, in dem linearen Zusammenhang ist es ja einfach mit der Steigung für jeden beliebigen $x$-Wert. Wir erhalten für jeden $x$-Wert genau die gleiche Steigung. Aber bei den nicht-linearen Zusammenhängen hat ja jeder $x$-Wert seine eigene Steigung. Wenn wir viele $x$-Werte gemessen haben, dann haben wir ja dutzende bis hunderte Steigungen durch ein *Marginal effect model* ermittelt. Das stimmt und damit kommen wir auch gleich zu dem nächsten Punkt, dem Aggregieren der Daten. Oder wie im folgenden Cartoon richtig dargestellt, müssen wir uns überlegen wie wir den den Durchschnitt der Steigungen berechnen.

!["Should I cut the red wire or the blue one!?" "WAIT! We're going to watch ALL the action movies from the '80s and '90s and then calculate the average!" Quelle: wumo.com](images/average.jpg){#fig-pretest-barplot-02 fig-align="center" width="100%"}

Wir haben uns in dem obigen Beispiel nur ein koninuierliches $x$ angeschaut. Jetzt kann es aber auch sein, dass deine $x$-Werte keine kontinuierlichen Messwerte wie das Gewicht oder die Zeit sind, sondern eben Gruppen. Also du hast verschiedene Düngestufen oder Behandlungsgruppen auf der $x$-Achse als Faktoren aufgetragen. Auch dann können wir eine lineare Regression rechnen, eine Linie durch die Punkte legen und anschließend ein *Marginal effect model* rechnen. Was ist also der Unterschied zwischen einem kontinuierlichen und einem kategoriellen $x$-Wert?

#### Unterschied zwischen kontinuierlichen und kategoriale $x$-Werte {.unnumbered .unlisted}

Wir kennen verschiedene Namen für das Gleiche. So nennen wir dann ein kontinuierliches $x$ dann auch gerne eine stetige Variable oder intervalskaliert. Nichts destotrotz, wir haben ein $x$ was in kleinen, marignalen Schritten anwachsen kann. Hier kannst du eben an das Gewicht der Flöhe oder aber Zeiteinheiten sowie das Einkommen denken. Wir verändert sich das $y$, wenn wir die $x$-Werte erhöhen?

Auf der anderen Seite haben wir dann kategoriale oder kategorielle $x$-Werte. Diese bezeichnen wir dann auch gerne diskret oder aber als Faktoren in R. Wenn wir die Werte von $x$ ändern, dann springen wir in eine neue Gruppe und es liegt hier eigentlich kein kleiner Schritt vor. Hier haben wir dann eben Düngestufen oder aber Behandlungsgruppen vorliegen. Hier fragen wir uns, wie ändert sich der Wert von $y$, wenn wir eine Gruppe in $x$ weiterspringen?

In der folgenden Abbildung von @heiss2022 siehst du nochmal schön den Unterschied dargestellt. Wir haben beider einer kategorialen Variable einen Schalter. Entweder ist der Schalter an oder eben aus. Im simpelsten Fall haben wir männliche oder eben weibliche Flöhe vorliegen. Das Geschlecht ist somit kategorial. Die Sprungweite oder das Gewicht von Flöhen ist eine kontinuierliche Variable. Wir haben einen Schieberegeler den wir ziemlich fein einstellen können.

![Unterschied zwischen einer kategorialen Variable und einer kontinuierlichen Variable in einem statistischen Modell visualisiert als Schalter und Schieberegler. Übersetzt nach @heiss2022](images/marginal/slider-switch-annotated-trans.png){#fig-utest-intro-01 fig-align="center" width="100%"}

Als wäre das nicht kompliziert genug, schauen wir uns meistens dann nicht nur eine $x$ Variable in einem Modell an, die wir dann ändern, sondern eben mehrere. Dann kombinieren wir noch gerne kontinuierliche und kategoriale $x$-Werte in einem Modell miteinander und erhalten ein Mischboard. Wir können einiges an Schiebereglern und Schaltern in einem Modell betätigen und erhalten entsprechende andere $y$-Werte. Hier helfen dann auch *Marginal effect models* um mehr Erkenntnisse aus einem Modell zu erhalten.

![Kombination verschiedener kategorialer Variablen und kontinuierlichen Variablen in einem statistischen Modell visualisiert als Mischboard. Übersetzt nach @heiss2022](images/marginal/mixer-board-annotated-trans.png){#fig-utest-intro-02 fig-align="center" width="100%"}

Somit kommen wir dann hier mal zu einer Definition, wie wir dann die beiden Arten der möglichen $x$-Werte als kontinuierliche und kategoriale Werte sprachlich unterscheiden. Wir immer, je nach wissenschaftlichen Hintergrund können sich dann die Namen ändern und anders sein. Das ist dann eben so in der Statistik.

Marginal effect (deu. *marginaler Effekt*)

:   Ein marginaler Effekt beschreibt den statistischen Effekt für kontinuierliche erklärende Variablen; die partielle Ableitung einer Variablen in einem Regressionsmodell; der Effekt eines einzelnen Schiebereglers.

Conditional effect (deu. *bedingter Effekt*) oder Gruppenkontrast (eng. *group contrast*)

:   Ein bedingter Effekt beschreibt den statistischen Effekt für kategoriale erklärende Variablen; der Unterschied in den Mittelwerten, wenn eine Bedingung eingeschaltet ist und wenn sie ausgeschaltet ist; der Effekt eines einzelnen Schalters.

#### Unterschied zwischen `{marginaleffects}` und `{emmeans}` {.unnumbered .unlisted}

Wenn wir *Marginal effect models* rechnen wollen, dann können wir im Prinzip auf zwei große Pakete zurückgreifen. Einmal das [R Paket `{marginaleffects}`](https://marginaleffects.com/) sowie das [R Paket `{emmeans}`](https://cran.r-project.org/web/packages/emmeans/vignettes/basics.html#contents). Das [R Paket `{modelbased}`](https://easystats.github.io/modelbased/index.html) setzt sich im Prinzip auf die beiden Pakete drauf und ist mehr oder minder ein Wrapper mit anderen Funktionsnamen. Das ist eigentlich eine gute Idee und ich zeige dann auch nochmal, wie sich das R Paket `{modelbased}` verhält. Kommen wir erstmal zu dem hauptsächlichen Unterschied zwischen unseren beiden Elefanten.

Wie unterscheiden sich `{emmeans}` und `{marginaleffects}`?

:   Das R Paket `{emmeans}` erstellt Durchschnittswerte der Daten und fügt diese Durchschnittswerte dann in Modelle ein. Das R Paket `{marginaleffects}` fügt alle Werte der Daten in ein Modell ein und erstellt dann Durchschnittswerte aus der Ausgabe des Modells. Am Ende ist es vermutlich dann auch wieder ein nur kleiner Unterschied, der was ausmachen kann. Aber da kommt es dann auf die wissenschaftliche Fragestellung an.

Dabei gibt es noch einen weiteren bedeutenden Unterschied zwischen den beiden Paketen, die sich dann direkt aus der Aggregierung der Daten ableitet. Die Frage ist ja, erst den Mittelwert bilden und dann Modellieren oder umgekehrt. Das R Paket `{emmeans}` hat als philosophischen Hintergrund experimentelle Daten als Basis. Das R Paket `{marginaleffects}` hingegen nimmt beobachtete Daten an. Hier möchte ich dann einmal die Vingette des R Pakets `{emmeans}` zitieren.

> *"To start off with, we should emphasize that the underpinnings of estimated marginal means – and much of what the `{emmeans}` package offers – relate more to experimental data than to observational data. In observational data, we sample from some population, and the goal of statistical analysis is to characterize that population in some way. In contrast, with experimental data, the experimenter controls the environment under which test runs are conducted, and in which responses are observed and recorded. Thus with experimentation, the population is an abstract entity consisting of potential outcomes of test runs made under conditions we enforce, rather than a physical entity that we observe without changing it." --- [R Paket `{emmeans}`](https://cran.r-project.org/web/packages/emmeans/vignettes/basics.html#contents)*

Was will uns nun dieser Text sagen und was bedeutet der Unterschied zwischen experimentellen und beobachteten Daten?

-   Wir nutzen `{emmeans}`, wenn wir Gruppenvergleiche aus einem experimentellen, faktoriellen Design rechnen wollen. Solche faktorielle Designs sind in den Agrarwissenschaften sehr häufig.
-   Wir nutzen `{marginaleffects}`, wenn wir beobachtete Daten vorliegen haben. Dies ist sehr häufig bei zeitlichen Verläufen der Fall. Wenn wir also wissen wollen, wie ändert sich den Messwert über die Zeit?

::: callout-tip
## Weitere Tutorien für die Marginal effects models

Wir oben schon erwähnt, kann dieses Kapitel nicht alle Themen der Marginal effects models abarbeiten. Daher präsentiere ich hier eine Liste von Literatur und Links, die mich für dieses Kapitel hier inspiriert haben. Nicht alles habe ich genutzt, aber vielleicht ist für dich was dabei.

-   Ohne den Blogpost [Marginalia: A guide to figuring out what the heck marginal effects, marginal slopes, average marginal effects, marginal effects at the mean, and all these other marginal things are](https://www.andrewheiss.com/blog/2022/05/20/marginalia/) von @heiss2022 wäre dieses Kapitel nicht möglich gewesen.
-   Wie alles im Leben ist nichts ohne Kritik. [Is least squares means (lsmeans) statistical nonsense?](https://cran.r-project.org/web/packages/emmeans/vignettes/basics.html#contents:~:text=found%20here%20and-,here,-.) ist dann auch eine gute Frage. Ich bin der Meinung nein und auch andere sind es, aber hier kannst du dann nochmal eine andere Meinung lesen.
:::

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
#| warning: false
pacman::p_load(tidyverse, gtsummary, marginaleffects, emmeans, scales,
               janitor, ggpmisc, conflicted)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(dplyr::summarize)
conflicts_prefer(dplyr::filter)
conflicts_prefer(ggplot2::annotate)
cb_pal <- c("#000000", "#E69F00", "#56B4E9", 
            "#009E73", "#F0E442", "#F5C710", 
            "#0072B2", "#D55E00", "#CC79A7")
## 
nice_number <- label_number(style_negative = "minus", accuracy = 0.01)
nice_p <- label_pvalue(prefix = c("p < ", "p = ", "p > "))
find_intercept <- function(x1, y1, slope) {
  intercept <- slope * (-x1) + y1
  return(intercept)
}
```

An der Seite des Kapitels findest du den Link *Quellcode anzeigen*, über den du Zugang zum gesamten R-Code dieses Kapitels erhältst.

## Daten

#### Modellierung von Enzymen {.unnumbered .unlisted}

```{r}
enzyme_tbl <- read_excel("data/enzyme_kinetic.xlsx") |> 
  mutate(grp = factor(grp, levels = c("niedrig", "mittel", "hoch")))  
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-margin-table-01
#| tbl-cap: "Daten für die einfaktorielle MANOVA mit der Sprungweite in [cm] und dem Gewicht der Flöhe in [mg] für drei Floharten."

enzyme_raw_tbl <- read_excel("data/enzyme_kinetic.xlsx") 

rbind(head(enzyme_raw_tbl, n = 3),
      rep("...", times = ncol(enzyme_raw_tbl)),
      tail(enzyme_raw_tbl, n = 3)) |> 
  kable(align = "c", "pipe")
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-margin-table-02
#| tbl-cap: "Daten für die einfaktorielle MANOVA mit der Sprungweite in [cm] und dem Gewicht der Flöhe in [mg] für drei Floharten."

enzyme_raw_tbl |> 
  tabyl(ph) |> 
  mutate(percent = scales::percent(percent)) |> 
  kable(align = "c", "pipe")
```

$$
y = x^3 - 8x^2 + 10x + 10
$$

Funktion der Steigung als erste Ableitung nach

$$
y' = 3x^2 - 16x + 10
$$

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 7
#| fig-cap: "Scatterplot der *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-enzyme-01

p1_model_enzyme_01
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 4.5
#| fig-width: 8
#| fig-cap: "**(A)** Linearer Zusammenhang. **(B)** gg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-enzyme-02

p1_model_enzyme_02 + p2_model_enzyme_02 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

#### Modellierung von Flöhen {.unnumbered .unlisted}

```{r}
flea_model_tbl <- read_excel("data/fleas_model_data.xlsx") |> 
  mutate(feeding = as_factor(feeding),
         stage = as_factor(stage),
         bonitur = as.numeric(bonitur),
         infected = factor(infected, labels = c("healthy", "infected"))) |> 
  select(feeding, stage, jump_length, weight, hatched, count_leg,  bonitur, infected)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-fac1cov-table
#| tbl-cap: "Daten für die einfaktorielle MANOVA mit der Sprungweite in [cm] und dem Gewicht der Flöhe in [mg] für drei Floharten."

flea_model_raw_tbl <- read_excel("data/fleas_model_data.xlsx") |> 
  mutate(bonitur = as.numeric(bonitur),
         infected = as.character(factor(infected, labels = c("healthy", "infected")))) |> 
  select(feeding, stage, jump_length, weight, count_leg, hatched, bonitur, infected) |> 
  mutate_if(is.numeric, round, 2)

rbind(head(flea_model_raw_tbl, n = 3),
      rep("...", times = ncol(flea_model_raw_tbl)),
      tail(flea_model_raw_tbl, n = 3)) |> 
  kable(align = "c", "pipe")
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 10.5
#| fig-cap: "foo. **(A)** Kombinierte Darstellung in einem Scatterplot **(B)** Aufgeteilte Darstellung für beide Entwicklungsstadien. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-1

p1_model_flea + p2_model_flea + p3_model_flea +
  plot_layout(ncol = 3, widths = c(1.25, 1.25, 2.5)) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-infected-model-fleas
#| tbl-cap: "Deskriptive Statistik des Infektionsstatus (0 = nein / 1 = ja) mit Flohschnupfen aufgeteilt nach den Faktoren und anderen Variablen."

flea_model_tbl |>
  select(infected, feeding, stage) |> 
  tbl_summary(
    by = infected,
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{n} / {N} ({p}%)"
    ),
    digits = all_continuous() ~ 2,
    #label = count_color ~ "Anzahl Farben",
    missing_text = "(Missing)"
  )
```

## Visualisierung von Modellen

In dem folgenden Abschnitten wollen wir immer Modell in unsere Visualisierungen einzeichen. Nehmen wir einmal einen simplen Datensatz,d en wir uns einfach selber bauen und dann wollen wir dort eine Linie durchzeichnen. Dafür nehmen wri einmal zwanzig x-Werte und bauen uns dann die y-Werte nach $y = 1.5 + 0.75 \cdot x$ zusammen. Dann addieren wir noch einen Fehler aus einer Standardnormalverteilung hinzu. Wenn wir keinen Fehler hinzuaddieren würden, dann lägen die Punkte wie auf einer Perlenschnur aneinandergereit.

```{r}
set.seed(20250703)
modell_line_tbl <- tibble(x = rnorm(20, 2, 1),
                          y = 1.5 + 0.75 * x + rnorm(length(x), 0, 1))
```

Jetzt können wir einmal das Modell anpassen und schauen, ob wir die Koeffizienten des Modells wiederfinden. Dann wollen wir natürlich auch sehen, ob unser Modell durch die Punkte läuft. Also erstmal das Modell mit `lm()` gebaut. Dann schauen wir uns noch die Koeffizienten einmal mit an. Bei nur so wenigen Beobachtungen werden die Koeffizienten aus dem Modell nicht mit den voreingestellten übereinstimmen.

```{r}
model_fit <- lm(y ~ x, modell_line_tbl)
model_fit
```

In der folgenden Abbildung siehst du dann einmal den Scatterplot von unseren x-Werten und y-Werten. Wir wollen jetzt die Gerade, die wir im Modell geschätzt haben einmal durch die Punkte legen um zu schauen, ob das Modell auch die Punkte beschreibt. Dabei soll die Gerade durch die Mitte der Punkte laufen und die Punkte sollten auf beiden Seiten der Geraden gleichmäßig verteilt sein.

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3
#| fig-width: 7
#| fig-cap: "Scatterplot der x-Werte und y-Werte. Durch die Punkte soll die Gerade aus dem Modell gelegt werden. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-line-01

ggplot(modell_line_tbl, aes(x, y)) +
  theme_minimal() +
  geom_point()
```

Wir haben jetzt verschiedene Möglichkeiten die Koeffizienten und damit das Modell in den obigen Plot einzuzeichnen. Ich zeige dir hier einmal die häufigsten, die ich dann auch nutze. Erstmal die Anwendung direkt in `{ggplot}` und dann einmal noch in dem R Paket `{ggpmisc}`.

#### ...mit `{ggplot}` {.unnumbered .unlisted}

::: panel-tabset
## `geom_function()`

In der Funktion `geom_function()` müssen wir die Funktion angeben, die wir dann abbilden wollen. Wenn du verstehst, was die Koeffizienten in dem Modell bedeuten, dann kannst du natürlich die mathematische Funktion wie hier entsprechend ergänzen.

```{r}
#| message: false
#| echo: true
#| warning: false
#| fig-align: center
#| fig-height: 3
#| fig-width: 7
#| fig-cap: "Scatterplot der x-Werte und y-Werte. Durch die Punkte läuft die Gerade mit den Koeffizienten aus dem Modell. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-line-02

ggplot(modell_line_tbl, aes(x, y)) +
  theme_minimal() +
  geom_point() +
  geom_function(fun = \(x) 1.9574 + 0.5534 * x, 
                color = "#CC79A7")
```

## `geom_line(aes(y = predict(model_fit)))`

Manchmal ist das Modell zu komplex, dass wir die mathematische Funktion einfach aufschreiben könnten. In dem Fall hilft die Funktion `geom_line()` die wir dann die vorhergesagten y-Werte mit der Funktion `predict()` aus dem Modell übergeben. Das funktioniert auch sehr gut.

```{r}
#| message: false
#| echo: true
#| warning: false
#| fig-align: center
#| fig-height: 3
#| fig-width: 7
#| fig-cap: "Scatterplot der x-Werte und y-Werte. Durch die Punkte läuft die Gerade mit den vorhergesagten Werten aus dem Modell. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-line-03

ggplot(modell_line_tbl, aes(x, y)) +
  theme_minimal() +
  geom_point() +
  geom_line(aes(y = predict(model_fit)), 
                color = "#CC79A7")
```

## `geom_smooth()`

Abschließend können wir auch einfach so eine Gerade durch die Punkte legen indem wir die Funktion `geom_smooth()` als eine Art der Glättung nutzen. Aber hier muss ich sagen, dass uns dann die Geradengleichung fehlt. So mal zum gucken ist das wunderbar. Du kannst über die Option `formula` auch eine Funktion übergeben. Darüber hinaus erhalten wir dann noch einen Fehlerbalken des Standardfehlers, was in manchen Fällen nützlich ist. Wenn du die Geradengleichung brauchst, dann schaue einmal in dem Paket `{ggpmisc}` rein.

```{r}
#| message: false
#| echo: true
#| warning: false
#| fig-align: center
#| fig-height: 3
#| fig-width: 7
#| fig-cap: "Scatterplot der x-Werte und y-Werte. Durch die Punkte läuft die Gerade aus einer Glättung. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-line-04

ggplot(modell_line_tbl, aes(x, y)) +
  theme_minimal() +
  geom_point() +
  geom_smooth(method = "lm", color = "#CC79A7") +
  geom_smooth(method = "lm", formula = y ~ I(x^4), 
              color = "#0072B2")
```
:::

#### ...mit `{ggpmisc}` {.unnumbered .unlisted}

Ich möchte hier nich zu sehr in die Tiefe von `{ggpmisc}` gehen, aber das Paket verbindet im Prinzip die Funktion `geom_smooth()` mit der Wiedergabe der Informationen zu den Regressionsgleichungen. Du findest bei StackOverflow einmal eine schöne Übersicht in [Add regression line equation and R\^2 on graph](https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph). Wenn du mehr willst, dann schaue dir einmal die Hilfeseite von `{ggpmisc}` mit [Fitted-Model-Based Annotations](https://cran.r-project.org/web/packages/ggpmisc/vignettes/model-based-annotations.html) näher an. Es geht echt eine Menge, von dem ich hier nur einmal den Klassiker zeige. Wir wollen einmal die Regressionsgleichung plus das Bestimmtheitsmaß einzeichnen. Das geht über drei Funktionen zusammen mit der Regressionsgeraden.

```{r}
#| message: false
#| echo: true
#| warning: false
#| fig-align: center
#| fig-height: 3
#| fig-width: 7
#| fig-cap: "Scatterplot der x-Werte und y-Werte. Durch die Punkte läuft die Gerade aus einer Glättung plus die Geradengleichung und das Bestimmtheitsmaß. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-line-05

ggplot(modell_line_tbl, aes(x, y)) +
  theme_minimal() +
  geom_point() +
  stat_poly_line(color = "#CC79A7") +
  stat_poly_eq(use_label("eq")) +
  stat_poly_eq(label.y = 0.9) 
```

## Datenraster

Was ist ein Datenraster (eng. *data grid*) eigentlich? Wir brauchen die Idee des Datenrasters um überhaupt die Vorhersagen und die Steigungen zu verstehen. Im Prinzip beinhaltet das Datenraster die Information zu welchen Beobachtungen wir eine Vorhersage machen wollen. Wenn wir nochmal kutz zu dem Enyzmebeispiel kommen, zu welchen pH-Werten möchtest du dann eine Steigung oder aber eine Vorhersage der Enzymetätigkeit haben? Beginnen wir mit einem einfachen Beispiel um zu verstehen was die einzelnen Datenraster aussagen wollen.

In Folgenden siehst du einmal einen kleinen Datensatz mit einer numerischen Variable, einer dichotomen Variable sowie einer Variable mit drei Kategorien. So ähnlich haben wir ja auch Datensätze in echt vorliegen.

```{r}
set.seed(20250709)
grid_tbl <-  tibble(numerisch = rnorm(n = 8),
                    dichotom = rbinom(n = 8, size = 1, prob = 0.5),
                    kategorial = sample(c("niedrig", "mittel", "hoch"), 
                                        size = 8, replace = TRUE))
```

#### Beobachtetes Raster (eng. *empirical grid*) {.unnumbered .unlisted}

```{r}
grid_tbl |> tt()
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7.5
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-grid-01

a_line <- \(x) x^3 + -8*x^2 + 10*x + 10

enzyme_tbl|> 
  ggplot(aes(ph, activity)) +
  theme_marginal() +
  geom_function(fun = a_line, linewidth = 1, color = "black", alpha = 0.5) +
  scale_x_continuous(breaks = c(-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 7.5), limits = c(-2, 8)) +
  scale_y_continuous(breaks = c(-50, 0, 50, 100), limits = c(-55, 75)) +
  geom_vline(xintercept = c(-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 7.5),
             color = "#D55E00", linetype = 21, size = 1) +
  geom_point() +
  labs(x = "Korrigierter pH-Wert", y = "Standardisierte Enzymaktivität",
       title = "Beobachtetes Raster") +
  theme(legend.position = "none") +
  theme(panel.grid.major.y = element_blank())
```

#### Interessantes Raster (eng. *interesting grid*) {.unnumbered .unlisted}

```{r}
datagrid(dichotom = c(0, 1), newdata = grid_tbl) |> tt()
```

```{r}
datagrid(numerisch = range, dichotom = mean, kategorial = unique, 
         newdata = grid_tbl) |> tt()
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7.5
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-grid-02

a_line <- \(x) x^3 + -8*x^2 + 10*x + 10

enzyme_tbl|> 
  ggplot(aes(ph, activity)) +
  theme_marginal() +
  geom_function(fun = a_line, linewidth = 1, color = "black", alpha = 0.5) +
  scale_x_continuous(breaks = c(0, 1, 2, 3.5, 5.5, 7), limits = c(-2, 8)) +
  scale_y_continuous(breaks = c(-50, 0, 50, 100), limits = c(-55, 75)) +
  geom_vline(xintercept = c(0, 1, 2, 3.5, 5.5, 7),
             color = "#0072B2", linetype = 21, size = 1) +
  geom_point() +
  labs(x = "Korrigierter pH-Wert", y = "Standardisierte Enzymaktivität",
       title = "Interessantes Raster") +
  theme(legend.position = "none") +
  theme(panel.grid.major.y = element_blank())
```

#### Repräsentatives Raster (eng. *representative grid*) {.unnumbered .unlisted}

```{r}
datagrid(grid_type = "mean_or_mode", newdata = grid_tbl) |> tt()
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7.5
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-grid-03

a_line <- \(x) x^3 + -8*x^2 + 10*x + 10
mean_rep_grid <- mean(c(-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 7.5))

enzyme_tbl|> 
  ggplot(aes(ph, activity)) +
  theme_marginal() +
  geom_function(fun = a_line, linewidth = 1, color = "black", alpha = 0.5) +
  scale_x_continuous(breaks = mean_rep_grid, limits = c(-2, 8),
                     label = expression(bar(y)[pH])) +
  scale_y_continuous(breaks = c(-50, 0, 50, 100), limits = c(-55, 75)) +
  geom_vline(xintercept = mean_rep_grid,
             color = "#CC79A7", linetype = 21, size = 1) +
  geom_point() +
  labs(x = "Korrigierter pH-Wert", y = "Standardisierte Enzymaktivität",
       title = "Interessantes Raster") +
  theme(legend.position = "none") +
  theme(panel.grid.major.y = element_blank())
```

#### Balanciertes Raster (eng. *balanced grid*) {.unnumbered .unlisted}

```{r}
datagrid(grid_type = "balanced", newdata = grid_tbl) |> tt()
```

#### Kontrafaktisches Raster (eng. *counterfactual grid*) {.unnumbered .unlisted}

```{r}
cf_grid <- datagrid(
  dichotom = c(0, 1),
  grid_type = "counterfactual",
  newdata = grid_tbl[1:5,]
)
nrow(cf_grid )
```

::: panel-tabset
## Beobachtete Daten

```{r}
grid_tbl[1:5,] |> tt()
```

## Kontrafaktisches Raster

```{r}
cf_grid |> tt()
```
:::

## Steigung (eng. *slopes*)

> *"Let us introduce another concept that is likely to get very popular in the near future within the world of regressions. Derivatives." --- [`{modelbased}`](https://easystats.github.io/modelbased/articles/derivatives.html#effect-derivatives)*

### Marginale Effekte

Hier sprechen wir von der Ableitung (eng. *derivative*)

#### Modellierung von Flöhen {.unnumbered .unlisted}

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "foo. **(A)** Kombinierte Darstellung in einem Scatterplot **(B)** Aufgeteilte Darstellung für beide Entwicklungsstadien. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-2

p1_slope_flea <- ggplot(flea_model_tbl, aes(x = hatched, y = jump_length)) +
  theme_marginal() +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x, linewidth = 1, 
              color = cb_pal[2], se = FALSE) +
  geom_richtext(aes(x = 625, y = 113, 
                    label = "f(x) = 52.07 + 1.61x<br>f'(x) = 1.61")) +
  labs(x = "Schlupfzeit in [h]", y = "Sprungweite in [cm]",
       title = "Linearer Zusammenhang") 

p2_slope_flea <- ggplot(flea_model_tbl, aes(x = weight, y = jump_length)) +
  theme_marginal() +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), linewidth = 1, 
              color = cb_pal[3], se = FALSE) +
  geom_richtext(aes(x = 15, y = 112, 
                    label = "f(x) = 47.10 + 2.62x - 0.04x²<br>f'(x) = 2.62 - 0.08x")) +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Quadratischer Zusammenhang") 

p1_slope_flea + p2_slope_flea +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

::: panel-tabset
## Linearer Zusammenhang ($y \sim x$)

```{r}
model_ln <- lm(jump_length ~ weight,
               data = flea_model_tbl)
tidy(model_ln)
```

$$
\begin{aligned}
\operatorname{E}[y \mid x] &= \beta_0 + \beta_1 x \\[4pt]
\frac{\partial \operatorname{E}[y \mid x]}{\partial x} &= \beta_1
\end{aligned}
$$

$$
\begin{aligned}
\operatorname{E}[\text{Sprungweite} \mid \text{Gewicht}] &= 52.10 + 1.61 \times \text{Gewicht} \\[6pt]
\frac{\partial \operatorname{E}[\text{Sprungweite} \mid \text{Gewicht}]}{\partial\ \text{Gewicht}} &= 1.61
\end{aligned}
$$

## Quadratischer Zusammenhang ($y \sim x + x^2$)

[R Paket `{polypoly}`](https://cran.r-project.org/web/packages/polypoly/vignettes/overview.html)

[Polynomial Regression - An example](https://www.geo.fu-berlin.de/en/v/soga-r/Basics-of-statistics/Linear-Regression/Polynomial-Regression/Polynomial-Regression---An-example/index.html)

[Fitting Polynomial Regression in R](https://datascienceplus.com/fitting-polynomial-regression-r/)

```{r}
model_sq <- lm(jump_length ~ weight + I(weight^2),
               data = flea_model_tbl)
tidy(model_sq)
```

$$
\begin{aligned}
\operatorname{E}[y \mid x] &= \beta_0 + \beta_1 x + \beta_2 x^2 \\[4pt]
\frac{\partial \operatorname{E}[y \mid x]}{\partial x} &= \beta_1 + 2 \beta_2 x
\end{aligned}
$$

$$
\begin{aligned}
\operatorname{E}[\text{Sprungweite} \mid \text{Gewicht}] &= 47.10 + (2.62 \times \text{Gewicht}) + (−0.04 \times \text{Gewicht}^2) \\[6pt]
\frac{\partial \operatorname{E}[\text{Sprungweite} \mid \text{Gewicht}]}{\partial\ \text{Gewicht}} &= 2.62 + (2\times −0.04 \times \text{Gewicht})
\end{aligned}
$$
:::

```{r}
jump_weight_slope <- function(x) 2.62 + (2 *-0.04 * x)
jump_weight_slope(c(5, 10, 15))
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "foo. . *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-3

tangents <- model_sq |> 
  augment(newdata = tibble(weight = c(5, 15, 25))) |> 
  mutate(slope = jump_weight_slope(weight),
         intercept = find_intercept(weight, .fitted, slope)) |> 
  mutate(nice_label = glue("Gewicht: {weight}<br>",
                           "Fitted Gewicht: {nice_number(.fitted)}<br>",
                           "Steigung: **{nice_number(slope)}**"))

ggplot(flea_model_tbl, aes(x = weight, y = jump_length)) +
  theme_marginal() +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), linewidth = 1.25, 
              se = FALSE, color = cb_pal[3], fullrange = TRUE) +
  geom_abline(data = tangents, aes(slope = slope, intercept = intercept), 
              linewidth = 0.5, color = cb_pal[8], linetype = "21") +
  geom_point(data = tangents, aes(x = weight, y = .fitted), 
             size = 4, shape = 18, color = cb_pal[9]) +
  geom_richtext(data = tangents,
                aes(x = weight, y = .fitted, label = nice_label), nudge_y = -7) +
  scale_x_continuous(breaks = seq(0, 30, 5), limits = c(0, 30)) +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]") 

```

::: panel-tabset
## `{marginaleffects}`

```{r}
#| message: false
#| warning: false
model_sq |> 
  slopes(newdata = datagrid(weight = c(5, 15, 25)))
```

## `{emmeans}`

```{r}
#| message: false
#| warning: false
model_sq |> 
  emtrends(~ weight, var = "weight",
           at = list(weight = c(5, 15, 25))) |> 
  test()
```
:::

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "foo. . *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-4

plot_slopes(model_sq, 
            variables = "weight", 
            condition = "weight") +
  labs(x = "Civil liberties", y = "Marginal effect of civil liberties on public sector corruption",
       subtitle = "Created automatically with marginaleffects::plot_slopes()") +
  theme_marginal()
```

#### Modellierung von Enzymen {.unnumbered .unlisted}

Nachdem wir das einmal konzeptionellm haben einmal komplexer.

::: panel-tabset
## `gam()`

```{r}
#| message: false
#| echo: false
#| warning: false

gam_fit <- gam(activity ~ s(ph), data = enzyme_tbl)
slopes(gam_fit, newdata = datagrid(ph = c(-1, 2, 6)))
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: " **(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-slope-02

p1_intro_00_1 + 
  labs(title = "Theoretisches Modell") +
  p1_slope_01  +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

## `poly()`

```{r}
#| message: false
#| echo: false
#| warning: false

poly_fit <- lm(activity ~ poly(ph, 3), data = enzyme_tbl)
slopes(poly_fit, newdata = datagrid(ph = c(-1, 2, 6)))
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: " **(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-slope-01

p1_intro_00_1 + 
  labs(title = "Theoretisches Modell") +
  p1_slope_00  +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

## `loess()`

```{r}
#| message: false
#| echo: false
#| warning: false
loess_fit <- loess(activity ~ ph, data = enzyme_tbl)
slopes(loess_fit, newdata = datagrid(ph = c(-1, 2, 6)))
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: " **(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-slope-03

p1_intro_00_1 + 
  labs(title = "Theoretisches Modell") +
  p1_slope_02  +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```
:::

::: callout-note
## Philosophien zur Mittelwertbildung

#### Average marginal effects (AME) {.unnumbered .unlisted}

```{r}
jump_weight_slope <- function(x) 2.62 + (2 *-0.04 * x)
jump_weight_slope(c(5, 10, 15))
```

![foo. Modifiziert nach @heiss2022](images/marginal/flow-ame-trans.png){#fig-utest-intro-03 fig-align="center" width="100%"}

```{r}
model_sq <- lm(jump_length ~ weight + I(weight^2),
               data = flea_model_tbl)
tidy(model_sq)
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-5

tangents <- model_sq |> 
  augment(newdata = tibble(weight = c(1:27))) |> 
  mutate(slope = jump_weight_slope(weight),
         intercept = find_intercept(weight, .fitted, slope)) |> 
  mutate(nice_label = glue("Gewicht: {weight}<br>",
                           "Fitted Gewicht: {nice_number(.fitted)}<br>",
                           "Steigung: **{nice_number(slope)}**"))

ggplot(flea_model_tbl, aes(x = weight, y = jump_length)) +
  theme_marginal() +
  geom_point() +
  geom_abline(data = tangents, aes(slope = slope, intercept = intercept), 
              linewidth = 0.5, color = cb_pal[8], linetype = "21") +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), linewidth = 1.25, 
              se = FALSE, color = cb_pal[3], fullrange = TRUE) +
  geom_point(data = tangents, aes(x = weight, y = .fitted), 
             size = 4, shape = 18, color = cb_pal[9]) +
  geom_richtext(aes(x = 15, y = 88, label = "Gemittelte Steigung: 1.83"),
                site = 20) +
  scale_x_continuous(breaks = seq(0, 30, 5), limits = c(0, 30)) +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Average marginal effects (AME)") 
```

```{r}
mfx_sq <- slopes(model_sq)
head(mfx_sq)
```

```{r}
mfx_sq |> 
  group_by(term) |> 
  summarize(avg_slope = mean(estimate))
```

```{r}
avg_slopes(model_sq)
```

#### Marginal effects at the mean (MEM) {.unnumbered .unlisted}

![foo. Modifiziert nach @heiss2022](images/marginal/flow-mem-trans.png){#fig-utest-intro-06 fig-align="center" width="100%"}

```{r}
model_sq <- lm(jump_length ~ weight + I(weight^2),
               data = flea_model_tbl)
tidy(model_sq)
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "foo. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-6

ggplot(flea_model_tbl, aes(x = weight, y = jump_length)) +
  theme_marginal() +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), linewidth = 1.25, 
              se = FALSE, color = cb_pal[3], fullrange = TRUE) +
  geom_abline(intercept = find_intercept(9.95375, 69.24257, 1.83), slope = 1.83,
              linewidth = 0.5, color = cb_pal[8], linetype = "21") +
  annotate("point", x = 9.95375, y = 69.24, size = 4, shape = 18, 
           color = cb_pal[9]) +
  geom_richtext(aes(x = 10, y = 75, label = "Steigung am Mittelwert: 1.83"),
                site = 20) +
  scale_x_continuous(breaks = seq(0, 30, 5), limits = c(0, 30)) +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Marginal effects at the mean (MEM)") 
```

```{r}
avg_jump_weight <- mean(flea_model_tbl$weight)
avg_jump_weight
```

```{r}
jump_weight_fitted <- model_sq |> 
  augment(newdata = tibble(weight = c(avg_jump_weight, avg_jump_weight + 0.001)))
jump_weight_fitted
```

```{r}
model_sq |> 
  emtrends(~ weight, var = "weight")
```

```{r}
model_sq |> 
  avg_slopes(newdata = "mean")
```
:::

### Gruppierte marginale Effekte

![foo. Modifiziert nach @heiss2022](images/marginal/flow-game-trans.png){#fig-utest-intro-05 fig-align="center" width="100%"}

Hier ist die Anordugn wichtig. Erst kommt die gruppierende Variable, dann der Rest.

```{r}
model_grp_sq <- lm(jump_length ~ stage * weight + I(weight^2),
                   data = flea_model_tbl)
tidy(model_grp_sq)
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "foo. **(A)** Kombinierte Darstellung in einem Scatterplot **(B)** Aufgeteilte Darstellung für beide Entwicklungsstadien. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-7

ggplot(flea_model_tbl, aes(x = weight, y = jump_length,
                           color = stage)) +
  theme_marginal() +
  geom_point() +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Quadratischer Zusammenhang") +
  geom_line(aes(y = predict(model_grp_sq)), linewidth = 1.25) +
  scale_color_okabeito()
```

::: panel-tabset
## Schritt-für-Schritt

```{r}
mfx_grp_sq <- model_grp_sq |> 
  slopes(variables = "weight")
head(mfx_grp_sq)
```

```{r}
mfx_grp_sq |> 
  group_by(stage) |> 
  summarize(stage_ame = mean(estimate))
```

## `slopes()`

```{r}
model_grp_sq |> 
  slopes(variables = "weight",
         by = "stage")
```
:::

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "foo. **(A)** Kombinierte Darstellung in einem Scatterplot **(B)** Aufgeteilte Darstellung für beide Entwicklungsstadien. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-8

weight_sum <- flea_model_tbl |> 
  group_by(stage) |> 
  summarise(mean(weight))

pred <- predict(model_grp_sq, newdata = tibble(weight = 14.05, stage = "adult"))

ggplot(flea_model_tbl, aes(x = weight, y = jump_length,
                           color = stage)) +
  theme_marginal() +
  geom_point() +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Quadratischer Zusammenhang") +
  geom_abline(intercept = find_intercept(14.05, 75.6691, 0.438), slope = 0.438,
              linewidth = 0.5, color = cb_pal[8], linetype = "21") +
  geom_abline(intercept = find_intercept(5.85, 58.59134, 0.807), slope = 0.807,
              linewidth = 0.5, color = cb_pal[7], linetype = "21") +
  geom_line(aes(y = predict(model_grp_sq)), linewidth = 1.25,
            fullrange = TRUE) +
  annotate("point", x = 14.05, y = 75.6691, size = 4, shape = 18, 
           color = cb_pal[9]) +
  annotate("point", x = 5.85, y = 58.59134, size = 4, shape = 18, 
           color = cb_pal[9]) +
  geom_richtext(aes(x = 14.05, y = 81, label = "Steigung adult: 0.44"),
                site = 20, color = "black") +
  geom_richtext(aes(x = 5.85, y = 64.5, label = "Steigung juvenile: 0.81"),
                site = 20, color = "black") +
  scale_color_okabeito()
```

### Repräsentative Werte

![foo. Modifiziert nach @heiss2022](images/marginal/flow-mer-trans.png){#fig-utest-intro-07 fig-align="center" width="100%"}

```{r}
model_grp_sq <- lm(jump_length ~ feeding * weight + I(weight^2),
                   data = flea_model_tbl)
tidy(model_grp_sq)
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "foo. **(A)** Kombinierte Darstellung in einem Scatterplot **(B)** Aufgeteilte Darstellung für beide Entwicklungsstadien. *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-data-9

ggplot(flea_model_tbl, aes(x = weight, y = jump_length,
                           color = feeding)) +
  theme_marginal() +
  geom_point() +
  labs(x = "Gewicht in [mg]", y = "Sprungweite in [cm]",
       title = "Quadratischer Zusammenhang") +
  geom_line(aes(y = predict(model_grp_sq)), linewidth = 1.25) +
  scale_color_okabeito()
```

```{r}
datagrid(model = model_grp_sq,
         weight = c(5, 10, 15),
         feeding = unique)
```

::: panel-tabset
## Ohne Gruppenvergleich

```{r}
model_grp_sq |> 
  slopes(variables = "weight",
         newdata = datagrid(weight = c(5, 10, 15),
                            feeding = unique))
```

## Mit Gruppenvergleich

```{r}
comp_tbl <- as.data.frame(t(combn(levels(flea_model_tbl$feeding), 2))) |> 
    unite("z", sep = " - ")
```

```{r}
model_grp_sq |> 
  slopes(variables = "weight",
         newdata = datagrid(weight = c(5),
                            feeding = unique))
```

```{r}
#| eval: false
model_grp_sq |> 
  slopes(variables = "weight",
         newdata = datagrid(weight = c(5),
                            feeding = unique),
         hypothesis = "pairwise")  |> 
  mutate(term = pluck(comp_tbl, "z"))
```
:::

```{r}
model_grp_sq |> 
  emtrends(~ weight + feeding, 
           var = "weight",
           at = list(weight = c(5, 10, 15),
                     feeding = c("sugar_water", "ketchup", "blood")),
           regrid = "response") 
```

## Vorhersagen (eng. *predictions*)

```{r}
#| message: false
#| warning: false

loess_fit <- loess(activity ~ ph, data = enzyme_tbl)
```

```{r}
predictions(loess_fit)
```

```{r}
predictions(loess_fit, by = "ph")
```

#### Kontinuierliche $x$-Werte {.unnumbered .unlisted}

::: panel-tabset
## `gam()`

```{r}
#| message: false
#| warning: false
gam_fit <- gam(activity ~ s(ph), data = enzyme_tbl)
```

```{r}
#| message: false
#| warning: false
gam_pred <- predictions(gam_fit, newdata = datagrid(ph = c(-1, 2, 6)))
gam_pred
```

## `poly()`

```{r}
#| message: false
#| warning: false
poly_fit <- lm(activity ~ poly(ph, 3), data = enzyme_tbl)
```

```{r}
poly_pred <- predictions(poly_fit, newdata = datagrid(ph = c(-1, 2, 6)))
poly_pred
```

## `loess()`

```{r}
#| message: false
#| warning: false
loess_fit <- loess(activity ~ ph, data = enzyme_tbl)
```

```{r}
loess_pred <- predictions(loess_fit, newdata = datagrid(ph = c(-1, 2, 6)))
loess_pred
```
:::

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 5
#| fig-width: 9.5
#| fig-cap: "**(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-predict-01

p2_intro_00_2 + 
  labs(title = "Theoretisches Modell") +
  p1_predict_00 +
  plot_layout(ncol = 2) +
  plot_annotation(tag_levels = 'A', tag_prefix = '(', tag_suffix = ')') &
  theme(plot.tag = element_text(size = 16, face = "bold"))
```

#### Kategoriale $x$-Werte {.unnumbered .unlisted}

::: callout-warning
## Achtung, bitte beachten!

Ich persönlich finde die Implementierung des multiplen Testens in `{emmeans}` um Längen besser gelöst. Den Rest von `{marginaleffects}` dann eher nicht so. Daher würde ich dir hier davon abraten, deine Gruppenvergleiche mit `predictions()` zu rechnen. Es ist gut zu verstehen was die Funktion macht, aber `{emmeans}` hat den klaren Vorteil, dass wir das *Compact letter disply* berechnen können. Darüber hinaus finde ich die zweifaktorielle Analyse besser gelöst durch die beiden Zeichen Stern `*` und Strich `|` besser gelöst. In `{marginaleffects}` haben wir dann die Problematik mit den Hypothesen und Gruppennamen innerhalb der Ausgabe der Funktion `hypotheses()`. Hier nochmal die Alternativen in `{emmeans}`, die ich hier aber dann nicht ausführen lasse. Bitte schaue dann nochmal in das [Kapitel zu den Post-hoc Tests](#sec-posthoc) vorbei.

```{r}
#| eval: false
enzyme_1fac_fit |> 
  emmeans(~ grp, vcov = sandwich::vcovHAC) |> 
  contrast(method = "pairwise", adjust = "bonferroni")
```

```{r}
#| eval: false
enzyme_2fac_fit |> 
  emmeans(~ grp | type, vcov = sandwich::vcovHAC) |> 
  contrast(method = "pairwise", adjust = "bonferroni")
```
:::

::: {layout="[15,85]" layout-valign="top"}
![](images/personal_opinion.png){fig-align="center" width="100%"}

> *"Manchmal schaue ich mir sehr lange Funktionen oder Pakete wie hier `{marginaleffects}` an und muss dann feststellen, dass für eien spezielle Orichideenanwendung dann doch ein anderes Paket besser ist. Ist nicht schlimm, dann musst du dir nicht die Arbeit machen. Für das faktorielle Experiment würde ich dann immer `{emmeans}` nehmen." --- Jochen Kruppa-Scheetz, meiner bescheidener Meinung nach.*
:::

Die Funktion `hypotheses()` ist mächtig.

::: panel-tabset
## Vorhersage 1-faktoriell

```{r}
enzyme_1fac_fit <-  lm(activity ~ grp, data = enzyme_tbl)
```

```{r}
#| message: false
#| warning: false
predictions(enzyme_1fac_fit, by = c("grp"), vcov = "HAC")
```

```{r}
#| message: false
#| warning: false
predictions(enzyme_1fac_fit, by = c("grp"), vcov = "HAC",
            hypothesis = ~pairwise)  |> 
  hypotheses(multcomp = "bonferroni")
```

```{r}
#| message: false
#| warning: false
predictions(enzyme_1fac_fit, by = c("grp"), vcov = "HAC",
            hypothesis = ~pairwise) 
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "**(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-predict-02

plot_predictions(enzyme_1fac_fit, by = c("grp")) +
  theme_minimal()
```

## Vorhersage 2-faktoriell

```{r}
enzyme_2fac_fit <- lm(activity ~ grp * type, data = enzyme_tbl)
```

```{r}
#| message: false
#| warning: false

predictions(enzyme_2fac_fit, by = c("grp", "type"), vcov = "HAC",
            hypothesis = ~pairwise | type, 
            newdata = "balanced") 
```

```{r}
#| message: false
#| warning: false

predictions(enzyme_2fac_fit, by = c("grp", "type"), vcov = "HAC",
            newdata = "balanced") |> 
  hypotheses(~pairwise | type, multcomp = "bonferroni")
```

```{r}
#| message: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "**(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-predict-03

plot_predictions(enzyme_2fac_fit, by = c("grp", "type")) +
  theme_minimal()
```
:::

:::: callout-note
## Vergleich `{marginaleffects}` und `{emmeans}`

```{r}
feeding_fit <-  lm(jump_length ~ feeding * stage, data = flea_model_tbl)
```

::: panel-tabset
## `{marginaleffects}`

```{r}
predictions(feeding_fit, by = c("stage", "feeding"), vcov = "HAC")
```

```{r}
predictions(feeding_fit, by = c("stage", "feeding"), vcov = "HAC",
            hypothesis = ~pairwise | stage)
```

```{r}
predictions(feeding_fit, by = c("stage", "feeding"), vcov = "HAC") |> 
  hypotheses(multcomp = "bonferroni")
```

```{r}
#| message: false
#| echo: false
#| warning: false
#| fig-align: center
#| fig-height: 3.5
#| fig-width: 7
#| fig-cap: "**(A)** Linearer Zusammenhang. **(B)** ggg *[Zum Vergrößern anklicken]*"
#| label: fig-marginal-model-predict-04

plot_predictions(feeding_fit, by = c("stage", "feeding")) +
  theme_minimal()
```

## `{emmeans}`

```{r}
feeding_fit |> 
  emmeans(~ feeding | stage, vcov = sandwich::vcovHAC)
```

```{r}
feeding_fit |> 
  emmeans(~ feeding | stage, vcov = sandwich::vcovHAC) |> 
  contrast(method = "pairwise", adjust = "bonferroni")
```
:::
::::

### Kontrafaktische Vergleiche (eng. *counterfactual*)

### Hypothesen- und Äquivalenztests

## Referenzen {.unnumbered}
