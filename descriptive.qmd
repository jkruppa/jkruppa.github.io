# Explorative Datenanalyse

Im folgenden Kapitel wollen wir uns mit der explorativen Datenanalyse
beschäftigen. Die explorative Datenanlalyse hat das Ziel Daten $D$
zusammenzufassen und/oder zu visualisieren. Damit stell die
explorative Datenanalyse den ersten Schritt zum Erkenntnisgewinn über
ein Experiment dar.

## Genutzte R Pakete für das Kapitel

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
pacman::p_load(tidyverse, readxl)
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem
Rutsch zum selber durchführen oder aber kopieren.



## Absolutes Verhältnis

Wir schreiben, dass 3 von 4 Hunden von Flöhen befallen sind.

## Relatives Verhältnis oder Risk Ratio

Wir schreiben, dass $3/7 = 0.43 = 43\%$ der Hunden einen Flohbefall haben.


## Chancenverhältnis oder Odds Ratio

Wir schreiben, dass die Chance von Flöhen infiziert zu sein $4:3 = 4/3
= 1.33 = 133\%$ ist.







```{r }
x <- c("dog", "dog", "dog", "cat", "cat", "cat")

as.factor(x)

factor(x, levels = c("dog", "cat"))

factor(x, labels = c("katze", "hund"))


dose <- c("low", "low", "mid", "mid", "high", "high")

as.factor(dose)

factor(dose, levels = c("low", "mid", "high"))



```




## Deskriptive Statistik





Wir messen sieben Sprungweiten von sieben Hundeflöhen und messen
dabei folgende Werte in [cm]: `r pander::p(y_dog, wrap = "", copula = " und
")`. Wir schreiben nun y als einen Vektor in der Form 

$$
y = \{`r str_c(y_dog, collapse = ", ")`\}.
$$

In R würde der Vektor wie etwas anders aussehen.

```{r }
y <- c(5.2, 4.9, 12.1, 8.2, 5.6, 9.1, 7.4) 
```


### Mittelwert

$$
\bar{y} = \sum_{i=1}^{n}\cfrac{x_i}{n} =
\cfrac{`r str_c(x, collapse = " + ")`}{`r length(y)`} =
`r mean(y)`
$$


```{r }
y %>% mean
```

### Spannweite oder range

$$
y_{range} = y_{max} - y_{min} = 12.1 - 4.9 = 7.2
$$

```{r }
range(y) 
```

### Varianz

$$
s^2 = \sum_{i=1}^n\cfrac{(y_i - \bar{y})^2}{n-1} = \cfrac{(5.2 -
7.5)^2 + (4.9 - 7.5)^2 + ... + (7.4 - 7.5^2)}{7-1} = 6.65
$$


```{r }
y %>% var %>% round(2) 
```

### Standardabweichung

$$
s = \sqrt{s^2} = \sqrt{6.65} = 2.58
$$


```{r }
y %>% sd %>% round(2) 
```

### Standardfehler oder Standard Error (SE)

$$
SE = \cfrac{s}{\sqrt{n}} = \cfrac{2.58}{2.65} = 0.97
$$

```{r }
se <- sd(y)/sqrt(length(y))
se %>% round(2)
```


### Median

$$
4.9,  5.2,  5.6,  \underbrace{7.4,}_{Median}  8.2,  9.1, 12.1
$$

```{r }
median(y) 
```


### Quartile

$$
4.9,  \underbrace{5.2,}_{1st\ Quartile}  5.6,  7.4,  8.2,  9.1, 12.1
$$


$$
4.9,  5.2,  5.6,  7.4,  8.2,  \underbrace{9.1,}_{3rd\ Quartile} 12.1
$$


```{r }
quantile(y, probs = c(0.25, 0.5, 0.75)) 
```

Warum unterscheiden sich die händisch berechneten Quartile von den
Quartilen aus R? Es gibt verschiedene Arten der Berechnung. In der
Klausur nutzen wir die Art und Weise wie die händische Berechnung hier
beschrieben ist. Später in der Anwendung nehmen wir die Werte, die R
ausgibt. Die Abweichungen sind so maginal, dass wir diese Abweichungen
in der praktischen Anwendung ignorieren wollen.

### Interquartilesabstand (IQR)

$$
IQR = \mbox{3rd Quartile} - \mbox{1st Quartile} = 9.1 - 5.2 = 3.9
$$

### Datenbeispiel


## Wide format

| dog | cat  |
|:---:|:---:|
| 5.2 | 10.1 |
| 4.9 | 9.4 |
| 12.1 | 11.8 |
| 8.2 | 6.7 |
| 5.6  | 8.2 |
| 9.1  | 9.1 |
| 7.4  | 7.1 |


```{r }
jump_wide_tbl <- tibble(dog = c(5.2, 4.9, 12.1, 8.2, 5.6, 9.1, 7.4),
                   cat = c(10.1, 9.4, 11.8, 6.7, 8.2, 9.1, 7.1))

jump_wide_tbl
```

## Long format

```{r }
jump_tbl <- tibble(dog = c(5.2, 4.9, 12.1, 8.2, 5.6, 9.1, 7.4),
                   cat = c(10.1, 9.4, 11.8, 6.7, 8.2, 9.1, 7.1)) %>%
  gather(key = "animal", value = "jump_length")
jump_tbl

```

## Zusammenfassen von Daten per Faktor

```{r }
jump_tbl %>%
  gather(key = "animal", value = "jump_length") %>%
  mutate(animal = as_factor(animal)) %>%
  group_by(animal) %>%
  summarise(mean(jump_length),
            sd(jump_length))


```

### Mehr Daten oder zwei Gruppen

Bis jetzt haben wir uns die Sprungweite [cm] nur für Hunde
angeschaut. 

$$
y_{dog} = \{`r str_c(y_dog, collapse = ", ")`\}.
$$

Wenn wir nun noch die Sprungweite von Katzen hinzunehmen, dann
erhalten wir einen weiteren Vektor $y_{cat}$ an Sprungweiten [cm].

$$
y_{cat} = \{`r str_c(y_cat, collapse = ", ")`\}.
$$


$$
y_{dog,\, cat} = \{`r str_c(c(y_dog, y_cat), collapse = ", ")`\}.
$$


$$
y = 
\begin{pmatrix}
`r str_c(c(y_dog, y_cat), collapse = "\\\\ ")`
\end{pmatrix}
x =
\begin{pmatrix}
`r str_c(rep(c("dog", "cat"), each = 7), collapse = "\\\\ ")`
\end{pmatrix}
$$

```{r }

tibble(y = c(y_dog, y_cat),
       x = rep(c("dog", "cat"), each = 7))

```



## Grundlagen in ggplot()

```{r echo = TRUE, fig.width = 5, fig.height = 5}
data_tbl <- read_excel(file.path("data/germination_data.xlsx"))

ggplot(data = data_tbl, aes(x = treatment, y = freshmatter))

```


## Häufig verwendete Abbildungen

### Histogramm

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = freshmatter)) +
  geom_histogram(binwidth = 2.5, fill = "gray", color = "black") +
  theme_bw()

```

Wenn wir viele Beobachtungen haben. Viele meint mehr als zwanzig Beobachtungen.

### Density Plot


```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = freshmatter)) +
  geom_density(fill = "gray", color = "black") +
  xlim(0, 50) +
  theme_bw()

```

Wenn wir viele Beobachtungen.

### Boxplot

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = treatment, y = freshmatter,
                            fill = treatment)) +
  geom_boxplot() +
  theme_bw()

```

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = treatment, y = freshmatter,
                            fill = treatment)) +
  geom_boxplot() +
  geom_jitter(width = 0.25) +
  theme_bw()

```

Wenn wir wenige Beobachtungen haben.

### Dotplot

Wenn wir ganz wenige Beobachtungen haben.

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = treatment, y = root_health,
                            fill = treatment)) +
  geom_dotplot(binaxis = "y", stackdir = "center") +
  theme_bw()

```

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = freshmatter, fill = treatment)) +
  geom_dotplot(method="histodot", binwidth = 2.5) +
  theme_bw()

```


```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = treatment, y = freshmatter,
                            fill = treatment)) +
  geom_violin() +
  geom_dotplot(binaxis = "y", stackdir = "center", fill = "black") +
  theme_bw()

```

```{r echo = TRUE, fig.width = 5, fig.height = 5}
ggplot(data = data_tbl, aes(x = treatment, y = root_health,
                            fill = treatment)) +
  geom_dotplot(binaxis = "y", stackdir = "center") +
  stat_summary(fun = median, fun.min = median, fun.max = median,
               geom = "crossbar", width = 0.5) +
  theme_bw()

```


### Scatterplot

```{r echo = TRUE, fig.width = 5, fig.height = 5}
ggplot(data = data_tbl, aes(x = freshmatter, y = drymatter)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  theme_bw()

```

### Mosaic Plot



### Abbildungen beschriften

```{r echo = TRUE, fig.width = 5, fig.height = 5}

ggplot(data = data_tbl, aes(x = treatment, y = freshmatter,
                            fill = treatment)) +
  geom_boxplot() +
  labs(title = "Frischgewicht in Abhängigkeit von der Behandlung",
       x = "Behandlung", y = "Frischgewicht in kg/ha",
       fill = "Behandlung") +
  theme_bw()

```


## Methods

We describe our methods in this chapter.

Math can be added in body using usual syntax like this 

## math example

$p$ is unknown but expected to be around 1/3. Standard error will be approximated

$$
SE = \sqrt(\frac{p(1-p)}{n}) \approx \sqrt{\frac{1/3 (1 - 1/3)} {300}} = 0.027
$$

You can also use math in footnotes like this^[where we mention $p = \frac{a}{b}$].

We will approximate standard error to 0.027[^longnote]

[^longnote]: $p$ is unknown but expected to be around 1/3. Standard error will be approximated

    $$
    SE = \sqrt(\frac{p(1-p)}{n}) \approx \sqrt{\frac{1/3 (1 - 1/3)} {300}} = 0.027
    $$
