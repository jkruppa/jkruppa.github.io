# Von Buchstaben und Zahlen

```{r}
#| warning: false
#| echo: false

pacman::p_load(tidyverse, readxl, knitr, kableExtra)
data_tbl <- read_excel("data/flea_dog_cat.xlsx")

```

Im vorherigen Kapitel haben wir die Datentabelle @tbl-dog-cat-long erschaffen. Bevor wir uns weiter mit statistischen Kennzahlen beschäftigen, wollen wir uns einmal die Realisierung der Tabelle @tbl-dog-cat-long in R anschauen. Dabei wollen wir auch Eigenschaften von Zahlen und Buchstaben lernen, die notwendig sind um mit einem Programm wie R kommunizieren zu können. Nun haben wir Tabelle @tbl-dog-cat-long mit Daten zu verschiedenen Oucomes, wie Sprungweite \[cm\], Anzahl an Flöhen auf Hunden und Katzen, die Boniturnoten oder aber den Infektionsstatus. Die Tabelle @tbl-dog-cat-long ist zwar nicht groß aber auch nicht wirklich klein. Wir wollen uns nun damit beschäftigen, die Zahlen sinnvoll in R darzustellen.

```{r dog-cat-long, echo = FALSE}
#| tbl-cap: Sprunglängen [cm] für Hunde- und Katzenflöhe. Die Tabelle ist im *Long*-Format dargestellt.

data_tbl %>%
  kable(align = "c", "pipe")


data_tbl <- data_tbl %>%
  mutate(flea_count = as.integer(flea_count),
         infected = as.logical(infected))

```

## Daten in R sind `tibble()`

Im folgenden sehen wir die Datentabelle @tbl-dog-cat-long in R als `tibble` dargestellt. Was ist nun ein `tibble`? Ein `tibble` ist zu aller erst ein Speicher für Daten in R. Das heist wir haben Spalten und Zeilen. Jede Spalte repräsentiert eine Messung oder Variable und die Zeilen jeweils eine Beobachtung.

```{r echo = FALSE}
data_tbl 
```

Als erstes erfahren wir, dass wir einen `A tibble: 14 x 5` vorliegen haben. Das heist, wir haben 14 Zeile und 5 Spalten. In einem `tibble` wird immer in der ersten Zeile angezeigt wieviele Beobachtungen wir in dem Datensatz haben. Wenn das `tibble` zu groß wird, werden wir nicht mehr das ganze `tibble` sehen sondern nur noch einen Ausschnitt. Im Weiteren hat jede Spalte noch eine Eigenschaft unter dem Spaltennamen

-   `<chr>` bedeutet `character`. Wir haben also hier Worte vorliegen.
-   `<dbl>` bedeutet `double`. Ein `double` ist eine Zahl mit Kommastellen.
-   `<int>` bedeutet `integer`. Ein `integer` ist eine ganze Zahl ohne Kommastellen.
-   `<lgl>` bedeutet `logical` oder `boolean`. Hier gibt es nur die Ausprägung *wahr* oder *falsch*. Somit `TRUE` oder `FALSE`. Statt den Worten `TRUE` oder `FALSE` kann hier auch 0 oder 1 stehen.
-   `<str>` bedeutet `string` der aus verschiedenen `character` besteht kann, getrennt durch Leerzeichen.

::: {.callout-note appearance="simple"}
This book was originally created using [bookdown](https://bookdown.org) and published at <https://rstudio-education.github.io/hopr/>. This site is a port of the original book source to the [Quarto](https://quarto.org) publishing system in order to provide an example of it's use.
:::

## Faktoren als Wörter zu Zahlen

Ein Computer und somit auch eine Programmsprache wie R kann keine Buchstaben **verrechnen**. Ein Programm kann nur mit Zahlen rechnen. Wir haben aber in der Datentabelle @tbl-dog-cat-long in der Spalte `animal` Buchstaben stehen. Da wir hier einen Kompromiss eingehen müssen führen wir Faktoren ein. Ein Faktor kombiniert Buchstaben mit Zahlen. Wir als Anwender sehen die Buchstaben, die Wörter bilden. Intern steht aber jedes Wort für eine Zahl, so dass R mit den Zahlen rechnen kann. Klingt ein wenig kryptisch, aber wir schauen uns einen `factor` einmal an.

```{r }

as_factor(data_tbl$animal[1:8])

```

Mit dem `$` Zeichen können wir uns eine einzelne Zeile aus dem Datensatz `data_tbl` rausziehen. Du kannst dir das `$` wie einen Kleiderbügel und das `data_tbl` als einen Schrank für Kleiderbügel verstellen. An dem Kleiderbügel hängen dann die einzelnen Zahlen und Worte. Im Weiteren nehmen wir nicht den ganzen Vektor `animal` mit vierzehn Einträgen sondern nur die ersten acht. Das machen wir mit `[1-8]` hinter dem `animal`. Schauen wir auf das Ergebnis, so erhalten wir sieben Mal `dog` und einmal `cat`. Insgesamt die ersten acht Einträge der Datentabelle. Darüber hinaus sehen wir auch, dass die der Faktor jetzt `Levels` hat. Exakt zwei Stück. Jeweils einen für `dog` und einen für `cat`.

```{r }
animal <- c("dog", "dog", "dog", "cat", "cat", "cat")

as.factor(animal)

factor(animal, levels = c("dog", "cat"))

factor(animal, labels = c("katze", "hund"))

as_factor(animal)


dose <- c("low", "low", "mid", "mid", "high", "high")

as.factor(dose)

factor(dose, levels = c("low", "mid", "high"))



```

## Der Zuweisungspfeil `<-`

Mit dem Zuweisungspfeil speichern wir *Dinge* in Objekte in R. Das heist wir speichern damit intern in R Datensätze und viele andere Sachen, die wir dan später wieder verwenden wollen. Schauen wir uns das einmal im Beispiel an. Schrieben wir nur den Vektor `c()` mit Hunden und Katzen darin, so erscheint eine Ausgabe in R.

```{r}
c("dog", "dog", "cat", "cat", "fox", "fox")
```

Schreiben wir den gleichen Vektor und nutzen den Zuweisungspfeil, dann wird der Vektor in dem Objekt `animal` gespeichert.

```{r}
animal <- c("dog", "dog", "cat", "cat", "fox", "fox")
```

Wie kommen wir jetzt an die Sachen, die in `animal` drin sind? Wir können einfach `animal` in R schreiben und dann wird uns der Inhalt von `animal` ausgegeben.

```{r}
animal
```

## Von Wörtern und Objekten

Das mag etwas verwirrend sein, denn es gibt in R Wörter `string <str>` oder `character <chr>`. Wörter sind was anderes als Objekte. Streng genommen sind beides Wörter, aber in Objekten werden Dinge gespeichert wohin gegen das Wort einfach ein Wort ist. Deshalb kennezeichnen wir Wörter auch mit `"wort"` und zeigen damit, dass es sich hier um einen String handelt.

### Ein `string <str>` oder `character <chr>`

Wir tippen `"animal"` in R und erhalten `"animal"` zurück.

```{r}
"animal"
```

### Ein Objekt

Wir tippen `animal` ohne die Anführungszeichen in R und erhalten den Inhalt von `animal` ausgegeben.

```{r}
animal
```

Sollte es das Objekt `animal` nicht geben, also nicht über den Zuweisungspfeil `<-` erschaffen worden, dann wird eine Fehlermeldung von R ausgegeben:

`Fehler in eval(expr, envir, enclos) : Objekt 'animal' nicht gefunden`

## Die Pipe `%>%`

Im Weiteren nutzen wir den Pipe Operator dargestellt als `%\>%`. Du kannst dir den Pipe Operator als eine Art Röhre vorstellen in dem die Daten verändert werden und dann an die nächste Funktion weitergeleitet werden. Nehmen wir nochmal das Beispiel von weiter oben. Wir wollen die `character` Spalte aus dem Datensatz `data_tbl` extrahieren und dann in einen Faktor umwandeln.

```{r}
as_factor(data_tbl$animal[1:5])

data_tbl %>% 
  pull(animal) %>% 
  extract(1:5)

```

Zuerst siehst du das alte Beispiel und dann die Nutzung des Pipe Operators `%>%`. Das Ergebnis ist das gleiche, aber der Code ist einfacher zu lesen. Wir nehmen den Datensatz `data_tbl` leiten den Datensatz in den Funktion `pull()` und ziehen uns damit den Vektor `animal` aus dem Datensatz. Den Vektor leiten wir dann weiter in die Funktion `extract()` und nehmen nur die ersten 5 Werte aus dem Vektor.

## Daten bearbeiten

Im folgenden wollen wir den Datensatz `data_tbl` in R bearbeiten. Das heist wir wollen Spalten auswählen mit `select()` oder Zeilen auswählen mit `filter()`. Schlussendlich wollen wir auch die Eigenschaften von Spalten mit der Funktion `mutate` ändern

### Spalten wählen mit `select()`

<https://dplyr.tidyverse.org/reference/select.html>

```{r}
data_tbl %>% 
  select(animal, jump_length, flea_count)
```

### Zeilen wählen mit `filter()`

<https://dplyr.tidyverse.org/reference/filter.html>

```{r}
data_tbl %>% 
  filter(animal %in% c("dog"))
```

```{r}
data_tbl %>% 
  filter(flea_count > 15)
```

```{r}
data_tbl %>% 
  filter(infected == TRUE)
```

### Spalten ändern mit `mutate()`

<https://dplyr.tidyverse.org/reference/mutate.html>

```{r}
data_tbl %>% 
  mutate(animal = as_factor(animal))
```

```{r}
data_tbl %>% 
  mutate(long_jump = if_else(jump_length > 7, TRUE, FALSE)) %>% 
  select(animal, jump_length, long_jump)
```

::: callout-note
## Die Funktionen select(), filter() und mutate() in R

Bitte schaue dir auch die Hilfeseiten der Funktionen an. In diesem Skript kann ich nicht alle Funktionalitäten der Funktionen zeigen. Oder du kommst in das R Tutorium welches ich anbiete und fragst dort nach den Möglichkeiten Daten in R zu verändern.
:::

## Mehr Informationen durch `glimpse()` und `str()`

```{r}
glimpse(data_tbl)
str(data_tbl)
```

## Pakete und `library()`

In der Vanilla[^programing-letters-numbers-1] Variante hat R sehr wenige Funktionen. Ohne zusätzliche Pakete ist R mehr ein sehr potenter Taschenrechner. Leider mit der Funktionalität aus den 90'zigern, was die Programmierumgebeung und die Funktionen angeht. Das wollen wir aber nicht. Wir wollen auf den aktuellen Stand der Technik und auch Sprache programmieren. Daher nutzen wir zusätzliche R Pakete.

[^programing-letters-numbers-1]: Als Vanilla beschreibt man in der Informatikerwelt ein Programm, was keine zusätzlichen Pakete geladen hat. Also die reinst Form ohne zusätzlichen Geschmack.

![Auf den Reiter *Packages* klicken und dann *Install*. In der deutschen version vom RStudio mögen die Begriffe leicht anders sein.](images/programing_01.PNG){#fig-pro-01 fig-align="center" width="300"}

In @fig-pro-01 wird gezeigt wie du ein zusätzliches Paket installieren kannst. Hierbei ist nochmal wichtig den semantischen Unterschied zu wissen. Es gibt das Paket `tidyverse` was wir viel nutzen. Wir isnatllieren *einmalig* Pakete der Funktion `install.packages()` oder eben wie in @fig-pro-01 gezeigt. Wir nutzen die Funktion `library()` um ein Paket in R zu laden. Ja, es müsste anders heisen, tut es aber nicht.

```{r}
#| eval: false

## Das Paket tidyverse installieren - einmalig
install.packages(tidyverse)

## Das Paket tidyverse laden - jedes Mal
library(tidyverse)
```

Nun muss man sich immer merken, ob das Paket schon installiert ist oder man schreibt relativ viele `library()` untereinander. Das passiert schnell, wenn du viele Pakete laden willst. Dafür erlaubt dir das Paket `pacman` eine Vereinfachung. Die Funktion `p_load()` installiert Pakete, wenn die Pakete nicht installiert sind. Sollten die Pakete installiert sein, so werden die Pakete geladen. Du musst nur einmal `install.packages(pacman)` ausführen um das Paket `pacman` zu installieren.

```{r}
#| eval: false

pacman::p_load(tidyverse, magrittr, readxl)
```

Schlussendlich gibt es noch die Möglichkeit sich alles nochmal bei YoTube anzuschauen.

::: callout-tip
## Unterschied von Packages und Libraries in R

Du findest auf YouTube [Einführung in R - Teil 03 - Unterschied Packages und Libraries in R](https://youtu.be/TWimhd3ZyMM) als Video. Hier erkläre ich nochmal den Ablauf zwischen Installieren eines Paketes und dem Laden eines Paketes.
:::
