# Reguläre Ausdrücke {#sec-regular-expr}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

Hier kommen wir jetzt zu einem speziellen Fall von Zeichen nämlich den Buchstaben oder `character` sowie den Wörtern oder `string`. Wörter kommen in R dann meist ja doppelt vor. Zum einen als Namen für Objekte oder aber als Bezeichnungen von Faktoren. Wir haben aber auch Spaltennamen oder aber unvollständige Einträge in Spalten. Am Ende gibt es noch das Datum oder die Zeit als Eingabe, die wollen wir uns dann auch nochmal am Ende anschauen. So häufig wirst du nicht mit Strings und Co. arbeiten, denn meist sind die Datensätze klein genug, dass du dir deine Daten dann sauber in Excel zusammenbauen kannst. Wenn die Daten aber großer werden, dann müssen wir mit besseren Tools ran. Und eins dieser Tools sind dann reguläre Ausdrück (eng. *regular expression*, abk. *RegExp* oder *Regex*). Ich nutze vieles von diesen Funktionen in dem Kapitel dann in der Anwendung. Deshalb ist dieses Kapitel auch so ein wenig für mich um meine Funktionen, die ich immer wieder nutze, parat zu haben.

::: column-margin
Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. -- Jamie Zawinski
:::

Wir brauchen nicht viele R Pakete in diesem Kapitel, aber ein paar sind es schon. Der Großteil der Funktionen steckt dann im R Paket `stingr` und das verbirgt sich dann in `tidyverse`.

```{r}
#| warning: false
#| echo: true

pacman::p_load(tidyverse, readxl, magrittr,
               conflicted)
conflict_prefer("extract", "magrittr")
```

In diesem kurzem Kapitel nutzen wir den Datensatz zu den Hunde-, Katzen- und Fuchsflöhen. Wir wollen uns aber auf die Spaltennamen konzentrieren, deshalb brauchen wir nur die ersten drei Zeilen des Datensatzes. Sonst bauen wir uns die Daten oder Vektoren einfach selber, denn hier geht es ja nur um das schnelle Zeigen und nicht um die direkte sinnvolle Anwendung.

```{r}
#| warning: false

data_tbl <- read_excel("data/flea_dog_cat_fox.xlsx") %>% 
  extract(1:3,)
```

Wir nehmen jetzt diesen Datensatz und schauen uns das R Paket `stringr` näher an. Danach werden wir dann die Sache nochmal von der Seite der regulären Ausdrück betrachten.

## Das R Paket `stringr` {#sec-stringr}

Das R Paket [`stringr`](https://stringr.tidyverse.org/) und das [Cheat Sheet zu `stringr`](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf) geben eine große Übersicht über die Möglichkeiten ein `character` zu bearbeiten. Im Folgenden schauen wir uns einmal einen simplen Datensatz an. Wir wollen auf dem Datensatz ein paar Funktionen aus dem R Paket `stringr` anwenden.

```{r}
regex_tbl <- tibble(animal = c("cat", "cat", "dog", "bird"),
                    site = c("village", "village", "town", "cities"),
                    time = c("t1_1", "t2_2", "t3_3", "t3_5"))
```

Die einfachste und am meisten genutzte Funktion ist `str_c()`. Die Funktion `str_c()` klebt verschiedene Vektoren zusammen. Wir können auch Zeichen wählen, wie das `-`, um die Vektoren zu verbinden. Wir bauen uns also eine neue Spalte `animal_site` in dem wir die Spalten `animal` und `site` mit einem `-` verbinden. Wir können statt dem `-` auch ein beliebiges anderes Zeichen oder auch Wort nehmen.

```{r}
regex_tbl %>% 
  mutate(animal_site = str_c(animal, "-", site))
```

Häufig brauchen wir auch eine ID Variable, die exakt $n$ Zeichen lang ist. Hier können wir die Funktion `str_pad()` nutzen um Worte auf die Zeichenlänge `width =` zu verlängern. Wir können auch das Zeichen wählen, was angeklebt wird und die Seite des Wortes wählen an die wir kleben wollen. Wir verlängern also links die Spalte site auf ein Wort mit acht Zeichen und als Füllzeichen nehmen wir die Null.

```{r}
regex_tbl %>% 
  mutate(village_pad = str_pad(site, pad = "0", 
                               width = 8, side = "left"))
```

Abschließend können wir auch eine Spalte in zwei Spalten aufteilen. Dafür müssen wir den Separator wählen nachdem die Spalte aufgetrennt werden soll. Wir können eine Spalte auch in mehrere Spalten aufteilen, wenn der Separator eben an zwei oder mehr Stellen steht. Wir haben die Spalte `time` und trennen die Spalte `time` an der Stelle `_` in zwei Spalten auf.

```{r}
regex_tbl %>% 
  separate(time, into = c("time", "rep"), 
           sep = "_", convert = TRUE)
```

Es gibt noch sehr viel mehr Möglichkeiten einen `character` Vektor zu bearbeiten. Teilweise nutze ich `stringr` bei der [Auswertung von den Beispielen](#sec-beispiel-auswertung) im Anhang. Schau dir da mal um, dort wirst du immer mal wieder die Funktionen aus dem Paket finden.

## Regular expressions {#sec-regex}

Ein regulärer Ausdruck (eng. *regular expression*, abk. *RegExp* oder *Regex*) ist eine verworrene Zeichenkette, die einer Maschine ein Muster übersetzt. Dieses Muster soll dann auch alle Wörter angewendet werden. Das klingt kryptisch und ist es auch. Reguläre Ausdrücke sind das Nerdthema schlechthin in der Programmierung. Also tauchen wir mal ab in die Welt der seht nützlichen und mächtigen regulären Ausdrücke.

::: column-margin
Wir immer gibt es schöne Tutorials. Einmal [Regular expressions in stingr](https://stringr.tidyverse.org/articles/regular-expressions.html) und dann von Hadley Wickham ein Kapitel zu [Regular expressions](https://r4ds.had.co.nz/strings.html).
:::

Fangen wir mit der grundsätzlichen Idee an. Reguläre Ausdrücke finden bestimmte Zeichen in Wörtern. Ich habe dir hier einmal eine winzige Auswahl an regulären Ausdrücken mitgebracht. Du kannst auch reguläre Ausdrück miteinander verknüpfen. Daher kommt die eigentlich Macht eines regulären Ausdruck. Aber später mehr dazu.

-   `\d`: entspricht einer beliebigen Ziffer. Wir finden also eine Ziffer oder Zahl in einem Wort.
-   `\s`: entspricht einem beliebigen Leerzeichen (z. B. Leerzeichen, Tabulator, Zeilenumbruch). Wir finden also ein Leerzeichen in einem String.
-   `[abc]`: passt auf a, b oder c. Das ist jetzt wörtlich gemeint. Wir finden die Buchstaben a, b oder c.
-   `[^abc]`: passt auf alles außer a, b oder c. Das ist jetzt ebenfalls wörtlich gemeint.

Denk daran, dass du, um einen regulären Ausdruck zu erstellen, der `\d` oder `\s` enthält, das `\` für die Zeichenkette ausschließen musst, also gib `\\d` oder `\\s` ein. Das ist eien Besonderheit in R. Wir müssen in R immer ein doppeltes `\\` schreiben.

Es gibt eine große Auswahl an möglichen regulären Ausdrücken. Ich nutze meist dann noch ein Cheat Sheet um den Überblick zu bewahren. Aber wie schon oben geschrieben, reguläre Ausdrücke braucht man meist erst, wenn die Daten so große werden, dass wir die Daten nicht mehr händisch bearbeiten können.

::: column-margin
Ich selber nutze immer das [Regular Expressions Cheat Sheet by DaveChild](https://cheatography.com/davechild/cheat-sheets/regular-expressions/) um den Überblick zu bewahren. Es ist dann auch einfach zu viel zu merken.
:::

Wir können wieder das R Paket `stringr` nutzen um die regulären Ausdrück in R anzuwenden. Beginnen wir erstmal mit den einfachen Funktionen und arbeiten uns dann vor. Bitte beachte auch, dass du in der [Funktion `select()` auch Helferfunktionen nutzen kannst](https://tidyselect.r-lib.org/reference/language.html), die dir das Leben wirklich einfacher machen. Auf diese Helferfunktionen gehen wir später nochmal ein.

-   `str_detect()` gibt `TRUE/FALSE` wieder, wenn das Wort eine Zeichenkette enthält.
-   `str_subset()` gibt die Werte wieder in denen die Zeichenkette erkannt wird.
-   `str_replace` ersetzt das erste Auftreten der Zeichenkette durch eine andere Zeichenkette.

Fangen wir simple an, wir wollen Wörter finden, die eine Zeichenkette enthalten. Dafür nutzen wir die Funktion `str_detect()`.

```{r}
c("dog", "small-dog", "doggy", "cat", "kitty") %>% 
  str_detect("dog")
```

Okay, das hat ja schon mal gut funktioniert. Wenn wir die Worte wiederhaben wollen, dann können wir auch die Funktion `str_subset()` nutzen. Wir wollen jetzt aber nur die Einträge, die mit der Zeichenkette `dog` anfangen. Deshalb schreiben wir ein `^` vor die Zeichenkette. Wenn wir nur die Einträge gewollt hätten, die mit `dog` enden, dann hätten wir `dog$` geschrieben. Das `$` schaut dann von hinten in die Wörter.

```{r}
c("dog", "small-dog", "doggy", "cat", "kitty") %>% 
  str_subset("^dog")
```

Nun haben wir uns verschrieben und wollen das `small` entfernen und mit `large` ersetzen. Statt `large` hätten wir auch nichts `""` hinschreiben können. Dafür können wir die Funktion `str_replace()` nutzen. Die Funktion entfernt das *erste* Auftreten einer Zeichenkette. Wenn du alle Zeichenketten entfernen willst, dann musst du die Funktion `str_replace_all()` verwenden.

```{r}
c("dog", "small-dog", "doggy", "cat", "kitty") %>% 
  str_replace("small", "large")
```

Damit haben wir die wichtigsten drei Funktionen einmal erklärt. Wir werden dann diese Funktionen immer mal wieder anwenden und dann kannst du sehen, wie die regulären Ausdrücke in den Funktionen funktionieren. Auf der Hilfeseite von `stringr` gibt es nochmal ein Tutorium zu [Regular expressions](https://stringr.tidyverse.org/articles/regular-expressions.html), wenn du hier mehr erfahren möchtest.

Viel häufiger nutzen wir die Helferfunktionen in `select()`. Wir haben hier eine große Auswahl, die uns das selektieren von Spalten sehr erleichtert. Im Folgenden einmal die Liste alle möglichen Funktionen. Beachte auch dabei folgende weitere Funktionen im [Overview of selection features](https://tidyselect.r-lib.org/reference/language.html).

-   `matches()`, wählt alle Spalten die eine Zeichenkette enthalten. Hier können wir reguläre Ausdrücke verwenden.
-   `all_of()`, ist für die strenge Auswahl. Wenn eine der Variablen im Zeichenvektor fehlt, wird ein Fehler ausgegeben.
-   `any_of()`, prüft nicht auf fehlende Variablen. Dies ist besonders nützlich bei der negativen Selektionen, wenn du sicherstellen möchtest, dass eine Variable entfernt wird.
-   `contains()`, wählt alle Spalten die eine Zeichenkette enthalten. Funktioniert *nicht* mit regulären Ausdrücken.
-   `starts_with()`, wählt alle Spalten die mit einer Zeichenkette beginnt. Funktioniert *nicht* mit regulären Ausdrücken.
-   `ends_with()`, wählt alle Spalten die mit einer Zeichenkette endet. Funktioniert *nicht* mit regulären Ausdrücken.
-   `everything()`, sortiert die restlichen Spalten hinten an. Wir können uns also die wichtigen Spalten namentlich nach vorne holen und dann den Rest mit `everything()` hinten an kleben.
-   `last_col()`, wählt die letzte Spalte aus. Besonders wichtig, wenn wir von einer Spalte *bis zur letzten Spalte* auswählen wollen.
-   `num_range()`, können wir nutzen, wenn wir über eine Zahl eine Spalte wählen wollen. Das heißt, unsere Spalten haben Zahlen in den Namen und wir könne darüber dann die Spalten wählen.

Hier einmal das Beispiel mit `matches()` wo wir alle Spalten nehmen in denen ein `_` als Unterstrich vorkommt.

```{r}
data_tbl %>% 
  select(matches("_"))
```

Wir können auch über einen Vektor die Spalten auswählen. Das ist meistens nötig, wenn wir die Namen der Spalten zum Beispiel aus einer anderen Funktion erhalten. Dafür können wir dann die Funktion `one_of()` nutzen.

```{r}
data_tbl %>% 
  select(one_of("animal", "grade"))
```

Es gibt noch eine Menge anderer [Tools zum Nutzen von Regulären Ausdrücken](https://r4ds.had.co.nz/strings.html#tools). Aber hier soll es erstmal reichen. Wir gehen dann später in der Anwendung immer mal wieder auf die Funktionen hier ein.

## Zeit und Datum {#sec-time-date}

![](images/caution.png){fig-align="center" width="50%"}

Die Arbeit mit Datumsdaten in R kann frustrierend sein. Die R Befehle für Datumszeiten sind im Allgemeinen nicht intuitiv und ändern sich je nach Art des verwendeten Datumsobjekts. Hier gibt es aber eine Lösung mit dem R Paket `lubridate`, die uns die Arbeit etwas erleichtert.

::: column-margin
[R lubridate - Make Dealing with Dates a Little Easier](https://lubridate.tidyverse.org/)
:::
