```{r echo = FALSE}
pacman::p_load(tidyverse, readxl, knitr, kableExtra, Hmisc,
               grid, agricolae, patchwork, desplot, modelr, see)
```

# Fortgeschrittene Designs {#sec-experimental-design-advanced}

*Version vom `r format(Sys.time(), '%B %d, %Y um %H:%M:%S')`*

![](images/caution.png){fig-align="center" width="50%"}

::: callout-important
## Auf ein Wort zum Umfang des Kapitels

Ich werde mich in diesem Kapitel für das Erste auf die wichtigen experimentellen Design beschränken. Wenn sich aus deer Lehre oder Beratungstätigkeit noch Bedarf an weiteren experimentellen Designs ergibt, werde ich die Designs entsprechend ergänzen. Insbesondere hier gilt, dass [DSFAIR](https://schmidtpaul.github.io/DSFAIR/DesigningExperiments.html) einen sehr umfangreichen Überblick liefert.

**Wenn dir ein experimentelles Design fehlt, dann schreibe mir gerne eine Mail und ich schaue, dass ich das experimentelle Design ergänze.**

Siehe dazu auch das Inhaltsverzeichnis von dem R Paket `agricolae` mit [Experimental Designs with agricolae](https://myaseen208.com/agricolae/articles/ExperimentalDesign.html) einmal genauer an. Auch ist es sehr hilfreich sich Datenbeispiele auf [agridat - Datensätze mit Abbildungen in `desplot`](https://kwstat.github.io/agridat/reference/index.html) anzuschauen.
:::

In diesem Kapitel wollen wir uns mit der Erstellung von komplexeren experimentellen Designs beschäftigen.

-   [Randomized complete block design (RCBD, 3-faktoriell)](#sec-rcbd-3fac)
-   [Split plot design (3-faktoriell) oder Spaltanlage](#sec-split)
-   [Subsampling](#sec-subsampling)
-   [Incomplete block design (3-faktoriell und 2-faktoriell)](#sec-incomplete)
-   [Strip plot design (3-faktoriell) oder Streifenanlage](#sec-strip-plot)

Dabei ist zu Bedenkne, dass diese Designs sehr viel Aufwand in der Anlegen der Anlage sowie der praktischen Auswertung auf dem Feld bedürfen. Hier musst du dich dann nochmal beraten lassen, bevor du mit einem Experiment startest. Wir schauen uns jetzt aber erstmal einen Überblick über die gängigsten komplexeren experimentellen Designs an.

In der @fig-exp-adv-1 sehen wir einmal die Übersicht über die drei häufigsten komplexeren experimentellen Designs mit dem RCBD (3-faktoriell), dem Split plot Design (3-faktoriell) sowie dem Subsampling eines RCBD (2-faktoriell). Die drei experimentellen Designs werden immer mal wieder etwas durcheinander gewirbelt. Du kannst dir im Prinzip die Sachlage wie folgt vorstellen. Im RCBD (3-faktoriell) werden die beiden Behandlungsfaktoren über die Blöcke randomsiert. Die beiden Behandlungen sind vollkommen durcheinander in der @fig-exp-adv-1-1. Im Fall eines Split plot Design (3-faktoriell) wird eine Behandlung innerhalb der anderen Behandlung über die Blöcke randomisiert. Wir haben also eine Spaltanlage vorliegen, da wir immer eine Behandlung in einer Spalte randomisieren. Das ist schon in der @fig-exp-adv-1-2 zu sehen. Die Farben bilden die zweite Behandlung ab. Innerhalb einer Spalte ist dann die erste Behandlung randomisiert. Das Subsampling nimmt jetzt eine Behandlung raus. Wir haben dann nur noch eine Behandlung als Faktor, die wir in den Blöcken randomisieren. Die Idee des Subsamplings ist nun, dass wir wiederholt Pflanzen innerhalb der Behandlung messen. Wir mitteln jetzt aber nicht über die Pflanzen in einem Block sondern nehmen alle Pflanzen mit in die statistische Auswertung. Das ist eigentlich die zentrale Idee des Subsamplings, wie wir das machen, ist dann die andere Frage. In der @fig-exp-adv-1-3 sehen wir schön wie sich die Pflanzen-ID's über das Feld verteilen. Die Farben stellen die vier Behandlungslevel dar.

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-1
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "Vergleich der drei häufigsten komplexeren experimentellen Designs mit dem RCBD (3-faktoriell), dem Split plot Design (3-faktoriell) sowie dem Subsampling eines RCBD (2-faktoriell). Die Zahlen bei dem Subsampling stellt die ID's der individuellen Beobachtungen dar."
#| fig-subcap: 
#|   - "Sechs Eisendüngerbehandlung (Text: fe_1 bis fe_6) sowie vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) in vier Blöcken."
#|   - "Sechs Eisendüngerbehandlung (Text: fe_1 bis fe_6) sowie vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) in vier Blöcken."
#|   - "Vier Bodenbehandlung (Farbe: schwarz, rot, orange, grün) mit den individuellen Beobachtungen in vier Blöcken."
#| layout-nrow: 1
#| column: page


trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4

## rcbd
fac2rcbd_out <- design.ab(trt = c(n_trt_fac2_fert, n_trt_fac1_soil), 
                          design = "rcbd",
                          r = n_block, 
                          seed = 42)

fac2rcbd_out$bookRowCol <- fac2rcbd_out$book %>%
  bind_cols(expand.grid(rows = 1:n_trt_fac2_fert,
                        cols = 1:(n_trt_fac1_soil*n_block))) %>% 
  mutate(trt_fac2_fert = paste0("fe_", A),
         trt_fac1_soil = paste0("soil_", B),
         block = paste0("Block ", block))

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = trt_fac2_fert, cex = 1, shorten = "no", col=trt_fac1_soil,
        data = fac2rcbd_out$bookRowCol,
        main = "Randomized complete block design (3-faktoriell)", 
        show.key = FALSE, key.cex = 0.5)

## split plot
splitplot_out <- design.split(trt1 = trt_fac1_soil,
                              trt2 = trt_fac2_fert,
                              r = n_block,
                              seed = 42)


splitplot_out$bookRowCol <- splitplot_out$book %>% 
  mutate(block = paste0("Block ", block),
         cols = plots %>% str_sub(2,3) %>% as.integer,
         rows = splots %>% as.integer)

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = trt_fac2_fert, cex = 1, shorten = "no", col=trt_fac1_soil,
        data = splitplot_out$bookRowCol ,
        main = "Split plot design (3-faktoriell)",
        show.key = FALSE, key.cex = 0.5)

## subsampling

rcbd_long_tbl <- expand_grid(block = 1:4, 
                             trt = 1:4,
                             rep = 1:6) %>% 
  mutate(trt = factor(trt, labels = trt_fac1_soil),
         block = factor(block, labels = str_c("Block ", 1:4)),
         pid = 1:n(),
         pid_text = str_pad(1:96, width = 2, pad = "0")) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) 

rcbd_plot_tbl <- rcbd_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))

desplot(data = rcbd_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell)", 
        text = pid_text, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 



```

## Genutzte R Pakete

Wir wollen folgende R Pakete in diesem Kapitel nutzen.

```{r echo = TRUE}
#| message: false
pacman::p_load(tidyverse, magrittr, agricolae, dae, desplot,
               conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("set_names", "magrittr")
cbbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Am Ende des Kapitels findest du nochmal den gesamten R Code in einem Rutsch zum selber durchführen oder aber kopieren.

## Randomized complete block design (RCBD, 3-faktoriell) {#sec-rcbd-3fac}

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

::: callout-tip
## Modell zur Auswertung

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ soil + fert + soil:fert + block +, data = rcbd_3f_tbl)
```
:::

### ... mit `expand_grid()`

```{r}
three_fct_long_tbl <- expand_grid(block = 1:2, soil = 1:4, fert = 1:6) %>% 
  mutate(block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4)),
         fert = factor(fert, label = str_c("fe_", 1:6))) %>% 
  group_by(block) %>% 
  mutate(fert = sample(fert),
         soil = sample(soil))

three_fct_long_tbl
```

```{r}
three_fct_plot_tbl <- three_fct_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, cols = 1:4, rows = 1:6))
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-6
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: "foo."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = three_fct_plot_tbl ,
        main = "Randomized complete block design (3-faktoriell)",
        show.key = FALSE)
```

```{r}
#| eval: false
#| message: false
#| warning: false
three_fct_plot_tbl %>% 
  select(-rep) %>% 
  write_xlsx("template_sheet.xlsx")
```

### ... mit `agricolae`

```{r}
trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4
```

```{r}
rcbd_fac3_obj <- design.ab(trt = c(n_trt_fac2_fert, n_trt_fac1_soil), 
                           design = "rcbd",
                           r = n_block, 
                           seed = 42)
```

```{r}
rcbd_fac3_book_tbl <- rcbd_fac3_obj$book %>%
  bind_cols(expand.grid(rows = 1:n_trt_fac2_fert,
                        cols = 1:(n_trt_fac1_soil*n_block))) %>% 
  mutate(trt_fac2_fert = str_c("fe_", A),
         trt_fac1_soil = str_c("soil_", B),
         block = paste0("Block ", block)) %>% 
  select(block, fert = trt_fac2_fert, soil = trt_fac1_soil, rows, cols)
```

Kein `sketch`, wenn man ihn braucht.

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-2
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "foo."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = rcbd_fac3_book_tbl,
        main = "Randomized complete block design (3-faktoriell)", 
        show.key = FALSE, key.cex = 0.5)
```

## Split plot design (3-faktoriell) {#sec-split}

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

::: callout-tip
## Modell zur Auswertung

Bei viel Fallzahl

```{r}
#| eval: FALSE
fit <-  lmer(yield ~ soil + fert + soil:fert + (1|block) + (1|block:fert) + (1|block:soil), data = split_tbl)
```

Bei weniger Fallzahl

```{r}
#| eval: FALSE
fit <-  lmer(yield ~ soil + fert + soil:fert + (1|block), data = split_tbl)
```
:::

### ... mit `expand_grid()`

```{r}
splitplot_long_tbl <- expand_grid(block = 1:2, soil = 1:4, fert = 1:6) %>% 
  mutate(block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4)),
         fert = factor(fert, label = str_c("fe_", 1:6))) %>% 
  group_by(block, soil) %>% 
  mutate(fert = sample(fert))

splitplot_long_tbl
```

```{r}
splitplot_plot_tbl <- splitplot_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, cols = 1:4, rows = 1:6))
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-5
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: "foo."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = splitplot_plot_tbl ,
        main = "Split plot design (3-faktoriell)",
        show.key = FALSE)
```

### ... mit `agricolae`

```{r}
trt_fac1_soil <- str_c("soil_", 1:4)    
n_trt_fac1_soil <- n_distinct(trt_fac1_soil) 
trt_fac2_fert <- str_c("fe_", 1:6)  
n_trt_fac2_fert <- n_distinct(trt_fac2_fert) 
n_block <- 4
```

Achtung, unbedingt `serie = 0` als Option nutzen, sonst klappt es nicht mit der Option die `plots` gleich den Spalten `cols` zu setzen. Ja, ich weiß, ist alles super suboptimal.

```{r}
splitplot_obj <- design.split(trt1 = trt_fac1_soil,
                              trt2 = trt_fac2_fert,
                              r = n_block,
                              seed = 42, serie = 0)
```

Leider gibt es kein `sketch`-Objekt gerade hier wo man eins gebrauchen könnte.

```{r}
splitsplot_book_tbl <- splitplot_obj$book %>% 
  mutate(block = paste0("Block ", block),
         cols = plots, 
         rows = as.numeric(splots)) %>% 
  select(block, fert = trt_fac2_fert, soil = trt_fac1_soil, rows, cols)
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-3
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "foo."
desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = splitsplot_book_tbl ,
        main = "Split plot design (3-faktoriell)",
        show.key = FALSE)
```

### ... mit `dae`

```{r}
oast_sys <- cbind(fac.gen(list(Blocks = 4, MPlots = 4, SubPlots = 6)),
                  fac.gen(list(soil = str_c("soil_", 1:4),
                               fert = str_c("fe_", 1:6)), times = 4)) 
```

```{r}
oats_lay <- designRandomize(allocated = oast_sys[c("soil", "fert")],
                            recipient = oast_sys[c("Blocks", "MPlots", "SubPlots")],
                            nested.recipients = list(MPlots = "Blocks",
                                                     SubPlots = c("MPlots", "Blocks")),
                            seed = 235805)

```

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-4
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "Vergleich der Darstellung eines Split plots Designs mit den jeweiligen Funktionen."
#| fig-subcap: 
#|   - "... mit `desplot()`"
#|   - "... mit `designGGplot()`."
#| layout-nrow: 1
#| column: page

desplot(Blocks ~ MPlots + SubPlots | Blocks, flip = TRUE,
        out1 = MPlots, out1.gpar = list(col = "grey", lty = 1),
        out2 = SubPlots, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = oats_lay ,
        main = "Split plot design (3-faktoriell)",
        show.key = FALSE)

designGGPlot(oats_lay, labels = "fert", cellalpha = 0.75, cellfillcolour.column = "soil",
             row.factors = c("Blocks", "SubPlots"), column.factors = c("MPlots"),
             blockdefinition = rbind(c(6, 1)),
             blocklinecolour = "black", title = NULL)


```

## Subsampling {#sec-subsampling}

Die zentrale Idee des Subsamplings ist, dass wir nicht über die Pflanzen in unseren Blöcken mitteln. Wir nehmen also alle Pflanzen in unserem Block mit in die Analyse. Oder aber wir mitteln nicht das Gewicht der Ferkel für jede Bucht, sondern wollen die Gewichte individuell mit betrachten. Wir messen die Beobachtungen innerhalb der Behandlung und nehmen diese individuellen Beobachtungen auch mit ins Modell. Damit haben wir eigentlich das gleiche Modell wie auch bei dem RCBD mit zwei Faktoren. Nur das wir eben in den Blöcken und Behandlungen nicht einen Mittelwert über alles haben, sondern eben sechs individuelle Werte für die sechs Beobachtungen in einer Behandlung/Block-Kombination in unserem Beispiel.

Das generelle Modell unterscheidet sich nicht von einem RCBD. Wir haben zwei Faktoren, einmal die Behandlung und einmal einen Block vorliegen.

$$
y \sim \overbrace{trt}^{f_1} + \underbrace{block}_{f_2} 
$$

Jetzt kommt es darauf an, wie die individuellen Pflanzen in den Behandlungen stehen. Eventuell ist alles durcheinander gemischt, das heißt, die Pflanzen sind in den Behandlungen und Blöcken randomisiert. Dann ist es recht einfach mit einem linearen Modell zu machen.

Wenn du aber die Pflanzen in einem Pflanztray oder irgendwie anders fixierst hast, dann macht es schon einen Unterschied. In dem Fall sind die Pflanzen ja individuell nicht unabhängig voneinander. Die Pflanzen sind ja in einem Tray zusammen. Dann nutzen wir ein lineares gemischtes Modell.

Im Folgenden generieren wir einmal beide Fälle, wobei der zweite Fall - Pflanzen stehen zusammen - als Subsampling angesehen wird. Häufig kann dies auch bei Tierversuchen passieren, wenn zum Beispiel Ferkel in einer Bucht in einem Stahl stehen. Da aber ab und zu beides vorkommt, hier dann einmal beides. Wir können das Subsampling nur selber mit `expand_grid()` durchführen, da weder das R Paket `agricolae` noch das R Paket `dae` eine entsprechende Implementierung der Funkationalität zur Generierung eines Datensatzes mit Subsampling aufweist.

::: callout-tip
## Modell zur Auswertung

Vollständig im Block randomisiert, wir rechnen ein lineares Modell.

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ fert + block + block:fert, data = subsampling_tbl)
```

Behandlung im Block randomisiert, dass heißt, dass die Pflanzen zusammen in einem Tray stehen, wir rechnen ein gemischtes Modell.

```{r}
#| eval: FALSE
fit <- lmer(drymatter ~ fert + block + (1 | block:fert), data = subsampling_tbl)
```
:::

Das Subsampling geht nur im Selbermachen, also machen wir das dann einmal mit der Funktion `expand_grid()`. Als erstes erstellen wir einmal ein Design mit vier Blöcken und vier Behandlungen. Dann ergänzen wir noch pro Behandlung sechs individuelle Beobachtungen. Am Ende randomisieren wir einmal über die Behandlungen in den Blöcken. Wichtig ist hier, dass wir die Daten nach den Blöcken gruppieren müssen und schon vorher alle individuellen Pflanzen generieren.

```{r}
subsampling_long_tbl <- expand_grid(block = 1:4, 
                                    trt = 1:4,
                                    rep = 1:6) %>% 
  mutate(trt = factor(trt, labels = trt_fac1_soil),
         block = factor(block, labels = str_c("Block ", 1:4)),
         pid = 1:n(),
         pid_text = str_pad(1:96, width = 2, pad = "0")) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) ## Randomisierung in den Blöcken
```

Dann bauen wir noch unser Grid auf. Wir wollen insgesamt sechzehn Spalten, dass sind die Blöcke/Behandlungs-Kombinationen. Dann brauchen wir noch jeweils sechs Zeilen für die individuellen Pflanzen. Dann können wir die Daten schon nehmen und in der @fig-exp-adv-10-1 visualisieren. Bevor wir die Abbildung besprechen, generieren wir uns nochmal die anderen Daten, wo die Behandlungen in den Blöcken randomisiert werden.

```{r}
subsampling_plot_tbl <- subsampling_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))
```

Eine andere Möglichkeit ist, dass unsere Pflanzen in einem Pflanztray stehen. Damit haben wir keine Randomisierung mehr in den Blöcken, sondern wir können nur unsere Behandlungen in den Blöcken randomisieren. Die Positionen in den Trays sind ja fix. Daher Randomisieren wir erst den Faktor der Behandlungen in den gruppierten Blöcken. Dann ergänzen wir noch die sechs individuellen Pflanzen.

```{r}

subsampling_tray_long_tbl <- expand_grid(block = 1:4, 
                                        trt = 1:4) %>% 
  mutate(trt = factor(trt, labels = trt_fac1_soil),
         block = factor(block, labels = str_c("Block ", 1:4))) %>% 
  group_by(block) %>% 
  mutate(trt = sample(trt)) %>% # Randomisierung der Behandlungen in den Blöcken
  expand_grid(rep = str_pad(1:6, width = 2, pad = "0"))

```

Jetzt bauen wir uns noch das Grid für die Positionen zusammen, da bleibt alles beim alten. Wir brauchen auch wieder sechzehn Spalten, dass sind die Blöcke/Behandlungs-Kombinationen. Dann noch die sechs Zeilen für das Pflanzentray. In der @fig-exp-adv-10-2 sehen wir einmal das Ergebnis der Randomisierung. Alle Pflanzen sind jetzt in einer Spalte randomisiert, die eben das Tray der Pflanzung entspricht.

```{r}
subsampling_tray_plot_tbl <- subsampling_tray_long_tbl %>% 
  bind_cols(expand_grid(cols = 1:16, rows = 1:6))
```

In der @fig-exp-adv-10 sehen wir nochmal die beiden Arten des Subsamplings miteinander vergleichen. In der @fig-exp-adv-10-1 sind alle Behandlungen mit ihren sechs Wiederholungen zufällig im Block verteilt. Im anderen Fall sehen wir in der @fig-exp-adv-10-2, wenn die Pfanzen zusammen in einem Tray stehen und alle die gleiche Behandlung kriegen. Es können aber auch Schweine in einer Bucht sein und die Blöcke sind dann die einzelnen Ställe.

```{r}
#| echo: false
#| warning: false
#| label: fig-exp-adv-10
#| fig-align: center
#| fig-height: 6
#| fig-width: 6
#| fig-cap: "Verschiedene Arten des Subsamplings. Einmal vollständig innerhalb der Blöcke randomsiert und einmal die Behandlung randomisiert."
#| fig-subcap: 
#|   - "... vollständig innerhalb Block randomisiert (`subsampling_plot_tbl`)."
#|   - "... Behandlungen innerhalb Block randomisiert (`subsampling_tray_plot_tbl`)."
#| layout-nrow: 1
#| column: page

desplot(data = subsampling_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell, vollständig randomisiert)", 
        text = pid_text, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 

desplot(data = subsampling_tray_plot_tbl, flip = TRUE, 
        form = block ~ cols + rows | block,
        out1 = trt, out1.gpar = list(col = "grey", lty = 1),
        #out2 = pid, out2.gpar = list(col = "grey", lty = 1),
        main = "Subsampling (2-faktoriell, Behandlung randomisiert)", 
        text = rep, 
        cex = 1, show.key = FALSE, shorten = "no", col = trt) 

```

## Incomplete block design {#sec-incomplete}

Einmal als 3-faktorielles Design

$$
y \sim \overbrace{soil}^{f_1} + \underbrace{fert}_{f_2} + \overbrace{block}^{f_3}
$$

Einmal als 2-faktorielles Design

$$
y \sim \overbrace{trt}^{f_1} + \underbrace{block}_{f_2} 
$$

::: callout-tip
## Modell zur Auswertung

```{r}
#| eval: FALSE
fit <- lm(drymatter ~ trt + cols + rows, data = lsd_tbl)
```
:::

### ... mit `expand_grid()` (3-faktoriell)

```{r}
incomplete_long_tbl <- expand_grid(block = 1:2, soil = 1:4, fert = 1:6) %>% 
  mutate(block = factor(block, labels = str_c("Block ", 1:2)),
         soil = factor(soil, labels = str_c("soil_", 1:4)),
         fert = factor(fert, label = str_c("fe_", 1:6))) %>% 
  group_by(block) %>% 
  mutate(fert = sample(fert),
         soil = sample(soil)) 

incomplete_long_tbl
```

```{r}
incomplete_plot_tbl <- incomplete_long_tbl %>% 
  bind_cols(expand_grid(rep = 1:2, cols = 1:4, rows = 1:6)) %>% 
  filter(rows <= 4)
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-7
#| fig-align: center
#| fig-height: 3
#| fig-width: 6
#| fig-cap: "foo."

desplot(block ~ cols + rows | block, flip = TRUE,
        out1 = rows, out1.gpar = list(col = "grey", lty = 1),
        out2 = cols, out2.gpar = list(col = "grey", lty = 1), 
        text = fert, cex = 1, shorten = "no", col = soil,
        data = incomplete_plot_tbl,
        main = "Incomplete block design (3-faktoriell)",
        show.key = FALSE)
```

```{r}
#| eval: false
#| message: false
#| warning: false
incomplete_plot_tbl %>% 
  select(-rep) %>% 
  write_xlsx("template_sheet.xlsx")
```

### ... mit `agricolae` (2-faktoriell)

```{r}
#| message: false
#| warning: false
bib_obj <- design.bib(trt = c("ctrl", "A", "B", "C"),
                      k = 3, seed = 543, serie = 2)
```

```{r}
bib_book_tbl <- bib_obj %>% 
  pluck("book") %>% 
  as_tibble() %>% 
  set_names(c("plots", "block", "trt"))
bib_book_tbl
```

```{r}
bib_plot_tbl <- bib_book_tbl %>%
  mutate(cols = as.numeric(block)) %>% 
  group_by(cols) %>% 
  mutate(rows = 1:n())
```

```{r}
bib_obj %>% 
  pluck("sketch") %>% 
  t()
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-8
#| fig-align: center
#| fig-height: 3
#| fig-width: 6
#| fig-cap: "foo."
desplot(trt ~ cols + rows, flip = TRUE,
        text = trt, cex = 1, shorten = "no",
        out1 = block,
        data = bib_plot_tbl,
        main = "Incomplete block design (2-faktoriell)", 
        show.key = FALSE, key.cex = 0.5)
```

## Strip plot design (3-faktoriell) {#sec-strip-plot}

Das Streifenparzellenversuch (eng. *strip plot design*) orientiert sich an dem [Strip-plot experiment of rice](https://kwstat.github.io/agridat/reference/gomez.stripplot.html) aus @gomez1984statistical. Du findest dann das Datenbeispiel auch in `agridat` als `data(gomez.stripplot)`. Ich habe versucht jetzt die Daten in der Form nachzubauen und somit kannst du dann auch ähnliche Experimente planen.

Ein Streifenparzellenversuch (eng. *strip plot design*) mit drei Wiederholungen `block`, Sorte `trt_gen` als horizontaler Streifen und Stickstoffdünger `trt_nitro` als vertikaler Streifen.

```{r}
trt_gen <- str_c("G", 1:6)
n_trt_gen <- n_distinct(trt_gen)
trt_nitro <- c(0, 60, 120)
n_trt_nitro <- n_distinct(trt_nitro)
n_block <- 3
```

Erst der kurze Vektor dann der lange

```{r}
strip_obj <- design.strip(trt1 = trt_nitro, 
                          trt2 = trt_gen, 
                          r = n_block, serie = 2, seed = 543)
```

```{r}
strip_plot_tbl <- strip_obj$book %>% 
  bind_cols(expand_grid(cols = 1:(n_trt_nitro*n_block), rows = 1:n_trt_gen))
```

```{r}
#| message: false
#| warning: false
#| label: fig-exp-adv-9
#| fig-align: center
#| fig-height: 4
#| fig-width: 6
#| fig-cap: "foo."
desplot(trt_gen ~ cols*rows,
        out1 = block, out2 = trt_nitro, num = trt_nitro, cex=1,
        show.key = FALSE, data = strip_plot_tbl,
        main = "Strip plot design (3-faktoriell)")
```

## Referenzen {.unnumbered}
